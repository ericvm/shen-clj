"Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

(defun shen.typecheck (V3644 V3645) (let Curry (shen.curry V3644) (let ProcessN (shen.start-new-prolog-process) (let Type (shen.insert-prolog-variables (shen.demodulate (shen.curry-type V3645)) ProcessN) (let Continuation (freeze (return Type ProcessN shen.void)) (shen.t* (cons Curry (cons : (cons Type ()))) () ProcessN Continuation))))))

(defun shen.curry (V3647) (cond ((and (cons? V3647) (shen.special? (hd V3647))) (cons (hd V3647) (map (lambda Y (shen.curry Y)) (tl V3647)))) ((and (cons? V3647) (and (cons? (tl V3647)) (shen.extraspecial? (hd V3647)))) V3647) ((and (cons? V3647) (and (= type (hd V3647)) (and (cons? (tl V3647)) (and (cons? (tl (tl V3647))) (= () (tl (tl (tl V3647)))))))) (cons type (cons (shen.curry (hd (tl V3647))) (tl (tl V3647))))) ((and (cons? V3647) (and (cons? (tl V3647)) (cons? (tl (tl V3647))))) (shen.curry (cons (cons (hd V3647) (cons (hd (tl V3647)) ())) (tl (tl V3647))))) ((and (cons? V3647) (and (cons? (tl V3647)) (= () (tl (tl V3647))))) (cons (shen.curry (hd V3647)) (cons (shen.curry (hd (tl V3647))) ()))) (true V3647)))

(defun shen.special? (V3649) (element? V3649 (value shen.*special*)))

(defun shen.extraspecial? (V3651) (element? V3651 (value shen.*extraspecial*)))

(defun shen.t* (V3656 V3657 V3658 V3659) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let Error (shen.newpv V3658) (do (shen.incinfs) (fwhen (shen.maxinfexceeded?) V3658 (freeze (bind Error (shen.errormaxinfs) V3658 V3659))))) (if (= Case false) (let Case (let V3636 (shen.lazyderef V3656 V3658) (if (= fail V3636) (do (shen.incinfs) (cut Throwcontrol V3658 (freeze (shen.prolog-failure V3658 V3659)))) false)) (if (= Case false) (let Case (let V3637 (shen.lazyderef V3656 V3658) (if (cons? V3637) (let X (hd V3637) (let V3638 (shen.lazyderef (tl V3637) V3658) (if (cons? V3638) (let V3639 (shen.lazyderef (hd V3638) V3658) (if (= : V3639) (let V3640 (shen.lazyderef (tl V3638) V3658) (if (cons? V3640) (let A (hd V3640) (let V3641 (shen.lazyderef (tl V3640) V3658) (if (= () V3641) (do (shen.incinfs) (fwhen (shen.type-theory-enabled?) V3658 (freeze (cut Throwcontrol V3658 (freeze (shen.th* X A V3657 V3658 V3659)))))) false))) false)) false)) false))) false)) (if (= Case false) (let Datatypes (shen.newpv V3658) (do (shen.incinfs) (shen.show V3656 V3657 V3658 (freeze (bind Datatypes (value shen.*datatypes*) V3658 (freeze (shen.udefs* V3656 V3657 Datatypes V3658 V3659))))))) Case)) Case)) Case)))))

(defun shen.type-theory-enabled? () (value shen.*shen-type-theory-enabled?*))

(defun enable-type-theory (V3665) (cond ((= + V3665) (set shen.*shen-type-theory-enabled?* true)) ((= - V3665) (set shen.*shen-type-theory-enabled?* false)) (true (simple-error "enable-type-theory expects a + or a -
"))))

(defun shen.prolog-failure (V3676 V3677) false)

(defun shen.maxinfexceeded? () (> (inferences) (value shen.*maxinferences*)))

(defun shen.errormaxinfs () (simple-error "maximum inferences exceeded~%"))

(defun shen.udefs* (V3683 V3684 V3685 V3686 V3687) (let Case (let V3632 (shen.lazyderef V3685 V3686) (if (cons? V3632) (let D (hd V3632) (do (shen.incinfs) (call (cons D (cons V3683 (cons V3684 ()))) V3686 V3687))) false)) (if (= Case false) (let V3633 (shen.lazyderef V3685 V3686) (if (cons? V3633) (let Ds (tl V3633) (do (shen.incinfs) (shen.udefs* V3683 V3684 Ds V3686 V3687))) false)) Case)))

(defun shen.th* (V3693 V3694 V3695 V3696 V3697) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (do (shen.incinfs) (shen.show (cons V3693 (cons : (cons V3694 ()))) V3695 V3696 (freeze (fwhen false V3696 V3697)))) (if (= Case false) (let Case (let F (shen.newpv V3696) (do (shen.incinfs) (fwhen (shen.typedf? (shen.lazyderef V3693 V3696)) V3696 (freeze (bind F (shen.sigf (shen.lazyderef V3693 V3696)) V3696 (freeze (call (cons F (cons V3694 ())) V3696 V3697))))))) (if (= Case false) (let Case (do (shen.incinfs) (shen.base V3693 V3694 V3696 V3697)) (if (= Case false) (let Case (do (shen.incinfs) (shen.by_hypothesis V3693 V3694 V3695 V3696 V3697)) (if (= Case false) (let Case (let V3528 (shen.lazyderef V3693 V3696) (if (cons? V3528) (let F (hd V3528) (let V3529 (shen.lazyderef (tl V3528) V3696) (if (= () V3529) (do (shen.incinfs) (shen.th* F (cons --> (cons V3694 ())) V3695 V3696 V3697)) false))) false)) (if (= Case false) (let Case (let V3530 (shen.lazyderef V3693 V3696) (if (cons? V3530) (let F (hd V3530) (let V3531 (shen.lazyderef (tl V3530) V3696) (if (cons? V3531) (let X (hd V3531) (let V3532 (shen.lazyderef (tl V3531) V3696) (if (= () V3532) (let B (shen.newpv V3696) (do (shen.incinfs) (shen.th* F (cons B (cons --> (cons V3694 ()))) V3695 V3696 (freeze (shen.th* X B V3695 V3696 V3697))))) false))) false))) false)) (if (= Case false) (let Case (let V3533 (shen.lazyderef V3693 V3696) (if (cons? V3533) (let V3534 (shen.lazyderef (hd V3533) V3696) (if (= cons V3534) (let V3535 (shen.lazyderef (tl V3533) V3696) (if (cons? V3535) (let X (hd V3535) (let V3536 (shen.lazyderef (tl V3535) V3696) (if (cons? V3536) (let Y (hd V3536) (let V3537 (shen.lazyderef (tl V3536) V3696) (if (= () V3537) (let V3538 (shen.lazyderef V3694 V3696) (if (cons? V3538) (let V3539 (shen.lazyderef (hd V3538) V3696) (if (= list V3539) (let V3540 (shen.lazyderef (tl V3538) V3696) (if (cons? V3540) (let A (hd V3540) (let V3541 (shen.lazyderef (tl V3540) V3696) (if (= () V3541) (do (shen.incinfs) (shen.th* X A V3695 V3696 (freeze (shen.th* Y (cons list (cons A ())) V3695 V3696 V3697)))) (if (shen.pvar? V3541) (do (shen.bindv V3541 () V3696) (let Result (do (shen.incinfs) (shen.th* X A V3695 V3696 (freeze (shen.th* Y (cons list (cons A ())) V3695 V3696 V3697)))) (do (shen.unbindv V3541 V3696) Result))) false)))) (if (shen.pvar? V3540) (let A (shen.newpv V3696) (do (shen.bindv V3540 (cons A ()) V3696) (let Result (do (shen.incinfs) (shen.th* X A V3695 V3696 (freeze (shen.th* Y (cons list (cons A ())) V3695 V3696 V3697)))) (do (shen.unbindv V3540 V3696) Result)))) false))) (if (shen.pvar? V3539) (do (shen.bindv V3539 list V3696) (let Result (let V3542 (shen.lazyderef (tl V3538) V3696) (if (cons? V3542) (let A (hd V3542) (let V3543 (shen.lazyderef (tl V3542) V3696) (if (= () V3543) (do (shen.incinfs) (shen.th* X A V3695 V3696 (freeze (shen.th* Y (cons list (cons A ())) V3695 V3696 V3697)))) (if (shen.pvar? V3543) (do (shen.bindv V3543 () V3696) (let Result (do (shen.incinfs) (shen.th* X A V3695 V3696 (freeze (shen.th* Y (cons list (cons A ())) V3695 V3696 V3697)))) (do (shen.unbindv V3543 V3696) Result))) false)))) (if (shen.pvar? V3542) (let A (shen.newpv V3696) (do (shen.bindv V3542 (cons A ()) V3696) (let Result (do (shen.incinfs) (shen.th* X A V3695 V3696 (freeze (shen.th* Y (cons list (cons A ())) V3695 V3696 V3697)))) (do (shen.unbindv V3542 V3696) Result)))) false))) (do (shen.unbindv V3539 V3696) Result))) false))) (if (shen.pvar? V3538) (let A (shen.newpv V3696) (do (shen.bindv V3538 (cons list (cons A ())) V3696) (let Result (do (shen.incinfs) (shen.th* X A V3695 V3696 (freeze (shen.th* Y (cons list (cons A ())) V3695 V3696 V3697)))) (do (shen.unbindv V3538 V3696) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3544 (shen.lazyderef V3693 V3696) (if (cons? V3544) (let V3545 (shen.lazyderef (hd V3544) V3696) (if (= @p V3545) (let V3546 (shen.lazyderef (tl V3544) V3696) (if (cons? V3546) (let X (hd V3546) (let V3547 (shen.lazyderef (tl V3546) V3696) (if (cons? V3547) (let Y (hd V3547) (let V3548 (shen.lazyderef (tl V3547) V3696) (if (= () V3548) (let V3549 (shen.lazyderef V3694 V3696) (if (cons? V3549) (let A (hd V3549) (let V3550 (shen.lazyderef (tl V3549) V3696) (if (cons? V3550) (let V3551 (shen.lazyderef (hd V3550) V3696) (if (= * V3551) (let V3552 (shen.lazyderef (tl V3550) V3696) (if (cons? V3552) (let B (hd V3552) (let V3553 (shen.lazyderef (tl V3552) V3696) (if (= () V3553) (do (shen.incinfs) (shen.th* X A V3695 V3696 (freeze (shen.th* Y B V3695 V3696 V3697)))) (if (shen.pvar? V3553) (do (shen.bindv V3553 () V3696) (let Result (do (shen.incinfs) (shen.th* X A V3695 V3696 (freeze (shen.th* Y B V3695 V3696 V3697)))) (do (shen.unbindv V3553 V3696) Result))) false)))) (if (shen.pvar? V3552) (let B (shen.newpv V3696) (do (shen.bindv V3552 (cons B ()) V3696) (let Result (do (shen.incinfs) (shen.th* X A V3695 V3696 (freeze (shen.th* Y B V3695 V3696 V3697)))) (do (shen.unbindv V3552 V3696) Result)))) false))) (if (shen.pvar? V3551) (do (shen.bindv V3551 * V3696) (let Result (let V3554 (shen.lazyderef (tl V3550) V3696) (if (cons? V3554) (let B (hd V3554) (let V3555 (shen.lazyderef (tl V3554) V3696) (if (= () V3555) (do (shen.incinfs) (shen.th* X A V3695 V3696 (freeze (shen.th* Y B V3695 V3696 V3697)))) (if (shen.pvar? V3555) (do (shen.bindv V3555 () V3696) (let Result (do (shen.incinfs) (shen.th* X A V3695 V3696 (freeze (shen.th* Y B V3695 V3696 V3697)))) (do (shen.unbindv V3555 V3696) Result))) false)))) (if (shen.pvar? V3554) (let B (shen.newpv V3696) (do (shen.bindv V3554 (cons B ()) V3696) (let Result (do (shen.incinfs) (shen.th* X A V3695 V3696 (freeze (shen.th* Y B V3695 V3696 V3697)))) (do (shen.unbindv V3554 V3696) Result)))) false))) (do (shen.unbindv V3551 V3696) Result))) false))) (if (shen.pvar? V3550) (let B (shen.newpv V3696) (do (shen.bindv V3550 (cons * (cons B ())) V3696) (let Result (do (shen.incinfs) (shen.th* X A V3695 V3696 (freeze (shen.th* Y B V3695 V3696 V3697)))) (do (shen.unbindv V3550 V3696) Result)))) false)))) (if (shen.pvar? V3549) (let A (shen.newpv V3696) (let B (shen.newpv V3696) (do (shen.bindv V3549 (cons A (cons * (cons B ()))) V3696) (let Result (do (shen.incinfs) (shen.th* X A V3695 V3696 (freeze (shen.th* Y B V3695 V3696 V3697)))) (do (shen.unbindv V3549 V3696) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3556 (shen.lazyderef V3693 V3696) (if (cons? V3556) (let V3557 (shen.lazyderef (hd V3556) V3696) (if (= @v V3557) (let V3558 (shen.lazyderef (tl V3556) V3696) (if (cons? V3558) (let X (hd V3558) (let V3559 (shen.lazyderef (tl V3558) V3696) (if (cons? V3559) (let Y (hd V3559) (let V3560 (shen.lazyderef (tl V3559) V3696) (if (= () V3560) (let V3561 (shen.lazyderef V3694 V3696) (if (cons? V3561) (let V3562 (shen.lazyderef (hd V3561) V3696) (if (= vector V3562) (let V3563 (shen.lazyderef (tl V3561) V3696) (if (cons? V3563) (let A (hd V3563) (let V3564 (shen.lazyderef (tl V3563) V3696) (if (= () V3564) (do (shen.incinfs) (shen.th* X A V3695 V3696 (freeze (shen.th* Y (cons vector (cons A ())) V3695 V3696 V3697)))) (if (shen.pvar? V3564) (do (shen.bindv V3564 () V3696) (let Result (do (shen.incinfs) (shen.th* X A V3695 V3696 (freeze (shen.th* Y (cons vector (cons A ())) V3695 V3696 V3697)))) (do (shen.unbindv V3564 V3696) Result))) false)))) (if (shen.pvar? V3563) (let A (shen.newpv V3696) (do (shen.bindv V3563 (cons A ()) V3696) (let Result (do (shen.incinfs) (shen.th* X A V3695 V3696 (freeze (shen.th* Y (cons vector (cons A ())) V3695 V3696 V3697)))) (do (shen.unbindv V3563 V3696) Result)))) false))) (if (shen.pvar? V3562) (do (shen.bindv V3562 vector V3696) (let Result (let V3565 (shen.lazyderef (tl V3561) V3696) (if (cons? V3565) (let A (hd V3565) (let V3566 (shen.lazyderef (tl V3565) V3696) (if (= () V3566) (do (shen.incinfs) (shen.th* X A V3695 V3696 (freeze (shen.th* Y (cons vector (cons A ())) V3695 V3696 V3697)))) (if (shen.pvar? V3566) (do (shen.bindv V3566 () V3696) (let Result (do (shen.incinfs) (shen.th* X A V3695 V3696 (freeze (shen.th* Y (cons vector (cons A ())) V3695 V3696 V3697)))) (do (shen.unbindv V3566 V3696) Result))) false)))) (if (shen.pvar? V3565) (let A (shen.newpv V3696) (do (shen.bindv V3565 (cons A ()) V3696) (let Result (do (shen.incinfs) (shen.th* X A V3695 V3696 (freeze (shen.th* Y (cons vector (cons A ())) V3695 V3696 V3697)))) (do (shen.unbindv V3565 V3696) Result)))) false))) (do (shen.unbindv V3562 V3696) Result))) false))) (if (shen.pvar? V3561) (let A (shen.newpv V3696) (do (shen.bindv V3561 (cons vector (cons A ())) V3696) (let Result (do (shen.incinfs) (shen.th* X A V3695 V3696 (freeze (shen.th* Y (cons vector (cons A ())) V3695 V3696 V3697)))) (do (shen.unbindv V3561 V3696) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3567 (shen.lazyderef V3693 V3696) (if (cons? V3567) (let V3568 (shen.lazyderef (hd V3567) V3696) (if (= @s V3568) (let V3569 (shen.lazyderef (tl V3567) V3696) (if (cons? V3569) (let X (hd V3569) (let V3570 (shen.lazyderef (tl V3569) V3696) (if (cons? V3570) (let Y (hd V3570) (let V3571 (shen.lazyderef (tl V3570) V3696) (if (= () V3571) (let V3572 (shen.lazyderef V3694 V3696) (if (= string V3572) (do (shen.incinfs) (shen.th* X string V3695 V3696 (freeze (shen.th* Y string V3695 V3696 V3697)))) (if (shen.pvar? V3572) (do (shen.bindv V3572 string V3696) (let Result (do (shen.incinfs) (shen.th* X string V3695 V3696 (freeze (shen.th* Y string V3695 V3696 V3697)))) (do (shen.unbindv V3572 V3696) Result))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3573 (shen.lazyderef V3693 V3696) (if (cons? V3573) (let V3574 (shen.lazyderef (hd V3573) V3696) (if (= lambda V3574) (let V3575 (shen.lazyderef (tl V3573) V3696) (if (cons? V3575) (let X (hd V3575) (let V3576 (shen.lazyderef (tl V3575) V3696) (if (cons? V3576) (let Y (hd V3576) (let V3577 (shen.lazyderef (tl V3576) V3696) (if (= () V3577) (let V3578 (shen.lazyderef V3694 V3696) (if (cons? V3578) (let A (hd V3578) (let V3579 (shen.lazyderef (tl V3578) V3696) (if (cons? V3579) (let V3580 (shen.lazyderef (hd V3579) V3696) (if (= --> V3580) (let V3581 (shen.lazyderef (tl V3579) V3696) (if (cons? V3581) (let B (hd V3581) (let V3582 (shen.lazyderef (tl V3581) V3696) (if (= () V3582) (let Z (shen.newpv V3696) (let X&& (shen.newpv V3696) (do (shen.incinfs) (cut Throwcontrol V3696 (freeze (bind X&& (shen.placeholder) V3696 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3696) (shen.lazyderef X V3696) (shen.lazyderef Y V3696)) V3696 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3695) V3696 V3697)))))))))) (if (shen.pvar? V3582) (do (shen.bindv V3582 () V3696) (let Result (let Z (shen.newpv V3696) (let X&& (shen.newpv V3696) (do (shen.incinfs) (cut Throwcontrol V3696 (freeze (bind X&& (shen.placeholder) V3696 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3696) (shen.lazyderef X V3696) (shen.lazyderef Y V3696)) V3696 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3695) V3696 V3697)))))))))) (do (shen.unbindv V3582 V3696) Result))) false)))) (if (shen.pvar? V3581) (let B (shen.newpv V3696) (do (shen.bindv V3581 (cons B ()) V3696) (let Result (let Z (shen.newpv V3696) (let X&& (shen.newpv V3696) (do (shen.incinfs) (cut Throwcontrol V3696 (freeze (bind X&& (shen.placeholder) V3696 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3696) (shen.lazyderef X V3696) (shen.lazyderef Y V3696)) V3696 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3695) V3696 V3697)))))))))) (do (shen.unbindv V3581 V3696) Result)))) false))) (if (shen.pvar? V3580) (do (shen.bindv V3580 --> V3696) (let Result (let V3583 (shen.lazyderef (tl V3579) V3696) (if (cons? V3583) (let B (hd V3583) (let V3584 (shen.lazyderef (tl V3583) V3696) (if (= () V3584) (let Z (shen.newpv V3696) (let X&& (shen.newpv V3696) (do (shen.incinfs) (cut Throwcontrol V3696 (freeze (bind X&& (shen.placeholder) V3696 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3696) (shen.lazyderef X V3696) (shen.lazyderef Y V3696)) V3696 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3695) V3696 V3697)))))))))) (if (shen.pvar? V3584) (do (shen.bindv V3584 () V3696) (let Result (let Z (shen.newpv V3696) (let X&& (shen.newpv V3696) (do (shen.incinfs) (cut Throwcontrol V3696 (freeze (bind X&& (shen.placeholder) V3696 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3696) (shen.lazyderef X V3696) (shen.lazyderef Y V3696)) V3696 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3695) V3696 V3697)))))))))) (do (shen.unbindv V3584 V3696) Result))) false)))) (if (shen.pvar? V3583) (let B (shen.newpv V3696) (do (shen.bindv V3583 (cons B ()) V3696) (let Result (let Z (shen.newpv V3696) (let X&& (shen.newpv V3696) (do (shen.incinfs) (cut Throwcontrol V3696 (freeze (bind X&& (shen.placeholder) V3696 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3696) (shen.lazyderef X V3696) (shen.lazyderef Y V3696)) V3696 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3695) V3696 V3697)))))))))) (do (shen.unbindv V3583 V3696) Result)))) false))) (do (shen.unbindv V3580 V3696) Result))) false))) (if (shen.pvar? V3579) (let B (shen.newpv V3696) (do (shen.bindv V3579 (cons --> (cons B ())) V3696) (let Result (let Z (shen.newpv V3696) (let X&& (shen.newpv V3696) (do (shen.incinfs) (cut Throwcontrol V3696 (freeze (bind X&& (shen.placeholder) V3696 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3696) (shen.lazyderef X V3696) (shen.lazyderef Y V3696)) V3696 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3695) V3696 V3697)))))))))) (do (shen.unbindv V3579 V3696) Result)))) false)))) (if (shen.pvar? V3578) (let A (shen.newpv V3696) (let B (shen.newpv V3696) (do (shen.bindv V3578 (cons A (cons --> (cons B ()))) V3696) (let Result (let Z (shen.newpv V3696) (let X&& (shen.newpv V3696) (do (shen.incinfs) (cut Throwcontrol V3696 (freeze (bind X&& (shen.placeholder) V3696 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3696) (shen.lazyderef X V3696) (shen.lazyderef Y V3696)) V3696 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3695) V3696 V3697)))))))))) (do (shen.unbindv V3578 V3696) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3585 (shen.lazyderef V3693 V3696) (if (cons? V3585) (let V3586 (shen.lazyderef (hd V3585) V3696) (if (= let V3586) (let V3587 (shen.lazyderef (tl V3585) V3696) (if (cons? V3587) (let X (hd V3587) (let V3588 (shen.lazyderef (tl V3587) V3696) (if (cons? V3588) (let Y (hd V3588) (let V3589 (shen.lazyderef (tl V3588) V3696) (if (cons? V3589) (let Z (hd V3589) (let V3590 (shen.lazyderef (tl V3589) V3696) (if (= () V3590) (let W (shen.newpv V3696) (let X&& (shen.newpv V3696) (let B (shen.newpv V3696) (do (shen.incinfs) (shen.th* Y B V3695 V3696 (freeze (bind X&& (shen.placeholder) V3696 (freeze (bind W (shen.ebr (shen.lazyderef X&& V3696) (shen.lazyderef X V3696) (shen.lazyderef Z V3696)) V3696 (freeze (shen.th* W V3694 (cons (cons X&& (cons : (cons B ()))) V3695) V3696 V3697))))))))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3591 (shen.lazyderef V3693 V3696) (if (cons? V3591) (let V3592 (shen.lazyderef (hd V3591) V3696) (if (= open V3592) (let V3593 (shen.lazyderef (tl V3591) V3696) (if (cons? V3593) (let FileName (hd V3593) (let V3594 (shen.lazyderef (tl V3593) V3696) (if (cons? V3594) (let Direction3524 (hd V3594) (let V3595 (shen.lazyderef (tl V3594) V3696) (if (= () V3595) (let V3596 (shen.lazyderef V3694 V3696) (if (cons? V3596) (let V3597 (shen.lazyderef (hd V3596) V3696) (if (= stream V3597) (let V3598 (shen.lazyderef (tl V3596) V3696) (if (cons? V3598) (let Direction (hd V3598) (let V3599 (shen.lazyderef (tl V3598) V3696) (if (= () V3599) (do (shen.incinfs) (unify! Direction Direction3524 V3696 (freeze (cut Throwcontrol V3696 (freeze (fwhen (element? (shen.lazyderef Direction V3696) (cons in (cons out ()))) V3696 (freeze (shen.th* FileName string V3695 V3696 V3697)))))))) (if (shen.pvar? V3599) (do (shen.bindv V3599 () V3696) (let Result (do (shen.incinfs) (unify! Direction Direction3524 V3696 (freeze (cut Throwcontrol V3696 (freeze (fwhen (element? (shen.lazyderef Direction V3696) (cons in (cons out ()))) V3696 (freeze (shen.th* FileName string V3695 V3696 V3697)))))))) (do (shen.unbindv V3599 V3696) Result))) false)))) (if (shen.pvar? V3598) (let Direction (shen.newpv V3696) (do (shen.bindv V3598 (cons Direction ()) V3696) (let Result (do (shen.incinfs) (unify! Direction Direction3524 V3696 (freeze (cut Throwcontrol V3696 (freeze (fwhen (element? (shen.lazyderef Direction V3696) (cons in (cons out ()))) V3696 (freeze (shen.th* FileName string V3695 V3696 V3697)))))))) (do (shen.unbindv V3598 V3696) Result)))) false))) (if (shen.pvar? V3597) (do (shen.bindv V3597 stream V3696) (let Result (let V3600 (shen.lazyderef (tl V3596) V3696) (if (cons? V3600) (let Direction (hd V3600) (let V3601 (shen.lazyderef (tl V3600) V3696) (if (= () V3601) (do (shen.incinfs) (unify! Direction Direction3524 V3696 (freeze (cut Throwcontrol V3696 (freeze (fwhen (element? (shen.lazyderef Direction V3696) (cons in (cons out ()))) V3696 (freeze (shen.th* FileName string V3695 V3696 V3697)))))))) (if (shen.pvar? V3601) (do (shen.bindv V3601 () V3696) (let Result (do (shen.incinfs) (unify! Direction Direction3524 V3696 (freeze (cut Throwcontrol V3696 (freeze (fwhen (element? (shen.lazyderef Direction V3696) (cons in (cons out ()))) V3696 (freeze (shen.th* FileName string V3695 V3696 V3697)))))))) (do (shen.unbindv V3601 V3696) Result))) false)))) (if (shen.pvar? V3600) (let Direction (shen.newpv V3696) (do (shen.bindv V3600 (cons Direction ()) V3696) (let Result (do (shen.incinfs) (unify! Direction Direction3524 V3696 (freeze (cut Throwcontrol V3696 (freeze (fwhen (element? (shen.lazyderef Direction V3696) (cons in (cons out ()))) V3696 (freeze (shen.th* FileName string V3695 V3696 V3697)))))))) (do (shen.unbindv V3600 V3696) Result)))) false))) (do (shen.unbindv V3597 V3696) Result))) false))) (if (shen.pvar? V3596) (let Direction (shen.newpv V3696) (do (shen.bindv V3596 (cons stream (cons Direction ())) V3696) (let Result (do (shen.incinfs) (unify! Direction Direction3524 V3696 (freeze (cut Throwcontrol V3696 (freeze (fwhen (element? (shen.lazyderef Direction V3696) (cons in (cons out ()))) V3696 (freeze (shen.th* FileName string V3695 V3696 V3697)))))))) (do (shen.unbindv V3596 V3696) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3602 (shen.lazyderef V3693 V3696) (if (cons? V3602) (let V3603 (shen.lazyderef (hd V3602) V3696) (if (= type V3603) (let V3604 (shen.lazyderef (tl V3602) V3696) (if (cons? V3604) (let X (hd V3604) (let V3605 (shen.lazyderef (tl V3604) V3696) (if (cons? V3605) (let A (hd V3605) (let V3606 (shen.lazyderef (tl V3605) V3696) (if (= () V3606) (do (shen.incinfs) (cut Throwcontrol V3696 (freeze (unify A V3694 V3696 (freeze (shen.th* X A V3695 V3696 V3697)))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3607 (shen.lazyderef V3693 V3696) (if (cons? V3607) (let V3608 (shen.lazyderef (hd V3607) V3696) (if (= input+ V3608) (let V3609 (shen.lazyderef (tl V3607) V3696) (if (cons? V3609) (let A (hd V3609) (let V3610 (shen.lazyderef (tl V3609) V3696) (if (cons? V3610) (let Stream (hd V3610) (let V3611 (shen.lazyderef (tl V3610) V3696) (if (= () V3611) (let C (shen.newpv V3696) (do (shen.incinfs) (bind C (shen.demodulate (shen.lazyderef A V3696)) V3696 (freeze (unify V3694 C V3696 (freeze (shen.th* Stream (cons stream (cons in ())) V3695 V3696 V3697))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3612 (shen.lazyderef V3693 V3696) (if (cons? V3612) (let V3613 (shen.lazyderef (hd V3612) V3696) (if (= set V3613) (let V3614 (shen.lazyderef (tl V3612) V3696) (if (cons? V3614) (let Var (hd V3614) (let V3615 (shen.lazyderef (tl V3614) V3696) (if (cons? V3615) (let Val (hd V3615) (let V3616 (shen.lazyderef (tl V3615) V3696) (if (= () V3616) (do (shen.incinfs) (cut Throwcontrol V3696 (freeze (shen.th* Var symbol V3695 V3696 (freeze (cut Throwcontrol V3696 (freeze (shen.th* (cons value (cons Var ())) V3694 V3695 V3696 (freeze (shen.th* Val V3694 V3695 V3696 V3697)))))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let NewHyp (shen.newpv V3696) (do (shen.incinfs) (shen.t*-hyps V3695 NewHyp V3696 (freeze (shen.th* V3693 V3694 NewHyp V3696 V3697))))) (if (= Case false) (let Case (let V3617 (shen.lazyderef V3693 V3696) (if (cons? V3617) (let V3618 (shen.lazyderef (hd V3617) V3696) (if (= define V3618) (let V3619 (shen.lazyderef (tl V3617) V3696) (if (cons? V3619) (let F (hd V3619) (let X (tl V3619) (do (shen.incinfs) (cut Throwcontrol V3696 (freeze (shen.t*-def (cons define (cons F X)) V3694 V3695 V3696 V3697)))))) false)) false)) false)) (if (= Case false) (let Case (let V3620 (shen.lazyderef V3693 V3696) (if (cons? V3620) (let V3621 (shen.lazyderef (hd V3620) V3696) (if (= defmacro V3621) (let V3622 (shen.lazyderef V3694 V3696) (if (= unit V3622) (do (shen.incinfs) (cut Throwcontrol V3696 V3697)) (if (shen.pvar? V3622) (do (shen.bindv V3622 unit V3696) (let Result (do (shen.incinfs) (cut Throwcontrol V3696 V3697)) (do (shen.unbindv V3622 V3696) Result))) false))) false)) false)) (if (= Case false) (let Case (let V3623 (shen.lazyderef V3693 V3696) (if (cons? V3623) (let V3624 (shen.lazyderef (hd V3623) V3696) (if (= shen.process-datatype V3624) (let V3625 (shen.lazyderef V3694 V3696) (if (= symbol V3625) (do (shen.incinfs) (thaw V3697)) (if (shen.pvar? V3625) (do (shen.bindv V3625 symbol V3696) (let Result (do (shen.incinfs) (thaw V3697)) (do (shen.unbindv V3625 V3696) Result))) false))) false)) false)) (if (= Case false) (let Case (let V3626 (shen.lazyderef V3693 V3696) (if (cons? V3626) (let V3627 (shen.lazyderef (hd V3626) V3696) (if (= shen.synonyms-help V3627) (let V3628 (shen.lazyderef V3694 V3696) (if (= symbol V3628) (do (shen.incinfs) (thaw V3697)) (if (shen.pvar? V3628) (do (shen.bindv V3628 symbol V3696) (let Result (do (shen.incinfs) (thaw V3697)) (do (shen.unbindv V3628 V3696) Result))) false))) false)) false)) (if (= Case false) (let Datatypes (shen.newpv V3696) (do (shen.incinfs) (bind Datatypes (value shen.*datatypes*) V3696 (freeze (shen.udefs* (cons V3693 (cons : (cons V3694 ()))) V3695 Datatypes V3696 V3697))))) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)))))

(defun shen.t*-hyps (V3702 V3703 V3704 V3705) (let Case (let V3439 (shen.lazyderef V3702 V3704) (if (cons? V3439) (let V3440 (shen.lazyderef (hd V3439) V3704) (if (cons? V3440) (let V3441 (shen.lazyderef (hd V3440) V3704) (if (cons? V3441) (let V3442 (shen.lazyderef (hd V3441) V3704) (if (= cons V3442) (let V3443 (shen.lazyderef (tl V3441) V3704) (if (cons? V3443) (let X (hd V3443) (let V3444 (shen.lazyderef (tl V3443) V3704) (if (cons? V3444) (let Y (hd V3444) (let V3445 (shen.lazyderef (tl V3444) V3704) (if (= () V3445) (let V3446 (shen.lazyderef (tl V3440) V3704) (if (cons? V3446) (let V3447 (shen.lazyderef (hd V3446) V3704) (if (= : V3447) (let V3448 (shen.lazyderef (tl V3446) V3704) (if (cons? V3448) (let V3449 (shen.lazyderef (hd V3448) V3704) (if (cons? V3449) (let V3450 (shen.lazyderef (hd V3449) V3704) (if (= list V3450) (let V3451 (shen.lazyderef (tl V3449) V3704) (if (cons? V3451) (let A (hd V3451) (let V3452 (shen.lazyderef (tl V3451) V3704) (if (= () V3452) (let V3453 (shen.lazyderef (tl V3448) V3704) (if (= () V3453) (let Hyp (tl V3439) (do (shen.incinfs) (bind V3703 (cons (cons (shen.lazyderef X V3704) (cons : (cons (shen.lazyderef A V3704) ()))) (cons (cons (shen.lazyderef Y V3704) (cons : (cons (cons list (cons (shen.lazyderef A V3704) ())) ()))) (shen.lazyderef Hyp V3704))) V3704 V3705))) (if (shen.pvar? V3453) (do (shen.bindv V3453 () V3704) (let Result (let Hyp (tl V3439) (do (shen.incinfs) (bind V3703 (cons (cons (shen.lazyderef X V3704) (cons : (cons (shen.lazyderef A V3704) ()))) (cons (cons (shen.lazyderef Y V3704) (cons : (cons (cons list (cons (shen.lazyderef A V3704) ())) ()))) (shen.lazyderef Hyp V3704))) V3704 V3705))) (do (shen.unbindv V3453 V3704) Result))) false))) (if (shen.pvar? V3452) (do (shen.bindv V3452 () V3704) (let Result (let V3454 (shen.lazyderef (tl V3448) V3704) (if (= () V3454) (let Hyp (tl V3439) (do (shen.incinfs) (bind V3703 (cons (cons (shen.lazyderef X V3704) (cons : (cons (shen.lazyderef A V3704) ()))) (cons (cons (shen.lazyderef Y V3704) (cons : (cons (cons list (cons (shen.lazyderef A V3704) ())) ()))) (shen.lazyderef Hyp V3704))) V3704 V3705))) (if (shen.pvar? V3454) (do (shen.bindv V3454 () V3704) (let Result (let Hyp (tl V3439) (do (shen.incinfs) (bind V3703 (cons (cons (shen.lazyderef X V3704) (cons : (cons (shen.lazyderef A V3704) ()))) (cons (cons (shen.lazyderef Y V3704) (cons : (cons (cons list (cons (shen.lazyderef A V3704) ())) ()))) (shen.lazyderef Hyp V3704))) V3704 V3705))) (do (shen.unbindv V3454 V3704) Result))) false))) (do (shen.unbindv V3452 V3704) Result))) false)))) (if (shen.pvar? V3451) (let A (shen.newpv V3704) (do (shen.bindv V3451 (cons A ()) V3704) (let Result (let V3455 (shen.lazyderef (tl V3448) V3704) (if (= () V3455) (let Hyp (tl V3439) (do (shen.incinfs) (bind V3703 (cons (cons (shen.lazyderef X V3704) (cons : (cons (shen.lazyderef A V3704) ()))) (cons (cons (shen.lazyderef Y V3704) (cons : (cons (cons list (cons (shen.lazyderef A V3704) ())) ()))) (shen.lazyderef Hyp V3704))) V3704 V3705))) (if (shen.pvar? V3455) (do (shen.bindv V3455 () V3704) (let Result (let Hyp (tl V3439) (do (shen.incinfs) (bind V3703 (cons (cons (shen.lazyderef X V3704) (cons : (cons (shen.lazyderef A V3704) ()))) (cons (cons (shen.lazyderef Y V3704) (cons : (cons (cons list (cons (shen.lazyderef A V3704) ())) ()))) (shen.lazyderef Hyp V3704))) V3704 V3705))) (do (shen.unbindv V3455 V3704) Result))) false))) (do (shen.unbindv V3451 V3704) Result)))) false))) (if (shen.pvar? V3450) (do (shen.bindv V3450 list V3704) (let Result (let V3456 (shen.lazyderef (tl V3449) V3704) (if (cons? V3456) (let A (hd V3456) (let V3457 (shen.lazyderef (tl V3456) V3704) (if (= () V3457) (let V3458 (shen.lazyderef (tl V3448) V3704) (if (= () V3458) (let Hyp (tl V3439) (do (shen.incinfs) (bind V3703 (cons (cons (shen.lazyderef X V3704) (cons : (cons (shen.lazyderef A V3704) ()))) (cons (cons (shen.lazyderef Y V3704) (cons : (cons (cons list (cons (shen.lazyderef A V3704) ())) ()))) (shen.lazyderef Hyp V3704))) V3704 V3705))) (if (shen.pvar? V3458) (do (shen.bindv V3458 () V3704) (let Result (let Hyp (tl V3439) (do (shen.incinfs) (bind V3703 (cons (cons (shen.lazyderef X V3704) (cons : (cons (shen.lazyderef A V3704) ()))) (cons (cons (shen.lazyderef Y V3704) (cons : (cons (cons list (cons (shen.lazyderef A V3704) ())) ()))) (shen.lazyderef Hyp V3704))) V3704 V3705))) (do (shen.unbindv V3458 V3704) Result))) false))) (if (shen.pvar? V3457) (do (shen.bindv V3457 () V3704) (let Result (let V3459 (shen.lazyderef (tl V3448) V3704) (if (= () V3459) (let Hyp (tl V3439) (do (shen.incinfs) (bind V3703 (cons (cons (shen.lazyderef X V3704) (cons : (cons (shen.lazyderef A V3704) ()))) (cons (cons (shen.lazyderef Y V3704) (cons : (cons (cons list (cons (shen.lazyderef A V3704) ())) ()))) (shen.lazyderef Hyp V3704))) V3704 V3705))) (if (shen.pvar? V3459) (do (shen.bindv V3459 () V3704) (let Result (let Hyp (tl V3439) (do (shen.incinfs) (bind V3703 (cons (cons (shen.lazyderef X V3704) (cons : (cons (shen.lazyderef A V3704) ()))) (cons (cons (shen.lazyderef Y V3704) (cons : (cons (cons list (cons (shen.lazyderef A V3704) ())) ()))) (shen.lazyderef Hyp V3704))) V3704 V3705))) (do (shen.unbindv V3459 V3704) Result))) false))) (do (shen.unbindv V3457 V3704) Result))) false)))) (if (shen.pvar? V3456) (let A (shen.newpv V3704) (do (shen.bindv V3456 (cons A ()) V3704) (let Result (let V3460 (shen.lazyderef (tl V3448) V3704) (if (= () V3460) (let Hyp (tl V3439) (do (shen.incinfs) (bind V3703 (cons (cons (shen.lazyderef X V3704) (cons : (cons (shen.lazyderef A V3704) ()))) (cons (cons (shen.lazyderef Y V3704) (cons : (cons (cons list (cons (shen.lazyderef A V3704) ())) ()))) (shen.lazyderef Hyp V3704))) V3704 V3705))) (if (shen.pvar? V3460) (do (shen.bindv V3460 () V3704) (let Result (let Hyp (tl V3439) (do (shen.incinfs) (bind V3703 (cons (cons (shen.lazyderef X V3704) (cons : (cons (shen.lazyderef A V3704) ()))) (cons (cons (shen.lazyderef Y V3704) (cons : (cons (cons list (cons (shen.lazyderef A V3704) ())) ()))) (shen.lazyderef Hyp V3704))) V3704 V3705))) (do (shen.unbindv V3460 V3704) Result))) false))) (do (shen.unbindv V3456 V3704) Result)))) false))) (do (shen.unbindv V3450 V3704) Result))) false))) (if (shen.pvar? V3449) (let A (shen.newpv V3704) (do (shen.bindv V3449 (cons list (cons A ())) V3704) (let Result (let V3461 (shen.lazyderef (tl V3448) V3704) (if (= () V3461) (let Hyp (tl V3439) (do (shen.incinfs) (bind V3703 (cons (cons (shen.lazyderef X V3704) (cons : (cons (shen.lazyderef A V3704) ()))) (cons (cons (shen.lazyderef Y V3704) (cons : (cons (cons list (cons (shen.lazyderef A V3704) ())) ()))) (shen.lazyderef Hyp V3704))) V3704 V3705))) (if (shen.pvar? V3461) (do (shen.bindv V3461 () V3704) (let Result (let Hyp (tl V3439) (do (shen.incinfs) (bind V3703 (cons (cons (shen.lazyderef X V3704) (cons : (cons (shen.lazyderef A V3704) ()))) (cons (cons (shen.lazyderef Y V3704) (cons : (cons (cons list (cons (shen.lazyderef A V3704) ())) ()))) (shen.lazyderef Hyp V3704))) V3704 V3705))) (do (shen.unbindv V3461 V3704) Result))) false))) (do (shen.unbindv V3449 V3704) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V3462 (shen.lazyderef V3702 V3704) (if (cons? V3462) (let V3463 (shen.lazyderef (hd V3462) V3704) (if (cons? V3463) (let V3464 (shen.lazyderef (hd V3463) V3704) (if (cons? V3464) (let V3465 (shen.lazyderef (hd V3464) V3704) (if (= @p V3465) (let V3466 (shen.lazyderef (tl V3464) V3704) (if (cons? V3466) (let X (hd V3466) (let V3467 (shen.lazyderef (tl V3466) V3704) (if (cons? V3467) (let Y (hd V3467) (let V3468 (shen.lazyderef (tl V3467) V3704) (if (= () V3468) (let V3469 (shen.lazyderef (tl V3463) V3704) (if (cons? V3469) (let V3470 (shen.lazyderef (hd V3469) V3704) (if (= : V3470) (let V3471 (shen.lazyderef (tl V3469) V3704) (if (cons? V3471) (let V3472 (shen.lazyderef (hd V3471) V3704) (if (cons? V3472) (let A (hd V3472) (let V3473 (shen.lazyderef (tl V3472) V3704) (if (cons? V3473) (let V3474 (shen.lazyderef (hd V3473) V3704) (if (= * V3474) (let V3475 (shen.lazyderef (tl V3473) V3704) (if (cons? V3475) (let B (hd V3475) (let V3476 (shen.lazyderef (tl V3475) V3704) (if (= () V3476) (let V3477 (shen.lazyderef (tl V3471) V3704) (if (= () V3477) (let Hyp (tl V3462) (do (shen.incinfs) (bind V3703 (cons (cons (shen.lazyderef X V3704) (cons : (cons (shen.lazyderef A V3704) ()))) (cons (cons (shen.lazyderef Y V3704) (cons : (cons (shen.lazyderef B V3704) ()))) (shen.lazyderef Hyp V3704))) V3704 V3705))) (if (shen.pvar? V3477) (do (shen.bindv V3477 () V3704) (let Result (let Hyp (tl V3462) (do (shen.incinfs) (bind V3703 (cons (cons (shen.lazyderef X V3704) (cons : (cons (shen.lazyderef A V3704) ()))) (cons (cons (shen.lazyderef Y V3704) (cons : (cons (shen.lazyderef B V3704) ()))) (shen.lazyderef Hyp V3704))) V3704 V3705))) (do (shen.unbindv V3477 V3704) Result))) false))) (if (shen.pvar? V3476) (do (shen.bindv V3476 () V3704) (let Result (let V3478 (shen.lazyderef (tl V3471) V3704) (if (= () V3478) (let Hyp (tl V3462) (do (shen.incinfs) (bind V3703 (cons (cons (shen.lazyderef X V3704) (cons : (cons (shen.lazyderef A V3704) ()))) (cons (cons (shen.lazyderef Y V3704) (cons : (cons (shen.lazyderef B V3704) ()))) (shen.lazyderef Hyp V3704))) V3704 V3705))) (if (shen.pvar? V3478) (do (shen.bindv V3478 () V3704) (let Result (let Hyp (tl V3462) (do (shen.incinfs) (bind V3703 (cons (cons (shen.lazyderef X V3704) (cons : (cons (shen.lazyderef A V3704) ()))) (cons (cons (shen.lazyderef Y V3704) (cons : (cons (shen.lazyderef B V3704) ()))) (shen.lazyderef Hyp V3704))) V3704 V3705))) (do (shen.unbindv V3478 V3704) Result))) false))) (do (shen.unbindv V3476 V3704) Result))) false)))) (if (shen.pvar? V3475) (let B (shen.newpv V3704) (do (shen.bindv V3475 (cons B ()) V3704) (let Result (let V3479 (shen.lazyderef (tl V3471) V3704) (if (= () V3479) (let Hyp (tl V3462) (do (shen.incinfs) (bind V3703 (cons (cons (shen.lazyderef X V3704) (cons : (cons (shen.lazyderef A V3704) ()))) (cons (cons (shen.lazyderef Y V3704) (cons : (cons (shen.lazyderef B V3704) ()))) (shen.lazyderef Hyp V3704))) V3704 V3705))) (if (shen.pvar? V3479) (do (shen.bindv V3479 () V3704) (let Result (let Hyp (tl V3462) (do (shen.incinfs) (bind V3703 (cons (cons (shen.lazyderef X V3704) (cons : (cons (shen.lazyderef A V3704) ()))) (cons (cons (shen.lazyderef Y V3704) (cons : (cons (shen.lazyderef B V3704) ()))) (shen.lazyderef Hyp V3704))) V3704 V3705))) (do (shen.unbindv V3479 V3704) Result))) false))) (do (shen.unbindv V3475 V3704) Result)))) false))) (if (shen.pvar? V3474) (do (shen.bindv V3474 * V3704) (let Result (let V3480 (shen.lazyderef (tl V3473) V3704) (if (cons? V3480) (let B (hd V3480) (let V3481 (shen.lazyderef (tl V3480) V3704) (if (= () V3481) (let V3482 (shen.lazyderef (tl V3471) V3704) (if (= () V3482) (let Hyp (tl V3462) (do (shen.incinfs) (bind V3703 (cons (cons (shen.lazyderef X V3704) (cons : (cons (shen.lazyderef A V3704) ()))) (cons (cons (shen.lazyderef Y V3704) (cons : (cons (shen.lazyderef B V3704) ()))) (shen.lazyderef Hyp V3704))) V3704 V3705))) (if (shen.pvar? V3482) (do (shen.bindv V3482 () V3704) (let Result (let Hyp (tl V3462) (do (shen.incinfs) (bind V3703 (cons (cons (shen.lazyderef X V3704) (cons : (cons (shen.lazyderef A V3704) ()))) (cons (cons (shen.lazyderef Y V3704) (cons : (cons (shen.lazyderef B V3704) ()))) (shen.lazyderef Hyp V3704))) V3704 V3705))) (do (shen.unbindv V3482 V3704) Result))) false))) (if (shen.pvar? V3481) (do (shen.bindv V3481 () V3704) (let Result (let V3483 (shen.lazyderef (tl V3471) V3704) (if (= () V3483) (let Hyp (tl V3462) (do (shen.incinfs) (bind V3703 (cons (cons (shen.lazyderef X V3704) (cons : (cons (shen.lazyderef A V3704) ()))) (cons (cons (shen.lazyderef Y V3704) (cons : (cons (shen.lazyderef B V3704) ()))) (shen.lazyderef Hyp V3704))) V3704 V3705))) (if (shen.pvar? V3483) (do (shen.bindv V3483 () V3704) (let Result (let Hyp (tl V3462) (do (shen.incinfs) (bind V3703 (cons (cons (shen.lazyderef X V3704) (cons : (cons (shen.lazyderef A V3704) ()))) (cons (cons (shen.lazyderef Y V3704) (cons : (cons (shen.lazyderef B V3704) ()))) (shen.lazyderef Hyp V3704))) V3704 V3705))) (do (shen.unbindv V3483 V3704) Result))) false))) (do (shen.unbindv V3481 V3704) Result))) false)))) (if (shen.pvar? V3480) (let B (shen.newpv V3704) (do (shen.bindv V3480 (cons B ()) V3704) (let Result (let V3484 (shen.lazyderef (tl V3471) V3704) (if (= () V3484) (let Hyp (tl V3462) (do (shen.incinfs) (bind V3703 (cons (cons (shen.lazyderef X V3704) (cons : (cons (shen.lazyderef A V3704) ()))) (cons (cons (shen.lazyderef Y V3704) (cons : (cons (shen.lazyderef B V3704) ()))) (shen.lazyderef Hyp V3704))) V3704 V3705))) (if (shen.pvar? V3484) (do (shen.bindv V3484 () V3704) (let Result (let Hyp (tl V3462) (do (shen.incinfs) (bind V3703 (cons (cons (shen.lazyderef X V3704) (cons : (cons (shen.lazyderef A V3704) ()))) (cons (cons (shen.lazyderef Y V3704) (cons : (cons (shen.lazyderef B V3704) ()))) (shen.lazyderef Hyp V3704))) V3704 V3705))) (do (shen.unbindv V3484 V3704) Result))) false))) (do (shen.unbindv V3480 V3704) Result)))) false))) (do (shen.unbindv V3474 V3704) Result))) false))) (if (shen.pvar? V3473) (let B (shen.newpv V3704) (do (shen.bindv V3473 (cons * (cons B ())) V3704) (let Result (let V3485 (shen.lazyderef (tl V3471) V3704) (if (= () V3485) (let Hyp (tl V3462) (do (shen.incinfs) (bind V3703 (cons (cons (shen.lazyderef X V3704) (cons : (cons (shen.lazyderef A V3704) ()))) (cons (cons (shen.lazyderef Y V3704) (cons : (cons (shen.lazyderef B V3704) ()))) (shen.lazyderef Hyp V3704))) V3704 V3705))) (if (shen.pvar? V3485) (do (shen.bindv V3485 () V3704) (let Result (let Hyp (tl V3462) (do (shen.incinfs) (bind V3703 (cons (cons (shen.lazyderef X V3704) (cons : (cons (shen.lazyderef A V3704) ()))) (cons (cons (shen.lazyderef Y V3704) (cons : (cons (shen.lazyderef B V3704) ()))) (shen.lazyderef Hyp V3704))) V3704 V3705))) (do (shen.unbindv V3485 V3704) Result))) false))) (do (shen.unbindv V3473 V3704) Result)))) false)))) (if (shen.pvar? V3472) (let A (shen.newpv V3704) (let B (shen.newpv V3704) (do (shen.bindv V3472 (cons A (cons * (cons B ()))) V3704) (let Result (let V3486 (shen.lazyderef (tl V3471) V3704) (if (= () V3486) (let Hyp (tl V3462) (do (shen.incinfs) (bind V3703 (cons (cons (shen.lazyderef X V3704) (cons : (cons (shen.lazyderef A V3704) ()))) (cons (cons (shen.lazyderef Y V3704) (cons : (cons (shen.lazyderef B V3704) ()))) (shen.lazyderef Hyp V3704))) V3704 V3705))) (if (shen.pvar? V3486) (do (shen.bindv V3486 () V3704) (let Result (let Hyp (tl V3462) (do (shen.incinfs) (bind V3703 (cons (cons (shen.lazyderef X V3704) (cons : (cons (shen.lazyderef A V3704) ()))) (cons (cons (shen.lazyderef Y V3704) (cons : (cons (shen.lazyderef B V3704) ()))) (shen.lazyderef Hyp V3704))) V3704 V3705))) (do (shen.unbindv V3486 V3704) Result))) false))) (do (shen.unbindv V3472 V3704) Result))))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V3487 (shen.lazyderef V3702 V3704) (if (cons? V3487) (let V3488 (shen.lazyderef (hd V3487) V3704) (if (cons? V3488) (let V3489 (shen.lazyderef (hd V3488) V3704) (if (cons? V3489) (let V3490 (shen.lazyderef (hd V3489) V3704) (if (= @v V3490) (let V3491 (shen.lazyderef (tl V3489) V3704) (if (cons? V3491) (let X (hd V3491) (let V3492 (shen.lazyderef (tl V3491) V3704) (if (cons? V3492) (let Y (hd V3492) (let V3493 (shen.lazyderef (tl V3492) V3704) (if (= () V3493) (let V3494 (shen.lazyderef (tl V3488) V3704) (if (cons? V3494) (let V3495 (shen.lazyderef (hd V3494) V3704) (if (= : V3495) (let V3496 (shen.lazyderef (tl V3494) V3704) (if (cons? V3496) (let V3497 (shen.lazyderef (hd V3496) V3704) (if (cons? V3497) (let V3498 (shen.lazyderef (hd V3497) V3704) (if (= vector V3498) (let V3499 (shen.lazyderef (tl V3497) V3704) (if (cons? V3499) (let A (hd V3499) (let V3500 (shen.lazyderef (tl V3499) V3704) (if (= () V3500) (let V3501 (shen.lazyderef (tl V3496) V3704) (if (= () V3501) (let Hyp (tl V3487) (do (shen.incinfs) (bind V3703 (cons (cons (shen.lazyderef X V3704) (cons : (cons (shen.lazyderef A V3704) ()))) (cons (cons (shen.lazyderef Y V3704) (cons : (cons (cons vector (cons (shen.lazyderef A V3704) ())) ()))) (shen.lazyderef Hyp V3704))) V3704 V3705))) (if (shen.pvar? V3501) (do (shen.bindv V3501 () V3704) (let Result (let Hyp (tl V3487) (do (shen.incinfs) (bind V3703 (cons (cons (shen.lazyderef X V3704) (cons : (cons (shen.lazyderef A V3704) ()))) (cons (cons (shen.lazyderef Y V3704) (cons : (cons (cons vector (cons (shen.lazyderef A V3704) ())) ()))) (shen.lazyderef Hyp V3704))) V3704 V3705))) (do (shen.unbindv V3501 V3704) Result))) false))) (if (shen.pvar? V3500) (do (shen.bindv V3500 () V3704) (let Result (let V3502 (shen.lazyderef (tl V3496) V3704) (if (= () V3502) (let Hyp (tl V3487) (do (shen.incinfs) (bind V3703 (cons (cons (shen.lazyderef X V3704) (cons : (cons (shen.lazyderef A V3704) ()))) (cons (cons (shen.lazyderef Y V3704) (cons : (cons (cons vector (cons (shen.lazyderef A V3704) ())) ()))) (shen.lazyderef Hyp V3704))) V3704 V3705))) (if (shen.pvar? V3502) (do (shen.bindv V3502 () V3704) (let Result (let Hyp (tl V3487) (do (shen.incinfs) (bind V3703 (cons (cons (shen.lazyderef X V3704) (cons : (cons (shen.lazyderef A V3704) ()))) (cons (cons (shen.lazyderef Y V3704) (cons : (cons (cons vector (cons (shen.lazyderef A V3704) ())) ()))) (shen.lazyderef Hyp V3704))) V3704 V3705))) (do (shen.unbindv V3502 V3704) Result))) false))) (do (shen.unbindv V3500 V3704) Result))) false)))) (if (shen.pvar? V3499) (let A (shen.newpv V3704) (do (shen.bindv V3499 (cons A ()) V3704) (let Result (let V3503 (shen.lazyderef (tl V3496) V3704) (if (= () V3503) (let Hyp (tl V3487) (do (shen.incinfs) (bind V3703 (cons (cons (shen.lazyderef X V3704) (cons : (cons (shen.lazyderef A V3704) ()))) (cons (cons (shen.lazyderef Y V3704) (cons : (cons (cons vector (cons (shen.lazyderef A V3704) ())) ()))) (shen.lazyderef Hyp V3704))) V3704 V3705))) (if (shen.pvar? V3503) (do (shen.bindv V3503 () V3704) (let Result (let Hyp (tl V3487) (do (shen.incinfs) (bind V3703 (cons (cons (shen.lazyderef X V3704) (cons : (cons (shen.lazyderef A V3704) ()))) (cons (cons (shen.lazyderef Y V3704) (cons : (cons (cons vector (cons (shen.lazyderef A V3704) ())) ()))) (shen.lazyderef Hyp V3704))) V3704 V3705))) (do (shen.unbindv V3503 V3704) Result))) false))) (do (shen.unbindv V3499 V3704) Result)))) false))) (if (shen.pvar? V3498) (do (shen.bindv V3498 vector V3704) (let Result (let V3504 (shen.lazyderef (tl V3497) V3704) (if (cons? V3504) (let A (hd V3504) (let V3505 (shen.lazyderef (tl V3504) V3704) (if (= () V3505) (let V3506 (shen.lazyderef (tl V3496) V3704) (if (= () V3506) (let Hyp (tl V3487) (do (shen.incinfs) (bind V3703 (cons (cons (shen.lazyderef X V3704) (cons : (cons (shen.lazyderef A V3704) ()))) (cons (cons (shen.lazyderef Y V3704) (cons : (cons (cons vector (cons (shen.lazyderef A V3704) ())) ()))) (shen.lazyderef Hyp V3704))) V3704 V3705))) (if (shen.pvar? V3506) (do (shen.bindv V3506 () V3704) (let Result (let Hyp (tl V3487) (do (shen.incinfs) (bind V3703 (cons (cons (shen.lazyderef X V3704) (cons : (cons (shen.lazyderef A V3704) ()))) (cons (cons (shen.lazyderef Y V3704) (cons : (cons (cons vector (cons (shen.lazyderef A V3704) ())) ()))) (shen.lazyderef Hyp V3704))) V3704 V3705))) (do (shen.unbindv V3506 V3704) Result))) false))) (if (shen.pvar? V3505) (do (shen.bindv V3505 () V3704) (let Result (let V3507 (shen.lazyderef (tl V3496) V3704) (if (= () V3507) (let Hyp (tl V3487) (do (shen.incinfs) (bind V3703 (cons (cons (shen.lazyderef X V3704) (cons : (cons (shen.lazyderef A V3704) ()))) (cons (cons (shen.lazyderef Y V3704) (cons : (cons (cons vector (cons (shen.lazyderef A V3704) ())) ()))) (shen.lazyderef Hyp V3704))) V3704 V3705))) (if (shen.pvar? V3507) (do (shen.bindv V3507 () V3704) (let Result (let Hyp (tl V3487) (do (shen.incinfs) (bind V3703 (cons (cons (shen.lazyderef X V3704) (cons : (cons (shen.lazyderef A V3704) ()))) (cons (cons (shen.lazyderef Y V3704) (cons : (cons (cons vector (cons (shen.lazyderef A V3704) ())) ()))) (shen.lazyderef Hyp V3704))) V3704 V3705))) (do (shen.unbindv V3507 V3704) Result))) false))) (do (shen.unbindv V3505 V3704) Result))) false)))) (if (shen.pvar? V3504) (let A (shen.newpv V3704) (do (shen.bindv V3504 (cons A ()) V3704) (let Result (let V3508 (shen.lazyderef (tl V3496) V3704) (if (= () V3508) (let Hyp (tl V3487) (do (shen.incinfs) (bind V3703 (cons (cons (shen.lazyderef X V3704) (cons : (cons (shen.lazyderef A V3704) ()))) (cons (cons (shen.lazyderef Y V3704) (cons : (cons (cons vector (cons (shen.lazyderef A V3704) ())) ()))) (shen.lazyderef Hyp V3704))) V3704 V3705))) (if (shen.pvar? V3508) (do (shen.bindv V3508 () V3704) (let Result (let Hyp (tl V3487) (do (shen.incinfs) (bind V3703 (cons (cons (shen.lazyderef X V3704) (cons : (cons (shen.lazyderef A V3704) ()))) (cons (cons (shen.lazyderef Y V3704) (cons : (cons (cons vector (cons (shen.lazyderef A V3704) ())) ()))) (shen.lazyderef Hyp V3704))) V3704 V3705))) (do (shen.unbindv V3508 V3704) Result))) false))) (do (shen.unbindv V3504 V3704) Result)))) false))) (do (shen.unbindv V3498 V3704) Result))) false))) (if (shen.pvar? V3497) (let A (shen.newpv V3704) (do (shen.bindv V3497 (cons vector (cons A ())) V3704) (let Result (let V3509 (shen.lazyderef (tl V3496) V3704) (if (= () V3509) (let Hyp (tl V3487) (do (shen.incinfs) (bind V3703 (cons (cons (shen.lazyderef X V3704) (cons : (cons (shen.lazyderef A V3704) ()))) (cons (cons (shen.lazyderef Y V3704) (cons : (cons (cons vector (cons (shen.lazyderef A V3704) ())) ()))) (shen.lazyderef Hyp V3704))) V3704 V3705))) (if (shen.pvar? V3509) (do (shen.bindv V3509 () V3704) (let Result (let Hyp (tl V3487) (do (shen.incinfs) (bind V3703 (cons (cons (shen.lazyderef X V3704) (cons : (cons (shen.lazyderef A V3704) ()))) (cons (cons (shen.lazyderef Y V3704) (cons : (cons (cons vector (cons (shen.lazyderef A V3704) ())) ()))) (shen.lazyderef Hyp V3704))) V3704 V3705))) (do (shen.unbindv V3509 V3704) Result))) false))) (do (shen.unbindv V3497 V3704) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V3510 (shen.lazyderef V3702 V3704) (if (cons? V3510) (let V3511 (shen.lazyderef (hd V3510) V3704) (if (cons? V3511) (let V3512 (shen.lazyderef (hd V3511) V3704) (if (cons? V3512) (let V3513 (shen.lazyderef (hd V3512) V3704) (if (= @s V3513) (let V3514 (shen.lazyderef (tl V3512) V3704) (if (cons? V3514) (let X (hd V3514) (let V3515 (shen.lazyderef (tl V3514) V3704) (if (cons? V3515) (let Y (hd V3515) (let V3516 (shen.lazyderef (tl V3515) V3704) (if (= () V3516) (let V3517 (shen.lazyderef (tl V3511) V3704) (if (cons? V3517) (let V3518 (shen.lazyderef (hd V3517) V3704) (if (= : V3518) (let V3519 (shen.lazyderef (tl V3517) V3704) (if (cons? V3519) (let V3520 (shen.lazyderef (hd V3519) V3704) (if (= string V3520) (let V3521 (shen.lazyderef (tl V3519) V3704) (if (= () V3521) (let Hyp (tl V3510) (do (shen.incinfs) (bind V3703 (cons (cons (shen.lazyderef X V3704) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V3704) (cons : (cons string ()))) (shen.lazyderef Hyp V3704))) V3704 V3705))) (if (shen.pvar? V3521) (do (shen.bindv V3521 () V3704) (let Result (let Hyp (tl V3510) (do (shen.incinfs) (bind V3703 (cons (cons (shen.lazyderef X V3704) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V3704) (cons : (cons string ()))) (shen.lazyderef Hyp V3704))) V3704 V3705))) (do (shen.unbindv V3521 V3704) Result))) false))) (if (shen.pvar? V3520) (do (shen.bindv V3520 string V3704) (let Result (let V3522 (shen.lazyderef (tl V3519) V3704) (if (= () V3522) (let Hyp (tl V3510) (do (shen.incinfs) (bind V3703 (cons (cons (shen.lazyderef X V3704) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V3704) (cons : (cons string ()))) (shen.lazyderef Hyp V3704))) V3704 V3705))) (if (shen.pvar? V3522) (do (shen.bindv V3522 () V3704) (let Result (let Hyp (tl V3510) (do (shen.incinfs) (bind V3703 (cons (cons (shen.lazyderef X V3704) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V3704) (cons : (cons string ()))) (shen.lazyderef Hyp V3704))) V3704 V3705))) (do (shen.unbindv V3522 V3704) Result))) false))) (do (shen.unbindv V3520 V3704) Result))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let V3523 (shen.lazyderef V3702 V3704) (if (cons? V3523) (let X (hd V3523) (let Hyp (tl V3523) (let NewHyps (shen.newpv V3704) (do (shen.incinfs) (bind V3703 (cons (shen.lazyderef X V3704) (shen.lazyderef NewHyps V3704)) V3704 (freeze (shen.t*-hyps Hyp NewHyps V3704 V3705))))))) false)) Case)) Case)) Case)) Case)))

(defun shen.show (V3722 V3723 V3724 V3725) (cond ((value shen.*spy*) (do (shen.line) (do (shen.show-p (shen.deref V3722 V3724)) (do (nl 1) (do (nl 1) (do (shen.show-assumptions (shen.deref V3723 V3724) 1) (do (shen.prhush "
> " (stoutput)) (do (shen.pause-for-user) (thaw V3725))))))))) (true (thaw V3725))))

(defun shen.line () (let Infs (inferences) (shen.prhush (cn "____________________________________________________________ " (shen.app Infs (cn " inference" (shen.app (if (= 1 Infs) "" "s") " 
?- " shen.a)) shen.a)) (stoutput))))

(defun shen.show-p (V3727) (cond ((and (cons? V3727) (and (cons? (tl V3727)) (and (= : (hd (tl V3727))) (and (cons? (tl (tl V3727))) (= () (tl (tl (tl V3727)))))))) (shen.prhush (shen.app (hd V3727) (cn " : " (shen.app (hd (tl (tl V3727))) "" shen.r)) shen.r) (stoutput))) (true (shen.prhush (shen.app V3727 "" shen.r) (stoutput)))))

(defun shen.show-assumptions (V3732 V3733) (cond ((= () V3732) shen.skip) ((cons? V3732) (do (shen.prhush (shen.app V3733 ". " shen.a) (stoutput)) (do (shen.show-p (hd V3732)) (do (nl 1) (shen.show-assumptions (tl V3732) (+ V3733 1)))))) (true (shen.f_error shen.show-assumptions))))

(defun shen.pause-for-user () (let Byte (read-byte (stinput)) (if (= Byte 94) (simple-error "input aborted
") (nl 1))))

(defun shen.typedf? (V3735) (cons? (assoc V3735 (value shen.*signedfuncs*))))

(defun shen.sigf (V3737) (concat shen.type-signature-of- V3737))

(defun shen.placeholder () (gensym &&))

(defun shen.base (V3742 V3743 V3744 V3745) (let Case (let V3426 (shen.lazyderef V3743 V3744) (if (= number V3426) (do (shen.incinfs) (fwhen (number? (shen.lazyderef V3742 V3744)) V3744 V3745)) (if (shen.pvar? V3426) (do (shen.bindv V3426 number V3744) (let Result (do (shen.incinfs) (fwhen (number? (shen.lazyderef V3742 V3744)) V3744 V3745)) (do (shen.unbindv V3426 V3744) Result))) false))) (if (= Case false) (let Case (let V3427 (shen.lazyderef V3743 V3744) (if (= boolean V3427) (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V3742 V3744)) V3744 V3745)) (if (shen.pvar? V3427) (do (shen.bindv V3427 boolean V3744) (let Result (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V3742 V3744)) V3744 V3745)) (do (shen.unbindv V3427 V3744) Result))) false))) (if (= Case false) (let Case (let V3428 (shen.lazyderef V3743 V3744) (if (= string V3428) (do (shen.incinfs) (fwhen (string? (shen.lazyderef V3742 V3744)) V3744 V3745)) (if (shen.pvar? V3428) (do (shen.bindv V3428 string V3744) (let Result (do (shen.incinfs) (fwhen (string? (shen.lazyderef V3742 V3744)) V3744 V3745)) (do (shen.unbindv V3428 V3744) Result))) false))) (if (= Case false) (let Case (let V3429 (shen.lazyderef V3743 V3744) (if (= symbol V3429) (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V3742 V3744)) V3744 (freeze (fwhen (not (shen.ue? (shen.lazyderef V3742 V3744))) V3744 V3745)))) (if (shen.pvar? V3429) (do (shen.bindv V3429 symbol V3744) (let Result (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V3742 V3744)) V3744 (freeze (fwhen (not (shen.ue? (shen.lazyderef V3742 V3744))) V3744 V3745)))) (do (shen.unbindv V3429 V3744) Result))) false))) (if (= Case false) (let V3430 (shen.lazyderef V3742 V3744) (if (= () V3430) (let V3431 (shen.lazyderef V3743 V3744) (if (cons? V3431) (let V3432 (shen.lazyderef (hd V3431) V3744) (if (= list V3432) (let V3433 (shen.lazyderef (tl V3431) V3744) (if (cons? V3433) (let A (hd V3433) (let V3434 (shen.lazyderef (tl V3433) V3744) (if (= () V3434) (do (shen.incinfs) (thaw V3745)) (if (shen.pvar? V3434) (do (shen.bindv V3434 () V3744) (let Result (do (shen.incinfs) (thaw V3745)) (do (shen.unbindv V3434 V3744) Result))) false)))) (if (shen.pvar? V3433) (let A (shen.newpv V3744) (do (shen.bindv V3433 (cons A ()) V3744) (let Result (do (shen.incinfs) (thaw V3745)) (do (shen.unbindv V3433 V3744) Result)))) false))) (if (shen.pvar? V3432) (do (shen.bindv V3432 list V3744) (let Result (let V3435 (shen.lazyderef (tl V3431) V3744) (if (cons? V3435) (let A (hd V3435) (let V3436 (shen.lazyderef (tl V3435) V3744) (if (= () V3436) (do (shen.incinfs) (thaw V3745)) (if (shen.pvar? V3436) (do (shen.bindv V3436 () V3744) (let Result (do (shen.incinfs) (thaw V3745)) (do (shen.unbindv V3436 V3744) Result))) false)))) (if (shen.pvar? V3435) (let A (shen.newpv V3744) (do (shen.bindv V3435 (cons A ()) V3744) (let Result (do (shen.incinfs) (thaw V3745)) (do (shen.unbindv V3435 V3744) Result)))) false))) (do (shen.unbindv V3432 V3744) Result))) false))) (if (shen.pvar? V3431) (let A (shen.newpv V3744) (do (shen.bindv V3431 (cons list (cons A ())) V3744) (let Result (do (shen.incinfs) (thaw V3745)) (do (shen.unbindv V3431 V3744) Result)))) false))) false)) Case)) Case)) Case)) Case)))

(defun shen.by_hypothesis (V3751 V3752 V3753 V3754 V3755) (let Case (let V3417 (shen.lazyderef V3753 V3754) (if (cons? V3417) (let V3418 (shen.lazyderef (hd V3417) V3754) (if (cons? V3418) (let Y (hd V3418) (let V3419 (shen.lazyderef (tl V3418) V3754) (if (cons? V3419) (let V3420 (shen.lazyderef (hd V3419) V3754) (if (= : V3420) (let V3421 (shen.lazyderef (tl V3419) V3754) (if (cons? V3421) (let B (hd V3421) (let V3422 (shen.lazyderef (tl V3421) V3754) (if (= () V3422) (do (shen.incinfs) (identical V3751 Y V3754 (freeze (unify! V3752 B V3754 V3755)))) false))) false)) false)) false))) false)) false)) (if (= Case false) (let V3423 (shen.lazyderef V3753 V3754) (if (cons? V3423) (let Hyp (tl V3423) (do (shen.incinfs) (shen.by_hypothesis V3751 V3752 Hyp V3754 V3755))) false)) Case)))

(defun shen.t*-def (V3761 V3762 V3763 V3764 V3765) (let V3411 (shen.lazyderef V3761 V3764) (if (cons? V3411) (let V3412 (shen.lazyderef (hd V3411) V3764) (if (= define V3412) (let V3413 (shen.lazyderef (tl V3411) V3764) (if (cons? V3413) (let F (hd V3413) (let X (tl V3413) (let Y (shen.newpv V3764) (let E (shen.newpv V3764) (do (shen.incinfs) (shen.t*-defh (compile (lambda Y (shen.<sig+rules> Y)) X (lambda E (if (cons? E) (simple-error (cn "parse error here: " (shen.app E "
" shen.s))) (simple-error "parse error
")))) F V3762 V3763 V3764 V3765)))))) false)) false)) false)))

(defun shen.t*-defh (V3772 V3773 V3774 V3775 V3776 V3777) (let V3407 (shen.lazyderef V3772 V3776) (if (cons? V3407) (let Sig (hd V3407) (let Rules (tl V3407) (do (shen.incinfs) (shen.t*-defhh Sig (shen.ue-sig Sig) V3773 V3774 V3775 Rules V3776 V3777)))) false)))

(defun shen.t*-defhh (V3786 V3787 V3788 V3789 V3790 V3791 V3792 V3793) (do (shen.incinfs) (shen.t*-rules V3791 V3787 1 V3788 (cons (cons V3788 (cons : (cons V3787 ()))) V3790) V3792 (freeze (shen.memo V3788 V3786 V3789 V3792 V3793)))))

(defun shen.memo (V3799 V3800 V3801 V3802 V3803) (let Jnk (shen.newpv V3802) (do (shen.incinfs) (unify! V3801 V3800 V3802 (freeze (bind Jnk (declare (shen.lazyderef V3799 V3802) (shen.lazyderef V3801 V3802)) V3802 V3803))))))

(defun shen.<sig+rules> (V3805) (let Parse_shen.<signature> (shen.<signature> V3805) (if (not (= (fail) Parse_shen.<signature>)) (let Parse_shen.<non-ll-rules> (shen.<non-ll-rules> Parse_shen.<signature>) (if (not (= (fail) Parse_shen.<non-ll-rules>)) (shen.pair (hd Parse_shen.<non-ll-rules>) (cons (shen.hdtl Parse_shen.<signature>) (shen.hdtl Parse_shen.<non-ll-rules>))) (fail))) (fail))))

(defun shen.<non-ll-rules> (V3807) (let YaccParse (let Parse_shen.<rule> (shen.<rule> V3807) (if (not (= (fail) Parse_shen.<rule>)) (let Parse_shen.<non-ll-rules> (shen.<non-ll-rules> Parse_shen.<rule>) (if (not (= (fail) Parse_shen.<non-ll-rules>)) (shen.pair (hd Parse_shen.<non-ll-rules>) (cons (shen.hdtl Parse_shen.<rule>) (shen.hdtl Parse_shen.<non-ll-rules>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<rule> (shen.<rule> V3807) (if (not (= (fail) Parse_shen.<rule>)) (shen.pair (hd Parse_shen.<rule>) (cons (shen.hdtl Parse_shen.<rule>) ())) (fail))) YaccParse)))

(defun shen.ue (V3809) (cond ((and (cons? V3809) (and (cons? (tl V3809)) (and (= () (tl (tl V3809))) (= (hd V3809) protect)))) V3809) ((cons? V3809) (map (lambda Z (shen.ue Z)) V3809)) ((variable? V3809) (concat && V3809)) (true V3809)))

(defun shen.ue-sig (V3811) (cond ((cons? V3811) (map (lambda Z (shen.ue-sig Z)) V3811)) ((variable? V3811) (concat &&& V3811)) (true V3811)))

(defun shen.ues (V3817) (cond ((shen.ue? V3817) (cons V3817 ())) ((cons? V3817) (union (shen.ues (hd V3817)) (shen.ues (tl V3817)))) (true ())))

(defun shen.ue? (V3819) (and (symbol? V3819) (shen.ue-h? (str V3819))))

(defun shen.ue-h? (V3827) (cond ((and (shen.+string? V3827) (and (= "&" (pos V3827 0)) (and (shen.+string? (tlstr V3827)) (= "&" (pos (tlstr V3827) 0))))) true) (true false)))

(defun shen.t*-rules (V3835 V3836 V3837 V3838 V3839 V3840 V3841) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V3391 (shen.lazyderef V3835 V3840) (if (= () V3391) (do (shen.incinfs) (thaw V3841)) false)) (if (= Case false) (let Case (let V3392 (shen.lazyderef V3835 V3840) (if (cons? V3392) (let Rule (hd V3392) (let Rules (tl V3392) (do (shen.incinfs) (shen.t*-rule (shen.ue Rule) V3836 V3839 V3840 (freeze (cut Throwcontrol V3840 (freeze (shen.t*-rules Rules V3836 (+ V3837 1) V3838 V3839 V3840 V3841)))))))) false)) (if (= Case false) (let Err (shen.newpv V3840) (do (shen.incinfs) (bind Err (simple-error (cn "type error in rule " (shen.app (shen.lazyderef V3837 V3840) (cn " of " (shen.app (shen.lazyderef V3838 V3840) "" shen.a)) shen.a))) V3840 V3841))) Case)) Case)))))

(defun shen.t*-rule (V3847 V3848 V3849 V3850 V3851) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let V3383 (shen.lazyderef V3847 V3850) (if (cons? V3383) (let Patterns (hd V3383) (let V3384 (shen.lazyderef (tl V3383) V3850) (if (cons? V3384) (let Action (hd V3384) (let V3385 (shen.lazyderef (tl V3384) V3850) (if (= () V3385) (let NewHyps (shen.newpv V3850) (do (shen.incinfs) (shen.newhyps (shen.placeholders Patterns) V3849 NewHyps V3850 (freeze (shen.t*-patterns Patterns V3848 NewHyps V3850 (freeze (cut Throwcontrol V3850 (freeze (shen.t*-action (shen.curry (shen.ue Action)) (shen.result-type Patterns V3848) (shen.patthyps Patterns V3848 V3849) V3850 V3851))))))))) false))) false))) false)))))

(defun shen.placeholders (V3857) (cond ((shen.ue? V3857) (cons V3857 ())) ((cons? V3857) (union (shen.placeholders (hd V3857)) (shen.placeholders (tl V3857)))) (true ())))

(defun shen.newhyps (V3863 V3864 V3865 V3866 V3867) (let Case (let V3370 (shen.lazyderef V3863 V3866) (if (= () V3370) (do (shen.incinfs) (unify! V3865 V3864 V3866 V3867)) false)) (if (= Case false) (let V3371 (shen.lazyderef V3863 V3866) (if (cons? V3371) (let V3366 (hd V3371) (let Vs (tl V3371) (let V3372 (shen.lazyderef V3865 V3866) (if (cons? V3372) (let V3373 (shen.lazyderef (hd V3372) V3866) (if (cons? V3373) (let V (hd V3373) (let V3374 (shen.lazyderef (tl V3373) V3866) (if (cons? V3374) (let V3375 (shen.lazyderef (hd V3374) V3866) (if (= : V3375) (let V3376 (shen.lazyderef (tl V3374) V3866) (if (cons? V3376) (let A (hd V3376) (let V3377 (shen.lazyderef (tl V3376) V3866) (if (= () V3377) (let NewHyp (tl V3372) (do (shen.incinfs) (unify! V V3366 V3866 (freeze (shen.newhyps Vs V3864 NewHyp V3866 V3867))))) (if (shen.pvar? V3377) (do (shen.bindv V3377 () V3866) (let Result (let NewHyp (tl V3372) (do (shen.incinfs) (unify! V V3366 V3866 (freeze (shen.newhyps Vs V3864 NewHyp V3866 V3867))))) (do (shen.unbindv V3377 V3866) Result))) false)))) (if (shen.pvar? V3376) (let A (shen.newpv V3866) (do (shen.bindv V3376 (cons A ()) V3866) (let Result (let NewHyp (tl V3372) (do (shen.incinfs) (unify! V V3366 V3866 (freeze (shen.newhyps Vs V3864 NewHyp V3866 V3867))))) (do (shen.unbindv V3376 V3866) Result)))) false))) (if (shen.pvar? V3375) (do (shen.bindv V3375 : V3866) (let Result (let V3378 (shen.lazyderef (tl V3374) V3866) (if (cons? V3378) (let A (hd V3378) (let V3379 (shen.lazyderef (tl V3378) V3866) (if (= () V3379) (let NewHyp (tl V3372) (do (shen.incinfs) (unify! V V3366 V3866 (freeze (shen.newhyps Vs V3864 NewHyp V3866 V3867))))) (if (shen.pvar? V3379) (do (shen.bindv V3379 () V3866) (let Result (let NewHyp (tl V3372) (do (shen.incinfs) (unify! V V3366 V3866 (freeze (shen.newhyps Vs V3864 NewHyp V3866 V3867))))) (do (shen.unbindv V3379 V3866) Result))) false)))) (if (shen.pvar? V3378) (let A (shen.newpv V3866) (do (shen.bindv V3378 (cons A ()) V3866) (let Result (let NewHyp (tl V3372) (do (shen.incinfs) (unify! V V3366 V3866 (freeze (shen.newhyps Vs V3864 NewHyp V3866 V3867))))) (do (shen.unbindv V3378 V3866) Result)))) false))) (do (shen.unbindv V3375 V3866) Result))) false))) (if (shen.pvar? V3374) (let A (shen.newpv V3866) (do (shen.bindv V3374 (cons : (cons A ())) V3866) (let Result (let NewHyp (tl V3372) (do (shen.incinfs) (unify! V V3366 V3866 (freeze (shen.newhyps Vs V3864 NewHyp V3866 V3867))))) (do (shen.unbindv V3374 V3866) Result)))) false)))) (if (shen.pvar? V3373) (let V (shen.newpv V3866) (let A (shen.newpv V3866) (do (shen.bindv V3373 (cons V (cons : (cons A ()))) V3866) (let Result (let NewHyp (tl V3372) (do (shen.incinfs) (unify! V V3366 V3866 (freeze (shen.newhyps Vs V3864 NewHyp V3866 V3867))))) (do (shen.unbindv V3373 V3866) Result))))) false))) (if (shen.pvar? V3372) (let V (shen.newpv V3866) (let A (shen.newpv V3866) (let NewHyp (shen.newpv V3866) (do (shen.bindv V3372 (cons (cons V (cons : (cons A ()))) NewHyp) V3866) (let Result (do (shen.incinfs) (unify! V V3366 V3866 (freeze (shen.newhyps Vs V3864 NewHyp V3866 V3867)))) (do (shen.unbindv V3372 V3866) Result)))))) false))))) false)) Case)))

(defun shen.patthyps (V3873 V3874 V3875) (cond ((= () V3873) V3875) ((and (cons? V3873) (and (cons? V3874) (and (cons? (tl V3874)) (and (= --> (hd (tl V3874))) (and (cons? (tl (tl V3874))) (= () (tl (tl (tl V3874))))))))) (adjoin (cons (hd V3873) (cons : (cons (hd V3874) ()))) (shen.patthyps (tl V3873) (hd (tl (tl V3874))) V3875))) (true (shen.f_error shen.patthyps))))

(defun shen.result-type (V3882 V3883) (cond ((and (= () V3882) (and (cons? V3883) (and (= --> (hd V3883)) (and (cons? (tl V3883)) (= () (tl (tl V3883))))))) (hd (tl V3883))) ((= () V3882) V3883) ((and (cons? V3882) (and (cons? V3883) (and (cons? (tl V3883)) (and (= --> (hd (tl V3883))) (and (cons? (tl (tl V3883))) (= () (tl (tl (tl V3883))))))))) (shen.result-type (tl V3882) (hd (tl (tl V3883))))) (true (shen.f_error shen.result-type))))

(defun shen.t*-patterns (V3889 V3890 V3891 V3892 V3893) (let Case (let V3358 (shen.lazyderef V3889 V3892) (if (= () V3358) (do (shen.incinfs) (thaw V3893)) false)) (if (= Case false) (let V3359 (shen.lazyderef V3889 V3892) (if (cons? V3359) (let Pattern (hd V3359) (let Patterns (tl V3359) (let V3360 (shen.lazyderef V3890 V3892) (if (cons? V3360) (let A (hd V3360) (let V3361 (shen.lazyderef (tl V3360) V3892) (if (cons? V3361) (let V3362 (shen.lazyderef (hd V3361) V3892) (if (= --> V3362) (let V3363 (shen.lazyderef (tl V3361) V3892) (if (cons? V3363) (let B (hd V3363) (let V3364 (shen.lazyderef (tl V3363) V3892) (if (= () V3364) (do (shen.incinfs) (shen.t* (cons Pattern (cons : (cons A ()))) V3891 V3892 (freeze (shen.t*-patterns Patterns B V3891 V3892 V3893)))) false))) false)) false)) false))) false)))) false)) Case)))

(defun shen.t*-action (V3899 V3900 V3901 V3902 V3903) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V3335 (shen.lazyderef V3899 V3902) (if (cons? V3335) (let V3336 (shen.lazyderef (hd V3335) V3902) (if (= where V3336) (let V3337 (shen.lazyderef (tl V3335) V3902) (if (cons? V3337) (let P (hd V3337) (let V3338 (shen.lazyderef (tl V3337) V3902) (if (cons? V3338) (let Action (hd V3338) (let V3339 (shen.lazyderef (tl V3338) V3902) (if (= () V3339) (do (shen.incinfs) (cut Throwcontrol V3902 (freeze (shen.t* (cons P (cons : (cons boolean ()))) V3901 V3902 (freeze (cut Throwcontrol V3902 (freeze (shen.t*-action Action V3900 (cons (cons P (cons : (cons verified ()))) V3901) V3902 V3903)))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3340 (shen.lazyderef V3899 V3902) (if (cons? V3340) (let V3341 (shen.lazyderef (hd V3340) V3902) (if (= shen.choicepoint! V3341) (let V3342 (shen.lazyderef (tl V3340) V3902) (if (cons? V3342) (let V3343 (shen.lazyderef (hd V3342) V3902) (if (cons? V3343) (let V3344 (shen.lazyderef (hd V3343) V3902) (if (cons? V3344) (let V3345 (shen.lazyderef (hd V3344) V3902) (if (= fail-if V3345) (let V3346 (shen.lazyderef (tl V3344) V3902) (if (cons? V3346) (let F (hd V3346) (let V3347 (shen.lazyderef (tl V3346) V3902) (if (= () V3347) (let V3348 (shen.lazyderef (tl V3343) V3902) (if (cons? V3348) (let Action (hd V3348) (let V3349 (shen.lazyderef (tl V3348) V3902) (if (= () V3349) (let V3350 (shen.lazyderef (tl V3342) V3902) (if (= () V3350) (do (shen.incinfs) (cut Throwcontrol V3902 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons F (cons Action ())) ())) (cons Action ()))) V3900 V3901 V3902 V3903)))) false)) false))) false)) false))) false)) false)) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V3351 (shen.lazyderef V3899 V3902) (if (cons? V3351) (let V3352 (shen.lazyderef (hd V3351) V3902) (if (= shen.choicepoint! V3352) (let V3353 (shen.lazyderef (tl V3351) V3902) (if (cons? V3353) (let Action (hd V3353) (let V3354 (shen.lazyderef (tl V3353) V3902) (if (= () V3354) (do (shen.incinfs) (cut Throwcontrol V3902 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons (cons = (cons Action ())) (cons (cons fail ()) ())) ())) (cons Action ()))) V3900 V3901 V3902 V3903)))) false))) false)) false)) false)) (if (= Case false) (do (shen.incinfs) (shen.t* (cons V3899 (cons : (cons V3900 ()))) V3901 V3902 V3903)) Case)) Case)) Case)))))

(defun findall (V3909 V3910 V3911 V3912 V3913) (let B (shen.newpv V3912) (let A (shen.newpv V3912) (do (shen.incinfs) (bind A (gensym shen.a) V3912 (freeze (bind B (set (shen.lazyderef A V3912) ()) V3912 (freeze (shen.findallhelp V3909 V3910 V3911 A V3912 V3913)))))))))

(defun shen.findallhelp (V3920 V3921 V3922 V3923 V3924 V3925) (let Case (do (shen.incinfs) (call V3921 V3924 (freeze (shen.remember V3923 V3920 V3924 (freeze (fwhen false V3924 V3925)))))) (if (= Case false) (do (shen.incinfs) (bind V3922 (value (shen.lazyderef V3923 V3924)) V3924 V3925)) Case)))

(defun shen.remember (V3930 V3931 V3932 V3933) (let B (shen.newpv V3932) (do (shen.incinfs) (bind B (set (shen.deref V3930 V3932) (cons (shen.deref V3931 V3932) (value (shen.deref V3930 V3932)))) V3932 V3933))))



