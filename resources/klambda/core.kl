"Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

(defun shen.shen->kl (V1384 V1385) (compile (lambda X (shen.<define> X)) (cons V1384 V1385) (lambda X (shen.shen-syntax-error V1384 X))))

(defun shen.shen-syntax-error (V1392 V1393) (cond ((cons? V1393) (simple-error (cn "syntax error in " (shen.app V1392 (cn " here:

 " (shen.app (shen.next-50 50 (hd V1393)) "
" shen.a)) shen.a)))) (true (simple-error (cn "syntax error in " (shen.app V1392 "
" shen.a))))))

(defun shen.<define> (V1395) (let YaccParse (let Parse_shen.<name> (shen.<name> V1395) (if (not (= (fail) Parse_shen.<name>)) (let Parse_shen.<signature> (shen.<signature> Parse_shen.<name>) (if (not (= (fail) Parse_shen.<signature>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<signature>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (shen.compile_to_machine_code (shen.hdtl Parse_shen.<name>) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<name> (shen.<name> V1395) (if (not (= (fail) Parse_shen.<name>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<name>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (shen.compile_to_machine_code (shen.hdtl Parse_shen.<name>) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) YaccParse)))

(defun shen.<name> (V1397) (if (cons? (hd V1397)) (let Parse_X (hd (hd V1397)) (shen.pair (hd (shen.pair (tl (hd V1397)) (shen.hdtl V1397))) (if (and (symbol? Parse_X) (not (shen.sysfunc? Parse_X))) Parse_X (simple-error (shen.app Parse_X " is not a legitimate function name.
" shen.a))))) (fail)))

(defun shen.sysfunc? (V1399) (element? V1399 (get (intern "shen") shen.external-symbols (value *property-vector*))))

(defun shen.<signature> (V1401) (if (and (cons? (hd V1401)) (= { (hd (hd V1401)))) (let Parse_shen.<signature-help> (shen.<signature-help> (shen.pair (tl (hd V1401)) (shen.hdtl V1401))) (if (not (= (fail) Parse_shen.<signature-help>)) (if (and (cons? (hd Parse_shen.<signature-help>)) (= } (hd (hd Parse_shen.<signature-help>)))) (shen.pair (hd (shen.pair (tl (hd Parse_shen.<signature-help>)) (shen.hdtl Parse_shen.<signature-help>))) (shen.demodulate (shen.curry-type (shen.hdtl Parse_shen.<signature-help>)))) (fail)) (fail))) (fail)))

(defun shen.curry-type (V1403) (cond ((and (cons? V1403) (and (cons? (tl V1403)) (and (= --> (hd (tl V1403))) (and (cons? (tl (tl V1403))) (and (cons? (tl (tl (tl V1403)))) (= --> (hd (tl (tl (tl V1403)))))))))) (shen.curry-type (cons (hd V1403) (cons --> (cons (tl (tl V1403)) ()))))) ((and (cons? V1403) (and (cons? (tl V1403)) (and (= * (hd (tl V1403))) (and (cons? (tl (tl V1403))) (and (cons? (tl (tl (tl V1403)))) (= * (hd (tl (tl (tl V1403)))))))))) (shen.curry-type (cons (hd V1403) (cons * (cons (tl (tl V1403)) ()))))) ((cons? V1403) (map (lambda Z (shen.curry-type Z)) V1403)) (true V1403)))

(defun shen.<signature-help> (V1405) (let YaccParse (if (cons? (hd V1405)) (let Parse_X (hd (hd V1405)) (let Parse_shen.<signature-help> (shen.<signature-help> (shen.pair (tl (hd V1405)) (shen.hdtl V1405))) (if (not (= (fail) Parse_shen.<signature-help>)) (if (not (element? Parse_X (cons { (cons } ())))) (shen.pair (hd Parse_shen.<signature-help>) (cons Parse_X (shen.hdtl Parse_shen.<signature-help>))) (fail)) (fail)))) (fail)) (if (= YaccParse (fail)) (let Parse_<e> (<e> V1405) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<rules> (V1407) (let YaccParse (let Parse_shen.<rule> (shen.<rule> V1407) (if (not (= (fail) Parse_shen.<rule>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<rule>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (cons (shen.linearise (shen.hdtl Parse_shen.<rule>)) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<rule> (shen.<rule> V1407) (if (not (= (fail) Parse_shen.<rule>)) (shen.pair (hd Parse_shen.<rule>) (cons (shen.linearise (shen.hdtl Parse_shen.<rule>)) ())) (fail))) YaccParse)))

(defun shen.<rule> (V1409) (let YaccParse (let Parse_shen.<patterns> (shen.<patterns> V1409) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= -> (hd (hd Parse_shen.<patterns>)))) (let Parse_shen.<action> (shen.<action> (shen.pair (tl (hd Parse_shen.<patterns>)) (shen.hdtl Parse_shen.<patterns>))) (if (not (= (fail) Parse_shen.<action>)) (if (and (cons? (hd Parse_shen.<action>)) (= where (hd (hd Parse_shen.<action>)))) (let Parse_shen.<guard> (shen.<guard> (shen.pair (tl (hd Parse_shen.<action>)) (shen.hdtl Parse_shen.<action>))) (if (not (= (fail) Parse_shen.<guard>)) (shen.pair (hd Parse_shen.<guard>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (cons where (cons (shen.hdtl Parse_shen.<guard>) (cons (shen.hdtl Parse_shen.<action>) ()))) ()))) (fail))) (fail)) (fail))) (fail)) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<patterns> (shen.<patterns> V1409) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= -> (hd (hd Parse_shen.<patterns>)))) (let Parse_shen.<action> (shen.<action> (shen.pair (tl (hd Parse_shen.<patterns>)) (shen.hdtl Parse_shen.<patterns>))) (if (not (= (fail) Parse_shen.<action>)) (shen.pair (hd Parse_shen.<action>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (shen.hdtl Parse_shen.<action>) ()))) (fail))) (fail)) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<patterns> (shen.<patterns> V1409) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= <- (hd (hd Parse_shen.<patterns>)))) (let Parse_shen.<action> (shen.<action> (shen.pair (tl (hd Parse_shen.<patterns>)) (shen.hdtl Parse_shen.<patterns>))) (if (not (= (fail) Parse_shen.<action>)) (if (and (cons? (hd Parse_shen.<action>)) (= where (hd (hd Parse_shen.<action>)))) (let Parse_shen.<guard> (shen.<guard> (shen.pair (tl (hd Parse_shen.<action>)) (shen.hdtl Parse_shen.<action>))) (if (not (= (fail) Parse_shen.<guard>)) (shen.pair (hd Parse_shen.<guard>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (cons where (cons (shen.hdtl Parse_shen.<guard>) (cons (cons shen.choicepoint! (cons (shen.hdtl Parse_shen.<action>) ())) ()))) ()))) (fail))) (fail)) (fail))) (fail)) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<patterns> (shen.<patterns> V1409) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= <- (hd (hd Parse_shen.<patterns>)))) (let Parse_shen.<action> (shen.<action> (shen.pair (tl (hd Parse_shen.<patterns>)) (shen.hdtl Parse_shen.<patterns>))) (if (not (= (fail) Parse_shen.<action>)) (shen.pair (hd Parse_shen.<action>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (cons shen.choicepoint! (cons (shen.hdtl Parse_shen.<action>) ())) ()))) (fail))) (fail)) (fail))) YaccParse)) YaccParse)) YaccParse)))

(defun shen.fail_if (V1412 V1413) (if (V1412 V1413) (fail) V1413))

(defun shen.succeeds? (V1419) (cond ((= V1419 (fail)) false) (true true)))

(defun shen.<patterns> (V1421) (let YaccParse (let Parse_shen.<pattern> (shen.<pattern> V1421) (if (not (= (fail) Parse_shen.<pattern>)) (let Parse_shen.<patterns> (shen.<patterns> Parse_shen.<pattern>) (if (not (= (fail) Parse_shen.<patterns>)) (shen.pair (hd Parse_shen.<patterns>) (cons (shen.hdtl Parse_shen.<pattern>) (shen.hdtl Parse_shen.<patterns>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V1421) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<pattern> (V1428) (let YaccParse (if (and (cons? (hd V1428)) (cons? (hd (hd V1428)))) (if (and (cons? (hd (shen.pair (hd (hd V1428)) (hd (tl V1428))))) (= @p (hd (hd (shen.pair (hd (hd V1428)) (hd (tl V1428))))))) (let Parse_shen.<pattern1> (shen.<pattern1> (shen.pair (tl (hd (shen.pair (hd (hd V1428)) (hd (tl V1428))))) (shen.hdtl (shen.pair (hd (hd V1428)) (hd (tl V1428)))))) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (tl (hd V1428)) (hd (tl V1428)))) (cons @p (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V1428)) (cons? (hd (hd V1428)))) (if (and (cons? (hd (shen.pair (hd (hd V1428)) (hd (tl V1428))))) (= cons (hd (hd (shen.pair (hd (hd V1428)) (hd (tl V1428))))))) (let Parse_shen.<pattern1> (shen.<pattern1> (shen.pair (tl (hd (shen.pair (hd (hd V1428)) (hd (tl V1428))))) (shen.hdtl (shen.pair (hd (hd V1428)) (hd (tl V1428)))))) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (tl (hd V1428)) (hd (tl V1428)))) (cons cons (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V1428)) (cons? (hd (hd V1428)))) (if (and (cons? (hd (shen.pair (hd (hd V1428)) (hd (tl V1428))))) (= @v (hd (hd (shen.pair (hd (hd V1428)) (hd (tl V1428))))))) (let Parse_shen.<pattern1> (shen.<pattern1> (shen.pair (tl (hd (shen.pair (hd (hd V1428)) (hd (tl V1428))))) (shen.hdtl (shen.pair (hd (hd V1428)) (hd (tl V1428)))))) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (tl (hd V1428)) (hd (tl V1428)))) (cons @v (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V1428)) (cons? (hd (hd V1428)))) (if (and (cons? (hd (shen.pair (hd (hd V1428)) (hd (tl V1428))))) (= @s (hd (hd (shen.pair (hd (hd V1428)) (hd (tl V1428))))))) (let Parse_shen.<pattern1> (shen.<pattern1> (shen.pair (tl (hd (shen.pair (hd (hd V1428)) (hd (tl V1428))))) (shen.hdtl (shen.pair (hd (hd V1428)) (hd (tl V1428)))))) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (tl (hd V1428)) (hd (tl V1428)))) (cons @s (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V1428)) (cons? (hd (hd V1428)))) (if (and (cons? (hd (shen.pair (hd (hd V1428)) (hd (tl V1428))))) (= vector (hd (hd (shen.pair (hd (hd V1428)) (hd (tl V1428))))))) (if (and (cons? (hd (shen.pair (tl (hd (shen.pair (hd (hd V1428)) (hd (tl V1428))))) (shen.hdtl (shen.pair (hd (hd V1428)) (hd (tl V1428))))))) (= 0 (hd (hd (shen.pair (tl (hd (shen.pair (hd (hd V1428)) (hd (tl V1428))))) (shen.hdtl (shen.pair (hd (hd V1428)) (hd (tl V1428))))))))) (shen.pair (hd (shen.pair (tl (hd V1428)) (hd (tl V1428)))) (cons vector (cons 0 ()))) (fail)) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (cons? (hd V1428)) (let Parse_X (hd (hd V1428)) (if (cons? Parse_X) (shen.pair (hd (shen.pair (tl (hd V1428)) (shen.hdtl V1428))) (shen.constructor-error Parse_X)) (fail))) (fail)) (if (= YaccParse (fail)) (let Parse_shen.<simple_pattern> (shen.<simple_pattern> V1428) (if (not (= (fail) Parse_shen.<simple_pattern>)) (shen.pair (hd Parse_shen.<simple_pattern>) (shen.hdtl Parse_shen.<simple_pattern>)) (fail))) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)))

(defun shen.constructor-error (V1430) (simple-error (shen.app V1430 " is not a legitimate constructor
" shen.a)))

(defun shen.<simple_pattern> (V1432) (let YaccParse (if (cons? (hd V1432)) (let Parse_X (hd (hd V1432)) (if (= Parse_X _) (shen.pair (hd (shen.pair (tl (hd V1432)) (shen.hdtl V1432))) (gensym Parse_Y)) (fail))) (fail)) (if (= YaccParse (fail)) (if (cons? (hd V1432)) (let Parse_X (hd (hd V1432)) (if (not (element? Parse_X (cons -> (cons <- ())))) (shen.pair (hd (shen.pair (tl (hd V1432)) (shen.hdtl V1432))) Parse_X) (fail))) (fail)) YaccParse)))

(defun shen.<pattern1> (V1434) (let Parse_shen.<pattern> (shen.<pattern> V1434) (if (not (= (fail) Parse_shen.<pattern>)) (shen.pair (hd Parse_shen.<pattern>) (shen.hdtl Parse_shen.<pattern>)) (fail))))

(defun shen.<pattern2> (V1436) (let Parse_shen.<pattern> (shen.<pattern> V1436) (if (not (= (fail) Parse_shen.<pattern>)) (shen.pair (hd Parse_shen.<pattern>) (shen.hdtl Parse_shen.<pattern>)) (fail))))

(defun shen.<action> (V1438) (if (cons? (hd V1438)) (let Parse_X (hd (hd V1438)) (shen.pair (hd (shen.pair (tl (hd V1438)) (shen.hdtl V1438))) Parse_X)) (fail)))

(defun shen.<guard> (V1440) (if (cons? (hd V1440)) (let Parse_X (hd (hd V1440)) (shen.pair (hd (shen.pair (tl (hd V1440)) (shen.hdtl V1440))) Parse_X)) (fail)))

(defun shen.compile_to_machine_code (V1443 V1444) (let Lambda+ (shen.compile_to_lambda+ V1443 V1444) (let KL (shen.compile_to_kl V1443 Lambda+) (let Record (shen.record-source V1443 KL) KL))))

(defun shen.record-source (V1449 V1450) (cond ((value shen.*installing-kl*) shen.skip) (true (put V1449 shen.source V1450 (value *property-vector*)))))

(defun shen.compile_to_lambda+ (V1453 V1454) (let Arity (shen.aritycheck V1453 V1454) (let UpDateSymbolTable (shen.update-symbol-table V1453 Arity) (let Free (shen.for-each (lambda Rule (shen.free_variable_check V1453 Rule)) V1454) (let Variables (shen.parameters Arity) (let Strip (map (lambda X (shen.strip-protect X)) V1454) (let Abstractions (map (lambda X (shen.abstract_rule X)) Strip) (let Applications (map (lambda X (shen.application_build Variables X)) Abstractions) (cons Variables (cons Applications ()))))))))))

(defun shen.update-symbol-table (V1457 V1458) (cond ((= 0 V1458) shen.skip) (true (put V1457 shen.lambda-form (eval-kl (shen.lambda-form V1457 V1458)) (value *property-vector*)))))

(defun shen.free_variable_check (V1461 V1462) (cond ((and (cons? V1462) (and (cons? (tl V1462)) (= () (tl (tl V1462))))) (let Bound (shen.extract_vars (hd V1462)) (let Free (shen.extract_free_vars Bound (hd (tl V1462))) (shen.free_variable_warnings V1461 Free)))) (true (shen.f_error shen.free_variable_check))))

(defun shen.extract_vars (V1464) (cond ((variable? V1464) (cons V1464 ())) ((cons? V1464) (union (shen.extract_vars (hd V1464)) (shen.extract_vars (tl V1464)))) (true ())))

(defun shen.extract_free_vars (V1476 V1477) (cond ((and (cons? V1477) (and (cons? (tl V1477)) (and (= () (tl (tl V1477))) (= (hd V1477) protect)))) ()) ((and (variable? V1477) (not (element? V1477 V1476))) (cons V1477 ())) ((and (cons? V1477) (and (= lambda (hd V1477)) (and (cons? (tl V1477)) (and (cons? (tl (tl V1477))) (= () (tl (tl (tl V1477)))))))) (shen.extract_free_vars (cons (hd (tl V1477)) V1476) (hd (tl (tl V1477))))) ((and (cons? V1477) (and (= let (hd V1477)) (and (cons? (tl V1477)) (and (cons? (tl (tl V1477))) (and (cons? (tl (tl (tl V1477)))) (= () (tl (tl (tl (tl V1477)))))))))) (union (shen.extract_free_vars V1476 (hd (tl (tl V1477)))) (shen.extract_free_vars (cons (hd (tl V1477)) V1476) (hd (tl (tl (tl V1477))))))) ((cons? V1477) (union (shen.extract_free_vars V1476 (hd V1477)) (shen.extract_free_vars V1476 (tl V1477)))) (true ())))

(defun shen.free_variable_warnings (V1482 V1483) (cond ((= () V1483) _) (true (simple-error (cn "error: the following variables are free in " (shen.app V1482 (cn ": " (shen.app (shen.list_variables V1483) "" shen.a)) shen.a))))))

(defun shen.list_variables (V1485) (cond ((and (cons? V1485) (= () (tl V1485))) (cn (str (hd V1485)) ".")) ((cons? V1485) (cn (str (hd V1485)) (cn ", " (shen.list_variables (tl V1485))))) (true (shen.f_error shen.list_variables))))

(defun shen.strip-protect (V1487) (cond ((and (cons? V1487) (and (cons? (tl V1487)) (and (= () (tl (tl V1487))) (= (hd V1487) protect)))) (shen.strip-protect (hd (tl V1487)))) ((cons? V1487) (map (lambda Z (shen.strip-protect Z)) V1487)) (true V1487)))

(defun shen.linearise (V1489) (cond ((and (cons? V1489) (and (cons? (tl V1489)) (= () (tl (tl V1489))))) (shen.linearise_help (shen.flatten (hd V1489)) (hd V1489) (hd (tl V1489)))) (true (shen.f_error shen.linearise))))

(defun shen.flatten (V1491) (cond ((= () V1491) ()) ((cons? V1491) (append (shen.flatten (hd V1491)) (shen.flatten (tl V1491)))) (true (cons V1491 ()))))

(defun shen.linearise_help (V1495 V1496 V1497) (cond ((= () V1495) (cons V1496 (cons V1497 ()))) ((cons? V1495) (if (and (variable? (hd V1495)) (element? (hd V1495) (tl V1495))) (let Var (gensym (hd V1495)) (let NewAction (cons where (cons (cons = (cons (hd V1495) (cons Var ()))) (cons V1497 ()))) (let NewPatts (shen.linearise_X (hd V1495) Var V1496) (shen.linearise_help (tl V1495) NewPatts NewAction)))) (shen.linearise_help (tl V1495) V1496 V1497))) (true (shen.f_error shen.linearise_help))))

(defun shen.linearise_X (V1510 V1511 V1512) (cond ((= V1512 V1510) V1511) ((cons? V1512) (let L (shen.linearise_X V1510 V1511 (hd V1512)) (if (= L (hd V1512)) (cons (hd V1512) (shen.linearise_X V1510 V1511 (tl V1512))) (cons L (tl V1512))))) (true V1512)))

(defun shen.aritycheck (V1515 V1516) (cond ((and (cons? V1516) (and (cons? (hd V1516)) (and (cons? (tl (hd V1516))) (and (= () (tl (tl (hd V1516)))) (= () (tl V1516)))))) (do (shen.aritycheck-action (hd (tl (hd V1516)))) (shen.aritycheck-name V1515 (arity V1515) (length (hd (hd V1516)))))) ((and (cons? V1516) (and (cons? (hd V1516)) (and (cons? (tl (hd V1516))) (and (= () (tl (tl (hd V1516)))) (and (cons? (tl V1516)) (and (cons? (hd (tl V1516))) (and (cons? (tl (hd (tl V1516)))) (= () (tl (tl (hd (tl V1516)))))))))))) (if (= (length (hd (hd V1516))) (length (hd (hd (tl V1516))))) (do (shen.aritycheck-action (hd (tl (hd V1516)))) (shen.aritycheck V1515 (tl V1516))) (simple-error (cn "arity error in " (shen.app V1515 "
" shen.a))))) (true (shen.f_error shen.aritycheck))))

(defun shen.aritycheck-name (V1529 V1530 V1531) (cond ((= -1 V1530) V1531) ((= V1531 V1530) V1531) (true (do (shen.prhush (cn "
warning: changing the arity of " (shen.app V1529 " can cause errors.
" shen.a)) (stoutput)) V1531))))

(defun shen.aritycheck-action (V1537) (cond ((cons? V1537) (do (shen.aah (hd V1537) (tl V1537)) (shen.for-each (lambda Y (shen.aritycheck-action Y)) V1537))) (true shen.skip)))

(defun shen.aah (V1540 V1541) (let Arity (arity V1540) (let Len (length V1541) (if (and (> Arity -1) (> Len Arity)) (shen.prhush (cn "warning: " (shen.app V1540 (cn " might not like " (shen.app Len (cn " argument" (shen.app (if (> Len 1) "s" "") ".
" shen.a)) shen.a)) shen.a)) (stoutput)) shen.skip))))

(defun shen.abstract_rule (V1543) (cond ((and (cons? V1543) (and (cons? (tl V1543)) (= () (tl (tl V1543))))) (shen.abstraction_build (hd V1543) (hd (tl V1543)))) (true (shen.f_error shen.abstract_rule))))

(defun shen.abstraction_build (V1546 V1547) (cond ((= () V1546) V1547) ((cons? V1546) (cons /. (cons (hd V1546) (cons (shen.abstraction_build (tl V1546) V1547) ())))) (true (shen.f_error shen.abstraction_build))))

(defun shen.parameters (V1549) (cond ((= 0 V1549) ()) (true (cons (gensym V) (shen.parameters (- V1549 1))))))

(defun shen.application_build (V1552 V1553) (cond ((= () V1552) V1553) ((cons? V1552) (shen.application_build (tl V1552) (cons V1553 (cons (hd V1552) ())))) (true (shen.f_error shen.application_build))))

(defun shen.compile_to_kl (V1556 V1557) (cond ((and (cons? V1557) (and (cons? (tl V1557)) (= () (tl (tl V1557))))) (let Arity (shen.store-arity V1556 (length (hd V1557))) (let Reduce (map (lambda X (shen.reduce X)) (hd (tl V1557))) (let CondExpression (shen.cond-expression V1556 (hd V1557) Reduce) (let TypeTable (if (value shen.*optimise*) (shen.typextable (shen.get-type V1556) (hd V1557)) shen.skip) (let TypedCondExpression (if (value shen.*optimise*) (shen.assign-types (hd V1557) TypeTable CondExpression) CondExpression) (cons defun (cons V1556 (cons (hd V1557) (cons TypedCondExpression ())))))))))) (true (shen.f_error shen.compile_to_kl))))

(defun shen.get-type (V1563) (cond ((cons? V1563) shen.skip) (true (let FType (assoc V1563 (value shen.*signedfuncs*)) (if (empty? FType) shen.skip (tl FType))))))

(defun shen.typextable (V1574 V1575) (cond ((and (cons? V1574) (and (cons? (tl V1574)) (and (= --> (hd (tl V1574))) (and (cons? (tl (tl V1574))) (and (= () (tl (tl (tl V1574)))) (cons? V1575)))))) (if (variable? (hd V1574)) (shen.typextable (hd (tl (tl V1574))) (tl V1575)) (cons (cons (hd V1575) (hd V1574)) (shen.typextable (hd (tl (tl V1574))) (tl V1575))))) (true ())))

(defun shen.assign-types (V1579 V1580 V1581) (cond ((and (cons? V1581) (and (= let (hd V1581)) (and (cons? (tl V1581)) (and (cons? (tl (tl V1581))) (and (cons? (tl (tl (tl V1581)))) (= () (tl (tl (tl (tl V1581)))))))))) (cons let (cons (hd (tl V1581)) (cons (shen.assign-types V1579 V1580 (hd (tl (tl V1581)))) (cons (shen.assign-types (cons (hd (tl V1581)) V1579) V1580 (hd (tl (tl (tl V1581))))) ()))))) ((and (cons? V1581) (and (= lambda (hd V1581)) (and (cons? (tl V1581)) (and (cons? (tl (tl V1581))) (= () (tl (tl (tl V1581)))))))) (cons lambda (cons (hd (tl V1581)) (cons (shen.assign-types (cons (hd (tl V1581)) V1579) V1580 (hd (tl (tl V1581)))) ())))) ((and (cons? V1581) (= cond (hd V1581))) (cons cond (map (lambda Y (cons (shen.assign-types V1579 V1580 (hd Y)) (cons (shen.assign-types V1579 V1580 (hd (tl Y))) ()))) (tl V1581)))) ((cons? V1581) (let NewTable (shen.typextable (shen.get-type (hd V1581)) (tl V1581)) (cons (hd V1581) (map (lambda Y (shen.assign-types V1579 (append V1580 NewTable) Y)) (tl V1581))))) (true (let AtomType (assoc V1581 V1580) (if (cons? AtomType) (cons type (cons V1581 (cons (tl AtomType) ()))) (if (element? V1581 V1579) V1581 (shen.atom-type V1581)))))))

(defun shen.atom-type (V1583) (if (string? V1583) (cons type (cons V1583 (cons string ()))) (if (number? V1583) (cons type (cons V1583 (cons number ()))) (if (boolean? V1583) (cons type (cons V1583 (cons boolean ()))) (if (symbol? V1583) (cons type (cons V1583 (cons symbol ()))) V1583)))))

(defun shen.store-arity (V1588 V1589) (cond ((value shen.*installing-kl*) shen.skip) (true (put V1588 arity V1589 (value *property-vector*)))))

(defun shen.reduce (V1591) (do (set shen.*teststack* ()) (let Result (shen.reduce_help V1591) (cons (cons : (cons shen.tests (reverse (value shen.*teststack*)))) (cons Result ())))))

(defun shen.reduce_help (V1593) (cond ((and (cons? V1593) (and (cons? (hd V1593)) (and (= /. (hd (hd V1593))) (and (cons? (tl (hd V1593))) (and (cons? (hd (tl (hd V1593)))) (and (= cons (hd (hd (tl (hd V1593))))) (and (cons? (tl (hd (tl (hd V1593))))) (and (cons? (tl (tl (hd (tl (hd V1593)))))) (and (= () (tl (tl (tl (hd (tl (hd V1593))))))) (and (cons? (tl (tl (hd V1593)))) (and (= () (tl (tl (tl (hd V1593))))) (and (cons? (tl V1593)) (= () (tl (tl V1593))))))))))))))) (do (shen.add_test (cons cons? (tl V1593))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V1593))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V1593)))))) (cons (shen.ebr (hd (tl V1593)) (hd (tl (hd V1593))) (hd (tl (tl (hd V1593))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons hd (tl V1593)) ())) (cons (cons tl (tl V1593)) ())) (shen.reduce_help Application))))) ((and (cons? V1593) (and (cons? (hd V1593)) (and (= /. (hd (hd V1593))) (and (cons? (tl (hd V1593))) (and (cons? (hd (tl (hd V1593)))) (and (= @p (hd (hd (tl (hd V1593))))) (and (cons? (tl (hd (tl (hd V1593))))) (and (cons? (tl (tl (hd (tl (hd V1593)))))) (and (= () (tl (tl (tl (hd (tl (hd V1593))))))) (and (cons? (tl (tl (hd V1593)))) (and (= () (tl (tl (tl (hd V1593))))) (and (cons? (tl V1593)) (= () (tl (tl V1593))))))))))))))) (do (shen.add_test (cons tuple? (tl V1593))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V1593))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V1593)))))) (cons (shen.ebr (hd (tl V1593)) (hd (tl (hd V1593))) (hd (tl (tl (hd V1593))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons fst (tl V1593)) ())) (cons (cons snd (tl V1593)) ())) (shen.reduce_help Application))))) ((and (cons? V1593) (and (cons? (hd V1593)) (and (= /. (hd (hd V1593))) (and (cons? (tl (hd V1593))) (and (cons? (hd (tl (hd V1593)))) (and (= @v (hd (hd (tl (hd V1593))))) (and (cons? (tl (hd (tl (hd V1593))))) (and (cons? (tl (tl (hd (tl (hd V1593)))))) (and (= () (tl (tl (tl (hd (tl (hd V1593))))))) (and (cons? (tl (tl (hd V1593)))) (and (= () (tl (tl (tl (hd V1593))))) (and (cons? (tl V1593)) (= () (tl (tl V1593))))))))))))))) (do (shen.add_test (cons shen.+vector? (tl V1593))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V1593))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V1593)))))) (cons (shen.ebr (hd (tl V1593)) (hd (tl (hd V1593))) (hd (tl (tl (hd V1593))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons hdv (tl V1593)) ())) (cons (cons tlv (tl V1593)) ())) (shen.reduce_help Application))))) ((and (cons? V1593) (and (cons? (hd V1593)) (and (= /. (hd (hd V1593))) (and (cons? (tl (hd V1593))) (and (cons? (hd (tl (hd V1593)))) (and (= @s (hd (hd (tl (hd V1593))))) (and (cons? (tl (hd (tl (hd V1593))))) (and (cons? (tl (tl (hd (tl (hd V1593)))))) (and (= () (tl (tl (tl (hd (tl (hd V1593))))))) (and (cons? (tl (tl (hd V1593)))) (and (= () (tl (tl (tl (hd V1593))))) (and (cons? (tl V1593)) (= () (tl (tl V1593))))))))))))))) (do (shen.add_test (cons shen.+string? (tl V1593))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V1593))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V1593)))))) (cons (shen.ebr (hd (tl V1593)) (hd (tl (hd V1593))) (hd (tl (tl (hd V1593))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons pos (cons (hd (tl V1593)) (cons 0 ()))) ())) (cons (cons tlstr (tl V1593)) ())) (shen.reduce_help Application))))) ((and (cons? V1593) (and (cons? (hd V1593)) (and (= /. (hd (hd V1593))) (and (cons? (tl (hd V1593))) (and (cons? (tl (tl (hd V1593)))) (and (= () (tl (tl (tl (hd V1593))))) (and (cons? (tl V1593)) (and (= () (tl (tl V1593))) (not (variable? (hd (tl (hd V1593))))))))))))) (do (shen.add_test (cons = (cons (hd (tl (hd V1593))) (tl V1593)))) (shen.reduce_help (hd (tl (tl (hd V1593))))))) ((and (cons? V1593) (and (cons? (hd V1593)) (and (= /. (hd (hd V1593))) (and (cons? (tl (hd V1593))) (and (cons? (tl (tl (hd V1593)))) (and (= () (tl (tl (tl (hd V1593))))) (and (cons? (tl V1593)) (= () (tl (tl V1593)))))))))) (shen.reduce_help (shen.ebr (hd (tl V1593)) (hd (tl (hd V1593))) (hd (tl (tl (hd V1593))))))) ((and (cons? V1593) (and (= where (hd V1593)) (and (cons? (tl V1593)) (and (cons? (tl (tl V1593))) (= () (tl (tl (tl V1593)))))))) (do (shen.add_test (hd (tl V1593))) (shen.reduce_help (hd (tl (tl V1593)))))) ((and (cons? V1593) (and (cons? (tl V1593)) (= () (tl (tl V1593))))) (let Z (shen.reduce_help (hd V1593)) (if (= (hd V1593) Z) V1593 (shen.reduce_help (cons Z (tl V1593)))))) (true V1593)))

(defun shen.+string? (V1595) (cond ((= "" V1595) false) (true (string? V1595))))

(defun shen.+vector? (V1597) (and (absvector? V1597) (> (<-address V1597 0) 0)))

(defun shen.ebr (V1611 V1612 V1613) (cond ((= V1613 V1612) V1611) ((and (cons? V1613) (and (= /. (hd V1613)) (and (cons? (tl V1613)) (and (cons? (tl (tl V1613))) (and (= () (tl (tl (tl V1613)))) (> (occurrences V1612 (hd (tl V1613))) 0)))))) V1613) ((and (cons? V1613) (and (= lambda (hd V1613)) (and (cons? (tl V1613)) (and (cons? (tl (tl V1613))) (and (= () (tl (tl (tl V1613)))) (> (occurrences V1612 (hd (tl V1613))) 0)))))) V1613) ((and (cons? V1613) (and (= let (hd V1613)) (and (cons? (tl V1613)) (and (cons? (tl (tl V1613))) (and (cons? (tl (tl (tl V1613)))) (and (= () (tl (tl (tl (tl V1613))))) (= (hd (tl V1613)) V1612))))))) (cons let (cons (hd (tl V1613)) (cons (shen.ebr V1611 (hd (tl V1613)) (hd (tl (tl V1613)))) (tl (tl (tl V1613))))))) ((cons? V1613) (cons (shen.ebr V1611 V1612 (hd V1613)) (shen.ebr V1611 V1612 (tl V1613)))) (true V1613)))

(defun shen.add_test (V1615) (set shen.*teststack* (cons V1615 (value shen.*teststack*))))

(defun shen.cond-expression (V1619 V1620 V1621) (let Err (shen.err-condition V1619) (let Cases (shen.case-form V1621 Err) (let EncodeChoices (shen.encode-choices Cases V1619) (shen.cond-form EncodeChoices)))))

(defun shen.cond-form (V1625) (cond ((and (cons? V1625) (and (cons? (hd V1625)) (and (= true (hd (hd V1625))) (and (cons? (tl (hd V1625))) (= () (tl (tl (hd V1625)))))))) (hd (tl (hd V1625)))) (true (cons cond V1625))))

(defun shen.encode-choices (V1630 V1631) (cond ((= () V1630) ()) ((and (cons? V1630) (and (cons? (hd V1630)) (and (= true (hd (hd V1630))) (and (cons? (tl (hd V1630))) (and (cons? (hd (tl (hd V1630)))) (and (= shen.choicepoint! (hd (hd (tl (hd V1630))))) (and (cons? (tl (hd (tl (hd V1630))))) (and (= () (tl (tl (hd (tl (hd V1630)))))) (and (= () (tl (tl (hd V1630)))) (= () (tl V1630))))))))))) (cons (cons true (cons (cons let (cons Result (cons (hd (tl (hd (tl (hd V1630))))) (cons (cons if (cons (cons = (cons Result (cons (cons fail ()) ()))) (cons (if (value shen.*installing-kl*) (cons shen.sys-error (cons V1631 ())) (cons shen.f_error (cons V1631 ()))) (cons Result ())))) ())))) ())) ())) ((and (cons? V1630) (and (cons? (hd V1630)) (and (= true (hd (hd V1630))) (and (cons? (tl (hd V1630))) (and (cons? (hd (tl (hd V1630)))) (and (= shen.choicepoint! (hd (hd (tl (hd V1630))))) (and (cons? (tl (hd (tl (hd V1630))))) (and (= () (tl (tl (hd (tl (hd V1630)))))) (= () (tl (tl (hd V1630)))))))))))) (cons (cons true (cons (cons let (cons Result (cons (hd (tl (hd (tl (hd V1630))))) (cons (cons if (cons (cons = (cons Result (cons (cons fail ()) ()))) (cons (shen.cond-form (shen.encode-choices (tl V1630) V1631)) (cons Result ())))) ())))) ())) ())) ((and (cons? V1630) (and (cons? (hd V1630)) (and (cons? (tl (hd V1630))) (and (cons? (hd (tl (hd V1630)))) (and (= shen.choicepoint! (hd (hd (tl (hd V1630))))) (and (cons? (tl (hd (tl (hd V1630))))) (and (= () (tl (tl (hd (tl (hd V1630)))))) (= () (tl (tl (hd V1630))))))))))) (cons (cons true (cons (cons let (cons Freeze (cons (cons freeze (cons (shen.cond-form (shen.encode-choices (tl V1630) V1631)) ())) (cons (cons if (cons (hd (hd V1630)) (cons (cons let (cons Result (cons (hd (tl (hd (tl (hd V1630))))) (cons (cons if (cons (cons = (cons Result (cons (cons fail ()) ()))) (cons (cons thaw (cons Freeze ())) (cons Result ())))) ())))) (cons (cons thaw (cons Freeze ())) ())))) ())))) ())) ())) ((and (cons? V1630) (and (cons? (hd V1630)) (and (cons? (tl (hd V1630))) (= () (tl (tl (hd V1630))))))) (cons (hd V1630) (shen.encode-choices (tl V1630) V1631))) (true (shen.f_error shen.encode-choices))))

(defun shen.case-form (V1638 V1639) (cond ((= () V1638) (cons V1639 ())) ((and (cons? V1638) (and (cons? (hd V1638)) (and (cons? (hd (hd V1638))) (and (= : (hd (hd (hd V1638)))) (and (cons? (tl (hd (hd V1638)))) (and (= shen.tests (hd (tl (hd (hd V1638))))) (and (= () (tl (tl (hd (hd V1638))))) (and (cons? (tl (hd V1638))) (and (cons? (hd (tl (hd V1638)))) (and (= shen.choicepoint! (hd (hd (tl (hd V1638))))) (and (cons? (tl (hd (tl (hd V1638))))) (and (= () (tl (tl (hd (tl (hd V1638)))))) (= () (tl (tl (hd V1638)))))))))))))))) (cons (cons true (tl (hd V1638))) (shen.case-form (tl V1638) V1639))) ((and (cons? V1638) (and (cons? (hd V1638)) (and (cons? (hd (hd V1638))) (and (= : (hd (hd (hd V1638)))) (and (cons? (tl (hd (hd V1638)))) (and (= shen.tests (hd (tl (hd (hd V1638))))) (and (= () (tl (tl (hd (hd V1638))))) (and (cons? (tl (hd V1638))) (= () (tl (tl (hd V1638)))))))))))) (cons (cons true (tl (hd V1638))) ())) ((and (cons? V1638) (and (cons? (hd V1638)) (and (cons? (hd (hd V1638))) (and (= : (hd (hd (hd V1638)))) (and (cons? (tl (hd (hd V1638)))) (and (= shen.tests (hd (tl (hd (hd V1638))))) (and (cons? (tl (hd V1638))) (= () (tl (tl (hd V1638))))))))))) (cons (cons (shen.embed-and (tl (tl (hd (hd V1638))))) (tl (hd V1638))) (shen.case-form (tl V1638) V1639))) (true (shen.f_error shen.case-form))))

(defun shen.embed-and (V1641) (cond ((and (cons? V1641) (= () (tl V1641))) (hd V1641)) ((cons? V1641) (cons and (cons (hd V1641) (cons (shen.embed-and (tl V1641)) ())))) (true (shen.f_error shen.embed-and))))

(defun shen.err-condition (V1643) (cons true (cons (cons shen.f_error (cons V1643 ())) ())))

(defun shen.sys-error (V1645) (simple-error (cn "system function " (shen.app V1645 ": unexpected argument
" shen.a))))



