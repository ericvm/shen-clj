(ns shen.functions
(:gen-class)
(:require [shen-port.primitives :as p])
(:refer-clojure :only []))

(clojure.core/declare shen-dot-shen)
(clojure.core/declare shen-dot-loop)
(clojure.core/declare shen-dot-toplevel-display-exception)
(clojure.core/declare shen-dot-credits)
(clojure.core/declare shen-dot-initialise_environment)
(clojure.core/declare shen-dot-multiple-set)
(clojure.core/declare destroy)
(clojure.core/declare shen-dot-read-evaluate-print)
(clojure.core/declare shen-dot-retrieve-from-history-if-needed)
(clojure.core/declare shen-dot-percent)
(clojure.core/declare shen-dot-exclamation)
(clojure.core/declare shen-dot-prbytes)
(clojure.core/declare shen-dot-update_history)
(clojure.core/declare shen-dot-toplineread)
(clojure.core/declare shen-dot-toplineread_loop)
(clojure.core/declare shen-dot-hat)
(clojure.core/declare shen-dot-newline)
(clojure.core/declare shen-dot-carriage-return)
(clojure.core/declare tc)
(clojure.core/declare shen-dot-prompt)
(clojure.core/declare shen-dot-toplevel)
(clojure.core/declare shen-dot-find-past-inputs)
(clojure.core/declare shen-dot-make-key)
(clojure.core/declare shen-dot-trim-gubbins)
(clojure.core/declare shen-dot-space)
(clojure.core/declare shen-dot-tab)
(clojure.core/declare shen-dot-left-round)
(clojure.core/declare shen-dot-find)
(clojure.core/declare shen-dot-prefix?)
(clojure.core/declare shen-dot-print-past-inputs)
(clojure.core/declare shen-dot-toplevel_evaluate)
(clojure.core/declare shen-dot-typecheck-and-evaluate)
(clojure.core/declare shen-dot-pretty-type)
(clojure.core/declare shen-dot-extract-pvars)
(clojure.core/declare shen-dot-mult_subst)
(clojure.core/declare shen-dot-shen->kl)
(clojure.core/declare shen-dot-shen-syntax-error)
(clojure.core/declare shen-dot-<define>)
(clojure.core/declare shen-dot-<name>)
(clojure.core/declare shen-dot-sysfunc?)
(clojure.core/declare shen-dot-<signature>)
(clojure.core/declare shen-dot-curry-type)
(clojure.core/declare shen-dot-<signature-help>)
(clojure.core/declare shen-dot-<rules>)
(clojure.core/declare shen-dot-<rule>)
(clojure.core/declare shen-dot-fail_if)
(clojure.core/declare shen-dot-succeeds?)
(clojure.core/declare shen-dot-<patterns>)
(clojure.core/declare shen-dot-<pattern>)
(clojure.core/declare shen-dot-constructor-error)
(clojure.core/declare shen-dot-<simple_pattern>)
(clojure.core/declare shen-dot-<pattern1>)
(clojure.core/declare shen-dot-<pattern2>)
(clojure.core/declare shen-dot-<action>)
(clojure.core/declare shen-dot-<guard>)
(clojure.core/declare shen-dot-compile_to_machine_code)
(clojure.core/declare shen-dot-record-source)
(clojure.core/declare shen-dot-compile_to_lambda+)
(clojure.core/declare shen-dot-update-symbol-table)
(clojure.core/declare shen-dot-free_variable_check)
(clojure.core/declare shen-dot-extract_vars)
(clojure.core/declare shen-dot-extract_free_vars)
(clojure.core/declare shen-dot-free_variable_warnings)
(clojure.core/declare shen-dot-list_variables)
(clojure.core/declare shen-dot-strip-protect)
(clojure.core/declare shen-dot-linearise)
(clojure.core/declare shen-dot-flatten)
(clojure.core/declare shen-dot-linearise_help)
(clojure.core/declare shen-dot-linearise_X)
(clojure.core/declare shen-dot-aritycheck)
(clojure.core/declare shen-dot-aritycheck-name)
(clojure.core/declare shen-dot-aritycheck-action)
(clojure.core/declare shen-dot-aah)
(clojure.core/declare shen-dot-abstract_rule)
(clojure.core/declare shen-dot-abstraction_build)
(clojure.core/declare shen-dot-parameters)
(clojure.core/declare shen-dot-application_build)
(clojure.core/declare shen-dot-compile_to_kl)
(clojure.core/declare shen-dot-get-type)
(clojure.core/declare shen-dot-typextable)
(clojure.core/declare shen-dot-assign-types)
(clojure.core/declare shen-dot-atom-type)
(clojure.core/declare shen-dot-store-arity)
(clojure.core/declare shen-dot-reduce)
(clojure.core/declare shen-dot-reduce_help)
(clojure.core/declare shen-dot-+string?)
(clojure.core/declare shen-dot-+vector?)
(clojure.core/declare shen-dot-ebr)
(clojure.core/declare shen-dot-add_test)
(clojure.core/declare shen-dot-cond-expression)
(clojure.core/declare shen-dot-cond-form)
(clojure.core/declare shen-dot-encode-choices)
(clojure.core/declare shen-dot-case-form)
(clojure.core/declare shen-dot-embed-and)
(clojure.core/declare shen-dot-err-condition)
(clojure.core/declare shen-dot-sys-error)
(clojure.core/declare thaw)
(clojure.core/declare eval)
(clojure.core/declare shen-dot-eval-without-macros)
(clojure.core/declare shen-dot-proc-input+)
(clojure.core/declare shen-dot-elim-def)
(clojure.core/declare shen-dot-add-macro)
(clojure.core/declare shen-dot-packaged?)
(clojure.core/declare external)
(clojure.core/declare internal)
(clojure.core/declare shen-dot-package-contents)
(clojure.core/declare shen-dot-walk)
(clojure.core/declare compile)
(clojure.core/declare fail-if)
(clojure.core/declare -at-s)
(clojure.core/declare tc?)
(clojure.core/declare ps)
(clojure.core/declare stinput)
(clojure.core/declare vector)
(clojure.core/declare vector?)
(clojure.core/declare vector->)
(clojure.core/declare <-vector)
(clojure.core/declare shen-dot-posint?)
(clojure.core/declare limit)
(clojure.core/declare symbol?)
(clojure.core/declare shen-dot-analyse-symbol?)
(clojure.core/declare shen-dot-alpha?)
(clojure.core/declare shen-dot-alphanums?)
(clojure.core/declare shen-dot-alphanum?)
(clojure.core/declare shen-dot-digit?)
(clojure.core/declare variable?)
(clojure.core/declare shen-dot-analyse-variable?)
(clojure.core/declare shen-dot-uppercase?)
(clojure.core/declare gensym)
(clojure.core/declare concat)
(clojure.core/declare -at-p)
(clojure.core/declare fst)
(clojure.core/declare snd)
(clojure.core/declare tuple?)
(clojure.core/declare append)
(clojure.core/declare -at-v)
(clojure.core/declare shen-dot--at-v-help)
(clojure.core/declare shen-dot-copyfromvector)
(clojure.core/declare hdv)
(clojure.core/declare tlv)
(clojure.core/declare shen-dot-tlv-help)
(clojure.core/declare assoc)
(clojure.core/declare shen-dot-assoc-set)
(clojure.core/declare shen-dot-assoc-rm)
(clojure.core/declare boolean?)
(clojure.core/declare nl)
(clojure.core/declare difference)
(clojure.core/declare do)
(clojure.core/declare element?)
(clojure.core/declare empty?)
(clojure.core/declare fix)
(clojure.core/declare shen-dot-fix-help)
(clojure.core/declare put)
(clojure.core/declare unput)
(clojure.core/declare get)
(clojure.core/declare hash)
(clojure.core/declare shen-dot-mod)
(clojure.core/declare shen-dot-multiples)
(clojure.core/declare shen-dot-modh)
(clojure.core/declare sum)
(clojure.core/declare head)
(clojure.core/declare tail)
(clojure.core/declare hdstr)
(clojure.core/declare intersection)
(clojure.core/declare reverse)
(clojure.core/declare shen-dot-reverse_help)
(clojure.core/declare union)
(clojure.core/declare y-or-n?)
(clojure.core/declare not)
(clojure.core/declare subst)
(clojure.core/declare explode)
(clojure.core/declare shen-dot-explode-h)
(clojure.core/declare cd)
(clojure.core/declare shen-dot-for-each)
(clojure.core/declare map)
(clojure.core/declare shen-dot-map-h)
(clojure.core/declare length)
(clojure.core/declare shen-dot-length-h)
(clojure.core/declare occurrences)
(clojure.core/declare nth)
(clojure.core/declare integer?)
(clojure.core/declare shen-dot-abs)
(clojure.core/declare shen-dot-magless)
(clojure.core/declare shen-dot-integer-test?)
(clojure.core/declare mapcan)
(clojure.core/declare ==)
(clojure.core/declare abort)
(clojure.core/declare bound?)
(clojure.core/declare shen-dot-string->bytes)
(clojure.core/declare maxinferences)
(clojure.core/declare inferences)
(clojure.core/declare protect)
(clojure.core/declare stoutput)
(clojure.core/declare sterror)
(clojure.core/declare string->symbol)
(clojure.core/declare optimise)
(clojure.core/declare os)
(clojure.core/declare language)
(clojure.core/declare version)
(clojure.core/declare port)
(clojure.core/declare porters)
(clojure.core/declare implementation)
(clojure.core/declare release)
(clojure.core/declare package?)
(clojure.core/declare function)
(clojure.core/declare shen-dot-lookup-func)
(clojure.core/declare shen-dot-dict)
(clojure.core/declare shen-dot-dict?)
(clojure.core/declare shen-dot-dict-capacity)
(clojure.core/declare shen-dot-dict-count)
(clojure.core/declare shen-dot-dict-count->)
(clojure.core/declare shen-dot-<-dict-bucket)
(clojure.core/declare shen-dot-dict-bucket->)
(clojure.core/declare shen-dot-dict-update-count)
(clojure.core/declare shen-dot-dict->)
(clojure.core/declare shen-dot-<-dict)
(clojure.core/declare shen-dot-dict-rm)
(clojure.core/declare shen-dot-dict-fold)
(clojure.core/declare shen-dot-dict-fold-h)
(clojure.core/declare shen-dot-bucket-fold)
(clojure.core/declare shen-dot-dict-keys)
(clojure.core/declare shen-dot-dict-values)
(clojure.core/declare shen-dot-datatype-error)
(clojure.core/declare shen-dot-<datatype-rules>)
(clojure.core/declare shen-dot-<datatype-rule>)
(clojure.core/declare shen-dot-<side-conditions>)
(clojure.core/declare shen-dot-<side-condition>)
(clojure.core/declare shen-dot-<variable?>)
(clojure.core/declare shen-dot-<expr>)
(clojure.core/declare shen-dot-remove-bar)
(clojure.core/declare shen-dot-<premises>)
(clojure.core/declare shen-dot-<semicolon-symbol>)
(clojure.core/declare shen-dot-<premise>)
(clojure.core/declare shen-dot-<conclusion>)
(clojure.core/declare shen-dot-sequent)
(clojure.core/declare shen-dot-<formulae>)
(clojure.core/declare shen-dot-<comma-symbol>)
(clojure.core/declare shen-dot-<formula>)
(clojure.core/declare shen-dot-<type>)
(clojure.core/declare shen-dot-<doubleunderline>)
(clojure.core/declare shen-dot-<singleunderline>)
(clojure.core/declare shen-dot-singleunderline?)
(clojure.core/declare shen-dot-sh?)
(clojure.core/declare shen-dot-doubleunderline?)
(clojure.core/declare shen-dot-dh?)
(clojure.core/declare shen-dot-process-datatype)
(clojure.core/declare shen-dot-remember-datatype)
(clojure.core/declare shen-dot-rules->horn-clauses)
(clojure.core/declare shen-dot-double->singles)
(clojure.core/declare shen-dot-right-rule)
(clojure.core/declare shen-dot-left-rule)
(clojure.core/declare shen-dot-right->left)
(clojure.core/declare shen-dot-rule->horn-clause)
(clojure.core/declare shen-dot-rule->horn-clause-head)
(clojure.core/declare shen-dot-mode-ify)
(clojure.core/declare shen-dot-rule->horn-clause-body)
(clojure.core/declare shen-dot-construct-search-literals)
(clojure.core/declare shen-dot-csl-help)
(clojure.core/declare shen-dot-construct-search-clauses)
(clojure.core/declare shen-dot-construct-search-clause)
(clojure.core/declare shen-dot-construct-base-search-clause)
(clojure.core/declare shen-dot-construct-recursive-search-clause)
(clojure.core/declare shen-dot-construct-side-literals)
(clojure.core/declare shen-dot-construct-premiss-literal)
(clojure.core/declare shen-dot-construct-context)
(clojure.core/declare shen-dot-recursive_cons_form)
(clojure.core/declare preclude)
(clojure.core/declare shen-dot-preclude-h)
(clojure.core/declare include)
(clojure.core/declare shen-dot-include-h)
(clojure.core/declare preclude-all-but)
(clojure.core/declare include-all-but)
(clojure.core/declare shen-dot-synonyms-help)
(clojure.core/declare shen-dot-pushnew)
(clojure.core/declare shen-dot-demod-rule)
(clojure.core/declare shen-dot-lambda-of-defun)
(clojure.core/declare shen-dot-update-demodulation-function)
(clojure.core/declare shen-dot-default-rule)
(clojure.core/declare shen-dot-yacc)
(clojure.core/declare shen-dot-yacc->shen)
(clojure.core/declare shen-dot-kill-code)
(clojure.core/declare kill)
(clojure.core/declare shen-dot-analyse-kill)
(clojure.core/declare shen-dot-split_cc_rules)
(clojure.core/declare shen-dot-split_cc_rule)
(clojure.core/declare shen-dot-semantic-completion-warning)
(clojure.core/declare shen-dot-default_semantics)
(clojure.core/declare shen-dot-grammar_symbol?)
(clojure.core/declare shen-dot-yacc_cases)
(clojure.core/declare shen-dot-cc_body)
(clojure.core/declare shen-dot-syntax)
(clojure.core/declare shen-dot-list-stream)
(clojure.core/declare shen-dot-decons)
(clojure.core/declare shen-dot-insert-runon)
(clojure.core/declare shen-dot-strip-pathname)
(clojure.core/declare shen-dot-recursive_descent)
(clojure.core/declare shen-dot-variable-match)
(clojure.core/declare shen-dot-terminal?)
(clojure.core/declare shen-dot-jump_stream?)
(clojure.core/declare shen-dot-check_stream)
(clojure.core/declare shen-dot-jump_stream)
(clojure.core/declare shen-dot-semantics)
(clojure.core/declare shen-dot-pair)
(clojure.core/declare shen-dot-hdtl)
(clojure.core/declare shen-dot-hdhd)
(clojure.core/declare shen-dot-tlhd)
(clojure.core/declare shen-dot-snd-or-fail)
(clojure.core/declare fail)
(clojure.core/declare <!>)
(clojure.core/declare <e>)
(clojure.core/declare shen-dot-read-char-code)
(clojure.core/declare read-file-as-bytelist)
(clojure.core/declare shen-dot-read-file-as-charlist)
(clojure.core/declare shen-dot-read-file-as-Xlist)
(clojure.core/declare shen-dot-read-file-as-Xlist-help)
(clojure.core/declare read-file-as-string)
(clojure.core/declare shen-dot-rfas-h)
(clojure.core/declare input)
(clojure.core/declare input+)
(clojure.core/declare shen-dot-monotype)
(clojure.core/declare read)
(clojure.core/declare it)
(clojure.core/declare shen-dot-read-loop)
(clojure.core/declare shen-dot-terminator?)
(clojure.core/declare lineread)
(clojure.core/declare shen-dot-lineread-loop)
(clojure.core/declare shen-dot-record-it)
(clojure.core/declare shen-dot-trim-whitespace)
(clojure.core/declare shen-dot-record-it-h)
(clojure.core/declare shen-dot-cn-all)
(clojure.core/declare read-file)
(clojure.core/declare read-from-string)
(clojure.core/declare shen-dot-read-error)
(clojure.core/declare shen-dot-compress-50)
(clojure.core/declare shen-dot-<st_input>)
(clojure.core/declare shen-dot-<lsb>)
(clojure.core/declare shen-dot-<rsb>)
(clojure.core/declare shen-dot-<lcurly>)
(clojure.core/declare shen-dot-<rcurly>)
(clojure.core/declare shen-dot-<bar>)
(clojure.core/declare shen-dot-<semicolon>)
(clojure.core/declare shen-dot-<colon>)
(clojure.core/declare shen-dot-<comma>)
(clojure.core/declare shen-dot-<equal>)
(clojure.core/declare shen-dot-<minus>)
(clojure.core/declare shen-dot-<lrb>)
(clojure.core/declare shen-dot-<rrb>)
(clojure.core/declare shen-dot-<atom>)
(clojure.core/declare shen-dot-control-chars)
(clojure.core/declare shen-dot-code-point)
(clojure.core/declare shen-dot-after-codepoint)
(clojure.core/declare shen-dot-decimalise)
(clojure.core/declare shen-dot-digits->integers)
(clojure.core/declare shen-dot-<sym>)
(clojure.core/declare shen-dot-<alphanums>)
(clojure.core/declare shen-dot-<alphanum>)
(clojure.core/declare shen-dot-<num>)
(clojure.core/declare shen-dot-numbyte?)
(clojure.core/declare shen-dot-<alpha>)
(clojure.core/declare shen-dot-symbol-code?)
(clojure.core/declare shen-dot-<str>)
(clojure.core/declare shen-dot-<dbq>)
(clojure.core/declare shen-dot-<strcontents>)
(clojure.core/declare shen-dot-<byte>)
(clojure.core/declare shen-dot-<strc>)
(clojure.core/declare shen-dot-<number>)
(clojure.core/declare shen-dot-<E>)
(clojure.core/declare shen-dot-<log10>)
(clojure.core/declare shen-dot-<plus>)
(clojure.core/declare shen-dot-<stop>)
(clojure.core/declare shen-dot-<predigits>)
(clojure.core/declare shen-dot-<postdigits>)
(clojure.core/declare shen-dot-<digits>)
(clojure.core/declare shen-dot-<digit>)
(clojure.core/declare shen-dot-byte->digit)
(clojure.core/declare shen-dot-pre)
(clojure.core/declare shen-dot-post)
(clojure.core/declare shen-dot-expt)
(clojure.core/declare shen-dot-<st_input1>)
(clojure.core/declare shen-dot-<st_input2>)
(clojure.core/declare shen-dot-<comment>)
(clojure.core/declare shen-dot-<singleline>)
(clojure.core/declare shen-dot-<backslash>)
(clojure.core/declare shen-dot-<anysingle>)
(clojure.core/declare shen-dot-<non-return>)
(clojure.core/declare shen-dot-<return>)
(clojure.core/declare shen-dot-<multiline>)
(clojure.core/declare shen-dot-<times>)
(clojure.core/declare shen-dot-<anymulti>)
(clojure.core/declare shen-dot-<whitespaces>)
(clojure.core/declare shen-dot-<whitespace>)
(clojure.core/declare shen-dot-cons_form)
(clojure.core/declare shen-dot-package-macro)
(clojure.core/declare shen-dot-record-exceptions)
(clojure.core/declare shen-dot-record-internal)
(clojure.core/declare shen-dot-internal-symbols)
(clojure.core/declare shen-dot-packageh)
(clojure.core/declare shen-dot-<defprolog>)
(clojure.core/declare shen-dot-prolog-error)
(clojure.core/declare shen-dot-next-50)
(clojure.core/declare shen-dot-decons-string)
(clojure.core/declare shen-dot-insert-predicate)
(clojure.core/declare shen-dot-<predicate*>)
(clojure.core/declare shen-dot-<clauses*>)
(clojure.core/declare shen-dot-<clause*>)
(clojure.core/declare shen-dot-<head*>)
(clojure.core/declare shen-dot-<term*>)
(clojure.core/declare shen-dot-legitimate-term?)
(clojure.core/declare shen-dot-eval-cons)
(clojure.core/declare shen-dot-<body*>)
(clojure.core/declare shen-dot-<literal*>)
(clojure.core/declare shen-dot-<end*>)
(clojure.core/declare cut)
(clojure.core/declare shen-dot-insert_modes)
(clojure.core/declare shen-dot-s-prolog)
(clojure.core/declare shen-dot-prolog->shen)
(clojure.core/declare shen-dot-s-prolog_clause)
(clojure.core/declare shen-dot-head_abstraction)
(clojure.core/declare shen-dot-complexity_head)
(clojure.core/declare shen-dot-safe-multiply)
(clojure.core/declare shen-dot-complexity)
(clojure.core/declare shen-dot-safe-product)
(clojure.core/declare shen-dot-s-prolog_literal)
(clojure.core/declare shen-dot-insert_deref)
(clojure.core/declare shen-dot-insert_lazyderef)
(clojure.core/declare shen-dot-group_clauses)
(clojure.core/declare shen-dot-collect)
(clojure.core/declare shen-dot-same_predicate?)
(clojure.core/declare shen-dot-compile_prolog_procedure)
(clojure.core/declare shen-dot-procedure_name)
(clojure.core/declare shen-dot-clauses-to-shen)
(clojure.core/declare shen-dot-catch-cut)
(clojure.core/declare shen-dot-catchpoint)
(clojure.core/declare shen-dot-cutpoint)
(clojure.core/declare shen-dot-nest-disjunct)
(clojure.core/declare shen-dot-lisp-or)
(clojure.core/declare shen-dot-prolog-aritycheck)
(clojure.core/declare shen-dot-linearise-clause)
(clojure.core/declare shen-dot-clause_form)
(clojure.core/declare shen-dot-explicit_modes)
(clojure.core/declare shen-dot-em_help)
(clojure.core/declare shen-dot-cf_help)
(clojure.core/declare occurs-check)
(clojure.core/declare shen-dot-aum)
(clojure.core/declare shen-dot-continuation_call)
(clojure.core/declare remove)
(clojure.core/declare shen-dot-remove-h)
(clojure.core/declare shen-dot-cc_help)
(clojure.core/declare shen-dot-make_mu_application)
(clojure.core/declare shen-dot-mu_reduction)
(clojure.core/declare shen-dot-rcons_form)
(clojure.core/declare shen-dot-remove_modes)
(clojure.core/declare shen-dot-ephemeral_variable?)
(clojure.core/declare shen-dot-prolog_constant?)
(clojure.core/declare shen-dot-aum_to_shen-fist-cond)
(clojure.core/declare shen-dot-aum_to_shen)
(clojure.core/declare shen-dot-chwild)
(clojure.core/declare shen-dot-newpv)
(clojure.core/declare shen-dot-resizeprocessvector)
(clojure.core/declare shen-dot-resize-vector)
(clojure.core/declare shen-dot-copy-vector)
(clojure.core/declare shen-dot-copy-vector-stage-1)
(clojure.core/declare shen-dot-copy-vector-stage-2)
(clojure.core/declare shen-dot-mk-pvar)
(clojure.core/declare shen-dot-pvar?)
(clojure.core/declare shen-dot-bindv)
(clojure.core/declare shen-dot-unbindv)
(clojure.core/declare shen-dot-incinfs)
(clojure.core/declare shen-dot-call_the_continuation)
(clojure.core/declare shen-dot-newcontinuation)
(clojure.core/declare return)
(clojure.core/declare shen-dot-measure&return)
(clojure.core/declare unify)
(clojure.core/declare shen-dot-lzy=)
(clojure.core/declare shen-dot-deref)
(clojure.core/declare shen-dot-lazyderef)
(clojure.core/declare shen-dot-valvector)
(clojure.core/declare unify!)
(clojure.core/declare shen-dot-lzy=!)
(clojure.core/declare shen-dot-occurs?)
(clojure.core/declare identical)
(clojure.core/declare shen-dot-lzy==)
(clojure.core/declare shen-dot-pvar)
(clojure.core/declare bind)
(clojure.core/declare fwhen)
(clojure.core/declare call)
(clojure.core/declare shen-dot-call-help)
(clojure.core/declare shen-dot-intprolog)
(clojure.core/declare shen-dot-intprolog-help)
(clojure.core/declare shen-dot-intprolog-help-help)
(clojure.core/declare shen-dot-call-rest)
(clojure.core/declare shen-dot-start-new-prolog-process)
(clojure.core/declare shen-dot-insert-prolog-variables)
(clojure.core/declare shen-dot-insert-prolog-variables-help)
(clojure.core/declare shen-dot-initialise-prolog)
(clojure.core/declare shen-dot-f_error)
(clojure.core/declare shen-dot-tracked?)
(clojure.core/declare track)
(clojure.core/declare shen-dot-track-function)
(clojure.core/declare shen-dot-insert-tracking-code)
(clojure.core/declare step)
(clojure.core/declare spy)
(clojure.core/declare shen-dot-terpri-or-read-char)
(clojure.core/declare shen-dot-check-byte)
(clojure.core/declare shen-dot-input-track)
(clojure.core/declare shen-dot-recursively-print)
(clojure.core/declare shen-dot-spaces)
(clojure.core/declare shen-dot-output-track)
(clojure.core/declare untrack)
(clojure.core/declare profile)
(clojure.core/declare shen-dot-profile-help)
(clojure.core/declare unprofile)
(clojure.core/declare shen-dot-profile-func)
(clojure.core/declare profile-results)
(clojure.core/declare shen-dot-get-profile)
(clojure.core/declare shen-dot-put-profile)
(clojure.core/declare load)
(clojure.core/declare shen-dot-load-help)
(clojure.core/declare shen-dot-remove-synonyms)
(clojure.core/declare shen-dot-typecheck-and-load)
(clojure.core/declare shen-dot-typetable)
(clojure.core/declare shen-dot-assumetype)
(clojure.core/declare shen-dot-unwind-types)
(clojure.core/declare shen-dot-remtype)
(clojure.core/declare shen-dot-removetype)
(clojure.core/declare shen-dot-<sig+rest>)
(clojure.core/declare write-to-file)
(clojure.core/declare pr)
(clojure.core/declare shen-dot-prh)
(clojure.core/declare shen-dot-write-char-and-inc)
(clojure.core/declare print)
(clojure.core/declare shen-dot-prhush)
(clojure.core/declare shen-dot-mkstr)
(clojure.core/declare shen-dot-mkstr-l)
(clojure.core/declare shen-dot-insert-l)
(clojure.core/declare shen-dot-factor-cn)
(clojure.core/declare shen-dot-proc-nl)
(clojure.core/declare shen-dot-mkstr-r)
(clojure.core/declare shen-dot-insert)
(clojure.core/declare shen-dot-insert-h)
(clojure.core/declare shen-dot-app)
(clojure.core/declare shen-dot-arg->str)
(clojure.core/declare shen-dot-list->str)
(clojure.core/declare shen-dot-maxseq)
(clojure.core/declare shen-dot-iter-list)
(clojure.core/declare shen-dot-str->str)
(clojure.core/declare shen-dot-vector->str)
(clojure.core/declare shen-dot-print-vector?)
(clojure.core/declare shen-dot-fbound?)
(clojure.core/declare shen-dot-tuple)
(clojure.core/declare shen-dot-dictionary)
(clojure.core/declare shen-dot-iter-vector)
(clojure.core/declare shen-dot-atom->str)
(clojure.core/declare shen-dot-funexstring)
(clojure.core/declare shen-dot-list?)
(clojure.core/declare macroexpand)
(clojure.core/declare shen-dot-error-macro)
(clojure.core/declare shen-dot-output-macro)
(clojure.core/declare shen-dot-make-string-macro)
(clojure.core/declare shen-dot-input-macro)
(clojure.core/declare shen-dot-compose)
(clojure.core/declare shen-dot-compile-macro)
(clojure.core/declare shen-dot-prolog-macro)
(clojure.core/declare shen-dot-receive-terms)
(clojure.core/declare shen-dot-pass-literals)
(clojure.core/declare shen-dot-defprolog-macro)
(clojure.core/declare shen-dot-datatype-macro)
(clojure.core/declare shen-dot-intern-type)
(clojure.core/declare shen-dot--at-s-macro)
(clojure.core/declare shen-dot-synonyms-macro)
(clojure.core/declare shen-dot-curry-synonyms)
(clojure.core/declare shen-dot-nl-macro)
(clojure.core/declare shen-dot-assoc-macro)
(clojure.core/declare shen-dot-let-macro)
(clojure.core/declare shen-dot-abs-macro)
(clojure.core/declare shen-dot-cases-macro)
(clojure.core/declare shen-dot-timer-macro)
(clojure.core/declare shen-dot-tuple-up)
(clojure.core/declare shen-dot-put-slash-get-macro)
(clojure.core/declare shen-dot-function-macro)
(clojure.core/declare shen-dot-function-abstraction)
(clojure.core/declare shen-dot-function-abstraction-help)
(clojure.core/declare undefmacro)
(clojure.core/declare shen-dot-findpos)
(clojure.core/declare shen-dot-remove-nth)
(clojure.core/declare shen-dot-initialise_arity_table)
(clojure.core/declare arity)
(clojure.core/declare systemf)
(clojure.core/declare adjoin)
(clojure.core/declare shen-dot-lambda-form-entry)
(clojure.core/declare shen-dot-lambda-form)
(clojure.core/declare shen-dot-add-end)
(clojure.core/declare shen-dot-set-lambda-form-entry)
(clojure.core/declare specialise)
(clojure.core/declare unspecialise)
(clojure.core/declare shen-dot-typecheck)
(clojure.core/declare shen-dot-curry)
(clojure.core/declare shen-dot-special?)
(clojure.core/declare shen-dot-extraspecial?)
(clojure.core/declare shen-dot-t*)
(clojure.core/declare shen-dot-type-theory-enabled?)
(clojure.core/declare enable-type-theory)
(clojure.core/declare shen-dot-prolog-failure)
(clojure.core/declare shen-dot-maxinfexceeded?)
(clojure.core/declare shen-dot-errormaxinfs)
(clojure.core/declare shen-dot-udefs*)
(clojure.core/declare shen-dot-th*-aux-2)
(clojure.core/declare shen-dot-th*-aux)
(clojure.core/declare shen-dot-th*)
(clojure.core/declare shen-dot-t*-hyps-aux)
(clojure.core/declare shen-dot-t*-hyps-aux-2)
(clojure.core/declare shen-dot-t*-hyps)
(clojure.core/declare shen-dot-show)
(clojure.core/declare shen-dot-line)
(clojure.core/declare shen-dot-show-p)
(clojure.core/declare shen-dot-show-assumptions)
(clojure.core/declare shen-dot-pause-for-user)
(clojure.core/declare shen-dot-typedf?)
(clojure.core/declare shen-dot-sigf)
(clojure.core/declare shen-dot-placeholder)
(clojure.core/declare shen-dot-base)
(clojure.core/declare shen-dot-by_hypothesis)
(clojure.core/declare shen-dot-t*-def)
(clojure.core/declare shen-dot-t*-defh)
(clojure.core/declare shen-dot-t*-defhh)
(clojure.core/declare shen-dot-memo)
(clojure.core/declare shen-dot-<sig+rules>)
(clojure.core/declare shen-dot-<non-ll-rules>)
(clojure.core/declare shen-dot-ue)
(clojure.core/declare shen-dot-ue-sig)
(clojure.core/declare shen-dot-ues)
(clojure.core/declare shen-dot-ue?)
(clojure.core/declare shen-dot-ue-h?)
(clojure.core/declare shen-dot-t*-rules)
(clojure.core/declare shen-dot-t*-rule)
(clojure.core/declare shen-dot-placeholders)
(clojure.core/declare shen-dot-newhyps)
(clojure.core/declare shen-dot-patthyps)
(clojure.core/declare shen-dot-result-type)
(clojure.core/declare shen-dot-t*-patterns)
(clojure.core/declare shen-dot-t*-action)
(clojure.core/declare findall)
(clojure.core/declare shen-dot-findallhelp)
(clojure.core/declare shen-dot-remember)
(clojure.core/declare declare)
(clojure.core/declare shen-dot-demodulate)
(clojure.core/declare shen-dot-variancy-test)
(clojure.core/declare shen-dot-variant?)

(shen-port.primitives/with-ns (quote shen.functions) (clojure.core/defn shen-dot-fillvector ([Vec pos c d] (clojure.core/cond (= c pos) (address-> Vec c d) :else (recur (address-> Vec pos d) (+ 1 pos) c d))) ([Vec pos c] (clojure.core/partial shen-dot-fillvector Vec pos c)) ([Vec pos] (clojure.core/partial shen-dot-fillvector Vec pos)) ([Vec] (clojure.core/partial shen-dot-fillvector Vec))))
(clojure.core/comment toplevel.kl)
(clojure.core/comment "Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.")
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-credits shen-dot-loop) (clojure.core/defn shen-dot-shen [] (do (shen-dot-credits) (shen-dot-loop)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-toplevel-display-exception shen-dot-initialise_environment shen-dot-prompt shen-dot-read-evaluate-print shen-dot-loop) (clojure.core/defn shen-dot-loop [] (do (shen-dot-initialise_environment) (do (shen-dot-prompt) (do (try (shen-dot-read-evaluate-print) (catch Exception e7391 ((do (clojure.core/declare shen-dot-toplevel-display-exception) (clojure.core/fn [E] (shen-dot-toplevel-display-exception E))) e7391))) (shen-dot-loop)))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare pr error-to-string stoutput) (clojure.core/defn shen-dot-toplevel-display-exception [V3935] (pr (error-to-string V3935) (stoutput)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-prhush stoutput cn shen-dot-app value) (clojure.core/defn shen-dot-credits [] (do (shen-dot-prhush "\nShen, copyright (C) 2010-2015 Mark Tarver\n" (stoutput)) (do (shen-dot-prhush (cn "www.shenlanguage.org, " (shen-dot-app (value (quote *version*)) "\n" (quote shen-dot-a))) (stoutput)) (do (shen-dot-prhush (cn "running under " (shen-dot-app (value (quote *language*)) (cn ", implementation: " (shen-dot-app (value (quote *implementation*)) "" (quote shen-dot-a))) (quote shen-dot-a))) (stoutput)) (shen-dot-prhush (cn "\nport " (shen-dot-app (value (quote *port*)) (cn " ported by " (shen-dot-app (value (quote *porters*)) "\n" (quote shen-dot-a))) (quote shen-dot-a))) (stoutput))))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-multiple-set cons) (clojure.core/defn shen-dot-initialise_environment [] (shen-dot-multiple-set (cons (quote shen-dot-*call*) (cons 0 (cons (quote shen-dot-*infs*) (cons 0 (cons (quote shen-dot-*process-counter*) (cons 0 (cons (quote shen-dot-*catch*) (cons 0 ()))))))))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare = cons? tl set hd shen-dot-multiple-set shen-dot-f_error) (clojure.core/defn shen-dot-multiple-set [V3937] (clojure.core/cond (= () V3937) () (clojure.core/and (cons? V3937) (cons? (tl V3937))) (do (set (hd V3937) (hd (tl V3937))) (shen-dot-multiple-set (tl (tl V3937)))) true (shen-dot-f_error (quote shen-dot-multiple-set)) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare declare) (clojure.core/defn destroy [V3939] (declare V3939 (quote symbol)))))
(set (quote shen-dot-*history*) ())
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-toplineread value shen-dot-retrieve-from-history-if-needed shen-dot-update_history fst shen-dot-toplevel) (clojure.core/defn shen-dot-read-evaluate-print [] (clojure.core/let [Lineread (shen-dot-toplineread)] (clojure.core/let [History (value (quote shen-dot-*history*))] (clojure.core/let [NewLineread (shen-dot-retrieve-from-history-if-needed Lineread History)] (clojure.core/let [NewHistory (shen-dot-update_history NewLineread History)] (clojure.core/let [Parsed (fst NewLineread)] (shen-dot-toplevel Parsed)))))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-retrieve-from-history-if-needed [V3951 V3952] (clojure.core/cond (clojure.core/and (tuple? V3951) (clojure.core/and (cons? (snd V3951)) (element? (hd (snd V3951)) (cons (shen-dot-space) (cons (shen-dot-newline) ()))))) (shen-dot-retrieve-from-history-if-needed (-at-p (fst V3951) (tl (snd V3951))) V3952) (clojure.core/and (tuple? V3951) (clojure.core/and (cons? (snd V3951)) (clojure.core/and (cons? (tl (snd V3951))) (clojure.core/and (= () (tl (tl (snd V3951)))) (clojure.core/and (cons? V3952) (clojure.core/and (= (hd (snd V3951)) (shen-dot-exclamation)) (= (hd (tl (snd V3951))) (shen-dot-exclamation)))))))) (clojure.core/let [PastPrint (shen-dot-prbytes (snd (hd V3952)))] (hd V3952)) (clojure.core/and (tuple? V3951) (clojure.core/and (cons? (snd V3951)) (= (hd (snd V3951)) (shen-dot-exclamation)))) (clojure.core/let [Key? (shen-dot-make-key (tl (snd V3951)) V3952)] (clojure.core/let [Find (head (shen-dot-find-past-inputs Key? V3952))] (clojure.core/let [PastPrint (shen-dot-prbytes (snd Find))] Find))) (clojure.core/and (tuple? V3951) (clojure.core/and (cons? (snd V3951)) (clojure.core/and (= () (tl (snd V3951))) (= (hd (snd V3951)) (shen-dot-percent))))) (do (shen-dot-print-past-inputs (clojure.core/fn [X] true) (reverse V3952) 0) (abort)) (clojure.core/and (tuple? V3951) (clojure.core/and (cons? (snd V3951)) (= (hd (snd V3951)) (shen-dot-percent)))) (clojure.core/let [Key? (shen-dot-make-key (tl (snd V3951)) V3952)] (clojure.core/let [Pastprint (shen-dot-print-past-inputs Key? (reverse V3952) 0)] (abort))) true V3951 :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (clojure.core/defn shen-dot-percent [] 37))
(shen-port.primitives/with-ns (quote shen.functions) (clojure.core/defn shen-dot-exclamation [] 33))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare pr n->string stoutput shen-dot-for-each nl) (clojure.core/defn shen-dot-prbytes [V3954] (do (shen-dot-for-each (do (clojure.core/declare pr n->string stoutput) (clojure.core/fn [Byte] (pr (n->string Byte) (stoutput)))) V3954) (nl 1)))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-update_history [V3957 V3958] (set (quote shen-dot-*history*) (cons V3957 V3958))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-toplineread_loop shen-dot-read-char-code stinput) (clojure.core/defn shen-dot-toplineread [] (shen-dot-toplineread_loop (shen-dot-read-char-code (stinput)) ()))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-toplineread_loop [V3962 V3963] (clojure.core/cond (= V3962 (shen-dot-hat)) (simple-error "line read aborted") (element? V3962 (cons (shen-dot-newline) (cons (shen-dot-carriage-return) ()))) (clojure.core/let [Line (compile (do (clojure.core/declare shen-dot-<st_input>) (clojure.core/fn [X] (shen-dot-<st_input> X))) V3963 (clojure.core/fn [E] (quote shen-dot-nextline)))] (clojure.core/let [It (shen-dot-record-it V3963)] (if (clojure.core/or (= Line (quote shen-dot-nextline)) (empty? Line)) (shen-dot-toplineread_loop (shen-dot-read-char-code (stinput)) (append V3963 (cons V3962 ()))) (-at-p Line V3963)))) true (shen-dot-toplineread_loop (shen-dot-read-char-code (stinput)) (if (= V3962 -1) V3963 (append V3963 (cons V3962 ())))) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (clojure.core/defn shen-dot-hat [] 94))
(shen-port.primitives/with-ns (quote shen.functions) (clojure.core/defn shen-dot-newline [] 10))
(shen-port.primitives/with-ns (quote shen.functions) (clojure.core/defn shen-dot-carriage-return [] 13))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare = set simple-error) (clojure.core/defn tc [V3969] (clojure.core/cond (= (quote +) V3969) (set (quote shen-dot-*tc*) true) (= (quote -) V3969) (set (quote shen-dot-*tc*) false) true (simple-error "tc expects a + or -") :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare value shen-dot-prhush cn shen-dot-app length stoutput) (clojure.core/defn shen-dot-prompt [] (if (value (quote shen-dot-*tc*)) (shen-dot-prhush (cn "\n\n(" (shen-dot-app (length (value (quote shen-dot-*history*))) "+) " (quote shen-dot-a))) (stoutput)) (shen-dot-prhush (cn "\n\n(" (shen-dot-app (length (value (quote shen-dot-*history*))) "-) " (quote shen-dot-a))) (stoutput))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-toplevel_evaluate value) (clojure.core/defn shen-dot-toplevel [V3971] (shen-dot-toplevel_evaluate V3971 (value (quote shen-dot-*tc*))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-find-past-inputs [V3974 V3975] (clojure.core/let [F (shen-dot-find V3974 V3975)] (if (empty? F) (simple-error "input not found\n") F))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-make-key [V3978 V3979] (clojure.core/let [Atom (hd (compile (do (clojure.core/declare shen-dot-<st_input>) (clojure.core/fn [X] (shen-dot-<st_input> X))) V3978 (do (clojure.core/declare cons? simple-error cn shen-dot-app) (clojure.core/fn [E] (if (cons? E) (simple-error (cn "parse error here: " (shen-dot-app E "\n" (quote shen-dot-s)))) (simple-error "parse error\n"))))))] (if (integer? Atom) (do (clojure.core/declare = nth + reverse) (clojure.core/fn [X] (= X (nth (+ Atom 1) (reverse V3979))))) (do (clojure.core/declare shen-dot-prefix? shen-dot-trim-gubbins snd) (clojure.core/fn [X] (shen-dot-prefix? V3978 (shen-dot-trim-gubbins (snd X)))))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? = hd shen-dot-space shen-dot-trim-gubbins tl shen-dot-newline shen-dot-carriage-return shen-dot-tab shen-dot-left-round) (clojure.core/defn shen-dot-trim-gubbins [V3981] (clojure.core/cond (clojure.core/and (cons? V3981) (= (hd V3981) (shen-dot-space))) (shen-dot-trim-gubbins (tl V3981)) (clojure.core/and (cons? V3981) (= (hd V3981) (shen-dot-newline))) (shen-dot-trim-gubbins (tl V3981)) (clojure.core/and (cons? V3981) (= (hd V3981) (shen-dot-carriage-return))) (shen-dot-trim-gubbins (tl V3981)) (clojure.core/and (cons? V3981) (= (hd V3981) (shen-dot-tab))) (shen-dot-trim-gubbins (tl V3981)) (clojure.core/and (cons? V3981) (= (hd V3981) (shen-dot-left-round))) (shen-dot-trim-gubbins (tl V3981)) true V3981 :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (clojure.core/defn shen-dot-space [] 32))
(shen-port.primitives/with-ns (quote shen.functions) (clojure.core/defn shen-dot-tab [] 9))
(shen-port.primitives/with-ns (quote shen.functions) (clojure.core/defn shen-dot-left-round [] 40))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-find [V3990 V3991] (clojure.core/cond (= () V3991) () (clojure.core/and (cons? V3991) ((shen.primitives/resolve-fn V3990) (hd V3991))) (cons (hd V3991) (shen-dot-find V3990 (tl V3991))) (cons? V3991) (shen-dot-find V3990 (tl V3991)) true (shen-dot-f_error (quote shen-dot-find)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-prefix? [V4005 V4006] (clojure.core/cond (= () V4005) true (clojure.core/and (cons? V4005) (clojure.core/and (cons? V4006) (= (hd V4006) (hd V4005)))) (shen-dot-prefix? (tl V4005) (tl V4006)) true false :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-print-past-inputs [V4018 V4019 V4020] (clojure.core/cond (= () V4019) (quote _) (clojure.core/and (cons? V4019) (not ((shen.primitives/resolve-fn V4018) (hd V4019)))) (shen-dot-print-past-inputs V4018 (tl V4019) (+ V4020 1)) (clojure.core/and (cons? V4019) (tuple? (hd V4019))) (do (shen-dot-prhush (shen-dot-app V4020 ". " (quote shen-dot-a)) (stoutput)) (do (shen-dot-prbytes (snd (hd V4019))) (shen-dot-print-past-inputs V4018 (tl V4019) (+ V4020 1)))) true (shen-dot-f_error (quote shen-dot-print-past-inputs)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-toplevel_evaluate [V4023 V4024] (clojure.core/cond (clojure.core/and (cons? V4023) (clojure.core/and (cons? (tl V4023)) (clojure.core/and (= (quote -colon-) (hd (tl V4023))) (clojure.core/and (cons? (tl (tl V4023))) (clojure.core/and (= () (tl (tl (tl V4023)))) (= true V4024)))))) (shen-dot-typecheck-and-evaluate (hd V4023) (hd (tl (tl V4023)))) (clojure.core/and (cons? V4023) (cons? (tl V4023))) (do (shen-dot-toplevel_evaluate (cons (hd V4023) ()) V4024) (do (nl 1) (shen-dot-toplevel_evaluate (tl V4023) V4024))) (clojure.core/and (cons? V4023) (clojure.core/and (= () (tl V4023)) (= true V4024))) (shen-dot-typecheck-and-evaluate (hd V4023) (gensym (quote A))) (clojure.core/and (cons? V4023) (clojure.core/and (= () (tl V4023)) (= false V4024))) (clojure.core/let [Eval (shen-dot-eval-without-macros (hd V4023))] (print Eval)) true (shen-dot-f_error (quote shen-dot-toplevel_evaluate)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-typecheck-and-evaluate [V4027 V4028] (clojure.core/let [Typecheck (shen-dot-typecheck V4027 V4028)] (if (= Typecheck false) (simple-error "type error\n") (clojure.core/let [Eval (shen-dot-eval-without-macros V4027)] (clojure.core/let [Type (shen-dot-pretty-type Typecheck)] (shen-dot-prhush (shen-dot-app Eval (cn " : " (shen-dot-app Type "" (quote shen-dot-r))) (quote shen-dot-s)) (stoutput))))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-mult_subst value shen-dot-extract-pvars) (clojure.core/defn shen-dot-pretty-type [V4030] (shen-dot-mult_subst (value (quote shen-dot-*alphabet*)) (shen-dot-extract-pvars V4030) V4030))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-pvar? cons cons? union shen-dot-extract-pvars hd tl) (clojure.core/defn shen-dot-extract-pvars [V4036] (clojure.core/cond (shen-dot-pvar? V4036) (cons V4036 ()) (cons? V4036) (union (shen-dot-extract-pvars (hd V4036)) (shen-dot-extract-pvars (tl V4036))) true () :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-mult_subst [V4044 V4045 V4046] (clojure.core/cond (= () V4044) V4046 (= () V4045) V4046 (clojure.core/and (cons? V4044) (cons? V4045)) (shen-dot-mult_subst (tl V4044) (tl V4045) (subst (hd V4044) (hd V4045) V4046)) true (shen-dot-f_error (quote shen-dot-mult_subst)) :else (throw (Exception. "No matching cond clause")))))
(clojure.core/comment core.kl)
(clojure.core/comment "Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.")
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-shen->kl [V1384 V1385] (compile (do (clojure.core/declare shen-dot-<define>) (clojure.core/fn [X] (shen-dot-<define> X))) (cons V1384 V1385) (do (clojure.core/declare shen-dot-shen-syntax-error) (clojure.core/fn [X] (shen-dot-shen-syntax-error V1384 X))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-shen-syntax-error [V1392 V1393] (clojure.core/cond (cons? V1393) (simple-error (cn "syntax error in " (shen-dot-app V1392 (cn " here:\n\n " (shen-dot-app (shen-dot-next-50 50 (hd V1393)) "\n" (quote shen-dot-a))) (quote shen-dot-a)))) true (simple-error (cn "syntax error in " (shen-dot-app V1392 "\n" (quote shen-dot-a)))) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-<name> not = fail shen-dot-<signature> shen-dot-<rules> shen-dot-pair hd shen-dot-compile_to_machine_code shen-dot-hdtl) (clojure.core/defn shen-dot-<define> [V1395] (clojure.core/let [YaccParse (clojure.core/let [Parse_shen-dot-<name> (shen-dot-<name> V1395)] (if (not (= (fail) Parse_shen-dot-<name>)) (clojure.core/let [Parse_shen-dot-<signature> (shen-dot-<signature> Parse_shen-dot-<name>)] (if (not (= (fail) Parse_shen-dot-<signature>)) (clojure.core/let [Parse_shen-dot-<rules> (shen-dot-<rules> Parse_shen-dot-<signature>)] (if (not (= (fail) Parse_shen-dot-<rules>)) (shen-dot-pair (hd Parse_shen-dot-<rules>) (shen-dot-compile_to_machine_code (shen-dot-hdtl Parse_shen-dot-<name>) (shen-dot-hdtl Parse_shen-dot-<rules>))) (fail))) (fail))) (fail)))] (if (= YaccParse (fail)) (clojure.core/let [Parse_shen-dot-<name> (shen-dot-<name> V1395)] (if (not (= (fail) Parse_shen-dot-<name>)) (clojure.core/let [Parse_shen-dot-<rules> (shen-dot-<rules> Parse_shen-dot-<name>)] (if (not (= (fail) Parse_shen-dot-<rules>)) (shen-dot-pair (hd Parse_shen-dot-<rules>) (shen-dot-compile_to_machine_code (shen-dot-hdtl Parse_shen-dot-<name>) (shen-dot-hdtl Parse_shen-dot-<rules>))) (fail))) (fail))) YaccParse)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? hd shen-dot-pair tl shen-dot-hdtl symbol? not shen-dot-sysfunc? simple-error shen-dot-app fail) (clojure.core/defn shen-dot-<name> [V1397] (if (cons? (hd V1397)) (clojure.core/let [Parse_X (hd (hd V1397))] (shen-dot-pair (hd (shen-dot-pair (tl (hd V1397)) (shen-dot-hdtl V1397))) (if (clojure.core/and (symbol? Parse_X) (not (shen-dot-sysfunc? Parse_X))) Parse_X (simple-error (shen-dot-app Parse_X " is not a legitimate function name.\n" (quote shen-dot-a)))))) (fail)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare element? get intern value) (clojure.core/defn shen-dot-sysfunc? [V1399] (element? V1399 (get (intern "shen") (quote shen-dot-external-symbols) (value (quote *property-vector*)))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? hd = shen-dot-<signature-help> shen-dot-pair tl shen-dot-hdtl not fail shen-dot-demodulate shen-dot-curry-type) (clojure.core/defn shen-dot-<signature> [V1401] (if (clojure.core/and (cons? (hd V1401)) (= (quote -lcurlybrac-) (hd (hd V1401)))) (clojure.core/let [Parse_shen-dot-<signature-help> (shen-dot-<signature-help> (shen-dot-pair (tl (hd V1401)) (shen-dot-hdtl V1401)))] (if (not (= (fail) Parse_shen-dot-<signature-help>)) (if (clojure.core/and (cons? (hd Parse_shen-dot-<signature-help>)) (= (quote -rcurlybrac-) (hd (hd Parse_shen-dot-<signature-help>)))) (shen-dot-pair (hd (shen-dot-pair (tl (hd Parse_shen-dot-<signature-help>)) (shen-dot-hdtl Parse_shen-dot-<signature-help>))) (shen-dot-demodulate (shen-dot-curry-type (shen-dot-hdtl Parse_shen-dot-<signature-help>)))) (fail)) (fail))) (fail)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-curry-type cons? tl = hd cons map) (clojure.core/defn shen-dot-curry-type [V1403] (clojure.core/cond (clojure.core/and (cons? V1403) (clojure.core/and (cons? (tl V1403)) (clojure.core/and (= (quote -->) (hd (tl V1403))) (clojure.core/and (cons? (tl (tl V1403))) (clojure.core/and (cons? (tl (tl (tl V1403)))) (= (quote -->) (hd (tl (tl (tl V1403)))))))))) (shen-dot-curry-type (cons (hd V1403) (cons (quote -->) (cons (tl (tl V1403)) ())))) (clojure.core/and (cons? V1403) (clojure.core/and (cons? (tl V1403)) (clojure.core/and (= (quote *) (hd (tl V1403))) (clojure.core/and (cons? (tl (tl V1403))) (clojure.core/and (cons? (tl (tl (tl V1403)))) (= (quote *) (hd (tl (tl (tl V1403)))))))))) (shen-dot-curry-type (cons (hd V1403) (cons (quote *) (cons (tl (tl V1403)) ())))) (cons? V1403) (map (do (clojure.core/declare shen-dot-curry-type) (clojure.core/fn [Z] (shen-dot-curry-type Z))) V1403) true V1403 :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? hd shen-dot-<signature-help> shen-dot-pair tl shen-dot-hdtl not = fail element? cons <e>) (clojure.core/defn shen-dot-<signature-help> [V1405] (clojure.core/let [YaccParse (if (cons? (hd V1405)) (clojure.core/let [Parse_X (hd (hd V1405))] (clojure.core/let [Parse_shen-dot-<signature-help> (shen-dot-<signature-help> (shen-dot-pair (tl (hd V1405)) (shen-dot-hdtl V1405)))] (if (not (= (fail) Parse_shen-dot-<signature-help>)) (if (not (element? Parse_X (cons (quote -lcurlybrac-) (cons (quote -rcurlybrac-) ())))) (shen-dot-pair (hd Parse_shen-dot-<signature-help>) (cons Parse_X (shen-dot-hdtl Parse_shen-dot-<signature-help>))) (fail)) (fail)))) (fail))] (if (= YaccParse (fail)) (clojure.core/let [Parse_<e> (<e> V1405)] (if (not (= (fail) Parse_<e>)) (shen-dot-pair (hd Parse_<e>) ()) (fail))) YaccParse)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-<rule> not = fail shen-dot-<rules> shen-dot-pair hd cons shen-dot-linearise shen-dot-hdtl) (clojure.core/defn shen-dot-<rules> [V1407] (clojure.core/let [YaccParse (clojure.core/let [Parse_shen-dot-<rule> (shen-dot-<rule> V1407)] (if (not (= (fail) Parse_shen-dot-<rule>)) (clojure.core/let [Parse_shen-dot-<rules> (shen-dot-<rules> Parse_shen-dot-<rule>)] (if (not (= (fail) Parse_shen-dot-<rules>)) (shen-dot-pair (hd Parse_shen-dot-<rules>) (cons (shen-dot-linearise (shen-dot-hdtl Parse_shen-dot-<rule>)) (shen-dot-hdtl Parse_shen-dot-<rules>))) (fail))) (fail)))] (if (= YaccParse (fail)) (clojure.core/let [Parse_shen-dot-<rule> (shen-dot-<rule> V1407)] (if (not (= (fail) Parse_shen-dot-<rule>)) (shen-dot-pair (hd Parse_shen-dot-<rule>) (cons (shen-dot-linearise (shen-dot-hdtl Parse_shen-dot-<rule>)) ())) (fail))) YaccParse)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-<patterns> not = fail cons? hd shen-dot-<action> shen-dot-pair tl shen-dot-hdtl shen-dot-<guard> cons) (clojure.core/defn shen-dot-<rule> [V1409] (clojure.core/let [YaccParse (clojure.core/let [Parse_shen-dot-<patterns> (shen-dot-<patterns> V1409)] (if (not (= (fail) Parse_shen-dot-<patterns>)) (if (clojure.core/and (cons? (hd Parse_shen-dot-<patterns>)) (= (quote ->) (hd (hd Parse_shen-dot-<patterns>)))) (clojure.core/let [Parse_shen-dot-<action> (shen-dot-<action> (shen-dot-pair (tl (hd Parse_shen-dot-<patterns>)) (shen-dot-hdtl Parse_shen-dot-<patterns>)))] (if (not (= (fail) Parse_shen-dot-<action>)) (if (clojure.core/and (cons? (hd Parse_shen-dot-<action>)) (= (quote where) (hd (hd Parse_shen-dot-<action>)))) (clojure.core/let [Parse_shen-dot-<guard> (shen-dot-<guard> (shen-dot-pair (tl (hd Parse_shen-dot-<action>)) (shen-dot-hdtl Parse_shen-dot-<action>)))] (if (not (= (fail) Parse_shen-dot-<guard>)) (shen-dot-pair (hd Parse_shen-dot-<guard>) (cons (shen-dot-hdtl Parse_shen-dot-<patterns>) (cons (cons (quote where) (cons (shen-dot-hdtl Parse_shen-dot-<guard>) (cons (shen-dot-hdtl Parse_shen-dot-<action>) ()))) ()))) (fail))) (fail)) (fail))) (fail)) (fail)))] (if (= YaccParse (fail)) (clojure.core/let [YaccParse (clojure.core/let [Parse_shen-dot-<patterns> (shen-dot-<patterns> V1409)] (if (not (= (fail) Parse_shen-dot-<patterns>)) (if (clojure.core/and (cons? (hd Parse_shen-dot-<patterns>)) (= (quote ->) (hd (hd Parse_shen-dot-<patterns>)))) (clojure.core/let [Parse_shen-dot-<action> (shen-dot-<action> (shen-dot-pair (tl (hd Parse_shen-dot-<patterns>)) (shen-dot-hdtl Parse_shen-dot-<patterns>)))] (if (not (= (fail) Parse_shen-dot-<action>)) (shen-dot-pair (hd Parse_shen-dot-<action>) (cons (shen-dot-hdtl Parse_shen-dot-<patterns>) (cons (shen-dot-hdtl Parse_shen-dot-<action>) ()))) (fail))) (fail)) (fail)))] (if (= YaccParse (fail)) (clojure.core/let [YaccParse (clojure.core/let [Parse_shen-dot-<patterns> (shen-dot-<patterns> V1409)] (if (not (= (fail) Parse_shen-dot-<patterns>)) (if (clojure.core/and (cons? (hd Parse_shen-dot-<patterns>)) (= (quote <-) (hd (hd Parse_shen-dot-<patterns>)))) (clojure.core/let [Parse_shen-dot-<action> (shen-dot-<action> (shen-dot-pair (tl (hd Parse_shen-dot-<patterns>)) (shen-dot-hdtl Parse_shen-dot-<patterns>)))] (if (not (= (fail) Parse_shen-dot-<action>)) (if (clojure.core/and (cons? (hd Parse_shen-dot-<action>)) (= (quote where) (hd (hd Parse_shen-dot-<action>)))) (clojure.core/let [Parse_shen-dot-<guard> (shen-dot-<guard> (shen-dot-pair (tl (hd Parse_shen-dot-<action>)) (shen-dot-hdtl Parse_shen-dot-<action>)))] (if (not (= (fail) Parse_shen-dot-<guard>)) (shen-dot-pair (hd Parse_shen-dot-<guard>) (cons (shen-dot-hdtl Parse_shen-dot-<patterns>) (cons (cons (quote where) (cons (shen-dot-hdtl Parse_shen-dot-<guard>) (cons (cons (quote shen-dot-choicepoint!) (cons (shen-dot-hdtl Parse_shen-dot-<action>) ())) ()))) ()))) (fail))) (fail)) (fail))) (fail)) (fail)))] (if (= YaccParse (fail)) (clojure.core/let [Parse_shen-dot-<patterns> (shen-dot-<patterns> V1409)] (if (not (= (fail) Parse_shen-dot-<patterns>)) (if (clojure.core/and (cons? (hd Parse_shen-dot-<patterns>)) (= (quote <-) (hd (hd Parse_shen-dot-<patterns>)))) (clojure.core/let [Parse_shen-dot-<action> (shen-dot-<action> (shen-dot-pair (tl (hd Parse_shen-dot-<patterns>)) (shen-dot-hdtl Parse_shen-dot-<patterns>)))] (if (not (= (fail) Parse_shen-dot-<action>)) (shen-dot-pair (hd Parse_shen-dot-<action>) (cons (shen-dot-hdtl Parse_shen-dot-<patterns>) (cons (cons (quote shen-dot-choicepoint!) (cons (shen-dot-hdtl Parse_shen-dot-<action>) ())) ()))) (fail))) (fail)) (fail))) YaccParse)) YaccParse)) YaccParse)))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-fail_if [V1412 V1413] (if ((shen.primitives/resolve-fn V1412) V1413) (fail) V1413)))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare = fail) (clojure.core/defn shen-dot-succeeds? [V1419] (clojure.core/cond (= V1419 (fail)) false true true :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-<pattern> not = fail shen-dot-<patterns> shen-dot-pair hd cons shen-dot-hdtl <e>) (clojure.core/defn shen-dot-<patterns> [V1421] (clojure.core/let [YaccParse (clojure.core/let [Parse_shen-dot-<pattern> (shen-dot-<pattern> V1421)] (if (not (= (fail) Parse_shen-dot-<pattern>)) (clojure.core/let [Parse_shen-dot-<patterns> (shen-dot-<patterns> Parse_shen-dot-<pattern>)] (if (not (= (fail) Parse_shen-dot-<patterns>)) (shen-dot-pair (hd Parse_shen-dot-<patterns>) (cons (shen-dot-hdtl Parse_shen-dot-<pattern>) (shen-dot-hdtl Parse_shen-dot-<patterns>))) (fail))) (fail)))] (if (= YaccParse (fail)) (clojure.core/let [Parse_<e> (<e> V1421)] (if (not (= (fail) Parse_<e>)) (shen-dot-pair (hd Parse_<e>) ()) (fail))) YaccParse)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? hd shen-dot-pair tl = shen-dot-<pattern1> shen-dot-hdtl not fail shen-dot-<pattern2> cons shen-dot-constructor-error shen-dot-<simple_pattern>) (clojure.core/defn shen-dot-<pattern> [V1428] (clojure.core/let [YaccParse (if (clojure.core/and (cons? (hd V1428)) (cons? (hd (hd V1428)))) (if (clojure.core/and (cons? (hd (shen-dot-pair (hd (hd V1428)) (hd (tl V1428))))) (= (quote -at-p) (hd (hd (shen-dot-pair (hd (hd V1428)) (hd (tl V1428))))))) (clojure.core/let [Parse_shen-dot-<pattern1> (shen-dot-<pattern1> (shen-dot-pair (tl (hd (shen-dot-pair (hd (hd V1428)) (hd (tl V1428))))) (shen-dot-hdtl (shen-dot-pair (hd (hd V1428)) (hd (tl V1428))))))] (if (not (= (fail) Parse_shen-dot-<pattern1>)) (clojure.core/let [Parse_shen-dot-<pattern2> (shen-dot-<pattern2> Parse_shen-dot-<pattern1>)] (if (not (= (fail) Parse_shen-dot-<pattern2>)) (shen-dot-pair (hd (shen-dot-pair (tl (hd V1428)) (hd (tl V1428)))) (cons (quote -at-p) (cons (shen-dot-hdtl Parse_shen-dot-<pattern1>) (cons (shen-dot-hdtl Parse_shen-dot-<pattern2>) ())))) (fail))) (fail))) (fail)) (fail))] (if (= YaccParse (fail)) (clojure.core/let [YaccParse (if (clojure.core/and (cons? (hd V1428)) (cons? (hd (hd V1428)))) (if (clojure.core/and (cons? (hd (shen-dot-pair (hd (hd V1428)) (hd (tl V1428))))) (= (quote cons) (hd (hd (shen-dot-pair (hd (hd V1428)) (hd (tl V1428))))))) (clojure.core/let [Parse_shen-dot-<pattern1> (shen-dot-<pattern1> (shen-dot-pair (tl (hd (shen-dot-pair (hd (hd V1428)) (hd (tl V1428))))) (shen-dot-hdtl (shen-dot-pair (hd (hd V1428)) (hd (tl V1428))))))] (if (not (= (fail) Parse_shen-dot-<pattern1>)) (clojure.core/let [Parse_shen-dot-<pattern2> (shen-dot-<pattern2> Parse_shen-dot-<pattern1>)] (if (not (= (fail) Parse_shen-dot-<pattern2>)) (shen-dot-pair (hd (shen-dot-pair (tl (hd V1428)) (hd (tl V1428)))) (cons (quote cons) (cons (shen-dot-hdtl Parse_shen-dot-<pattern1>) (cons (shen-dot-hdtl Parse_shen-dot-<pattern2>) ())))) (fail))) (fail))) (fail)) (fail))] (if (= YaccParse (fail)) (clojure.core/let [YaccParse (if (clojure.core/and (cons? (hd V1428)) (cons? (hd (hd V1428)))) (if (clojure.core/and (cons? (hd (shen-dot-pair (hd (hd V1428)) (hd (tl V1428))))) (= (quote -at-v) (hd (hd (shen-dot-pair (hd (hd V1428)) (hd (tl V1428))))))) (clojure.core/let [Parse_shen-dot-<pattern1> (shen-dot-<pattern1> (shen-dot-pair (tl (hd (shen-dot-pair (hd (hd V1428)) (hd (tl V1428))))) (shen-dot-hdtl (shen-dot-pair (hd (hd V1428)) (hd (tl V1428))))))] (if (not (= (fail) Parse_shen-dot-<pattern1>)) (clojure.core/let [Parse_shen-dot-<pattern2> (shen-dot-<pattern2> Parse_shen-dot-<pattern1>)] (if (not (= (fail) Parse_shen-dot-<pattern2>)) (shen-dot-pair (hd (shen-dot-pair (tl (hd V1428)) (hd (tl V1428)))) (cons (quote -at-v) (cons (shen-dot-hdtl Parse_shen-dot-<pattern1>) (cons (shen-dot-hdtl Parse_shen-dot-<pattern2>) ())))) (fail))) (fail))) (fail)) (fail))] (if (= YaccParse (fail)) (clojure.core/let [YaccParse (if (clojure.core/and (cons? (hd V1428)) (cons? (hd (hd V1428)))) (if (clojure.core/and (cons? (hd (shen-dot-pair (hd (hd V1428)) (hd (tl V1428))))) (= (quote -at-s) (hd (hd (shen-dot-pair (hd (hd V1428)) (hd (tl V1428))))))) (clojure.core/let [Parse_shen-dot-<pattern1> (shen-dot-<pattern1> (shen-dot-pair (tl (hd (shen-dot-pair (hd (hd V1428)) (hd (tl V1428))))) (shen-dot-hdtl (shen-dot-pair (hd (hd V1428)) (hd (tl V1428))))))] (if (not (= (fail) Parse_shen-dot-<pattern1>)) (clojure.core/let [Parse_shen-dot-<pattern2> (shen-dot-<pattern2> Parse_shen-dot-<pattern1>)] (if (not (= (fail) Parse_shen-dot-<pattern2>)) (shen-dot-pair (hd (shen-dot-pair (tl (hd V1428)) (hd (tl V1428)))) (cons (quote -at-s) (cons (shen-dot-hdtl Parse_shen-dot-<pattern1>) (cons (shen-dot-hdtl Parse_shen-dot-<pattern2>) ())))) (fail))) (fail))) (fail)) (fail))] (if (= YaccParse (fail)) (clojure.core/let [YaccParse (if (clojure.core/and (cons? (hd V1428)) (cons? (hd (hd V1428)))) (if (clojure.core/and (cons? (hd (shen-dot-pair (hd (hd V1428)) (hd (tl V1428))))) (= (quote vector) (hd (hd (shen-dot-pair (hd (hd V1428)) (hd (tl V1428))))))) (if (clojure.core/and (cons? (hd (shen-dot-pair (tl (hd (shen-dot-pair (hd (hd V1428)) (hd (tl V1428))))) (shen-dot-hdtl (shen-dot-pair (hd (hd V1428)) (hd (tl V1428))))))) (= 0 (hd (hd (shen-dot-pair (tl (hd (shen-dot-pair (hd (hd V1428)) (hd (tl V1428))))) (shen-dot-hdtl (shen-dot-pair (hd (hd V1428)) (hd (tl V1428))))))))) (shen-dot-pair (hd (shen-dot-pair (tl (hd V1428)) (hd (tl V1428)))) (cons (quote vector) (cons 0 ()))) (fail)) (fail)) (fail))] (if (= YaccParse (fail)) (clojure.core/let [YaccParse (if (cons? (hd V1428)) (clojure.core/let [Parse_X (hd (hd V1428))] (if (cons? Parse_X) (shen-dot-pair (hd (shen-dot-pair (tl (hd V1428)) (shen-dot-hdtl V1428))) (shen-dot-constructor-error Parse_X)) (fail))) (fail))] (if (= YaccParse (fail)) (clojure.core/let [Parse_shen-dot-<simple_pattern> (shen-dot-<simple_pattern> V1428)] (if (not (= (fail) Parse_shen-dot-<simple_pattern>)) (shen-dot-pair (hd Parse_shen-dot-<simple_pattern>) (shen-dot-hdtl Parse_shen-dot-<simple_pattern>)) (fail))) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare simple-error shen-dot-app) (clojure.core/defn shen-dot-constructor-error [V1430] (simple-error (shen-dot-app V1430 " is not a legitimate constructor\n" (quote shen-dot-a))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? hd = shen-dot-pair tl shen-dot-hdtl gensym fail not element? cons) (clojure.core/defn shen-dot-<simple_pattern> [V1432] (clojure.core/let [YaccParse (if (cons? (hd V1432)) (clojure.core/let [Parse_X (hd (hd V1432))] (if (= Parse_X (quote _)) (shen-dot-pair (hd (shen-dot-pair (tl (hd V1432)) (shen-dot-hdtl V1432))) (gensym (quote Parse_Y))) (fail))) (fail))] (if (= YaccParse (fail)) (if (cons? (hd V1432)) (clojure.core/let [Parse_X (hd (hd V1432))] (if (not (element? Parse_X (cons (quote ->) (cons (quote <-) ())))) (shen-dot-pair (hd (shen-dot-pair (tl (hd V1432)) (shen-dot-hdtl V1432))) Parse_X) (fail))) (fail)) YaccParse)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-<pattern> not = fail shen-dot-pair hd shen-dot-hdtl) (clojure.core/defn shen-dot-<pattern1> [V1434] (clojure.core/let [Parse_shen-dot-<pattern> (shen-dot-<pattern> V1434)] (if (not (= (fail) Parse_shen-dot-<pattern>)) (shen-dot-pair (hd Parse_shen-dot-<pattern>) (shen-dot-hdtl Parse_shen-dot-<pattern>)) (fail))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-<pattern> not = fail shen-dot-pair hd shen-dot-hdtl) (clojure.core/defn shen-dot-<pattern2> [V1436] (clojure.core/let [Parse_shen-dot-<pattern> (shen-dot-<pattern> V1436)] (if (not (= (fail) Parse_shen-dot-<pattern>)) (shen-dot-pair (hd Parse_shen-dot-<pattern>) (shen-dot-hdtl Parse_shen-dot-<pattern>)) (fail))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? hd shen-dot-pair tl shen-dot-hdtl fail) (clojure.core/defn shen-dot-<action> [V1438] (if (cons? (hd V1438)) (clojure.core/let [Parse_X (hd (hd V1438))] (shen-dot-pair (hd (shen-dot-pair (tl (hd V1438)) (shen-dot-hdtl V1438))) Parse_X)) (fail)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? hd shen-dot-pair tl shen-dot-hdtl fail) (clojure.core/defn shen-dot-<guard> [V1440] (if (cons? (hd V1440)) (clojure.core/let [Parse_X (hd (hd V1440))] (shen-dot-pair (hd (shen-dot-pair (tl (hd V1440)) (shen-dot-hdtl V1440))) Parse_X)) (fail)))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-compile_to_machine_code [V1443 V1444] (clojure.core/let [Lambda+ (shen-dot-compile_to_lambda+ V1443 V1444)] (clojure.core/let [KL (shen-dot-compile_to_kl V1443 Lambda+)] (clojure.core/let [Record (shen-dot-record-source V1443 KL)] KL)))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-record-source [V1449 V1450] (clojure.core/cond (value (quote shen-dot-*installing-kl*)) (quote shen-dot-skip) true (put V1449 (quote shen-dot-source) V1450 (value (quote *property-vector*))) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-compile_to_lambda+ [V1453 V1454] (clojure.core/let [Arity (shen-dot-aritycheck V1453 V1454)] (clojure.core/let [UpDateSymbolTable (shen-dot-update-symbol-table V1453 Arity)] (clojure.core/let [Free (shen-dot-for-each (do (clojure.core/declare shen-dot-free_variable_check) (clojure.core/fn [Rule] (shen-dot-free_variable_check V1453 Rule))) V1454)] (clojure.core/let [Variables (shen-dot-parameters Arity)] (clojure.core/let [Strip (map (do (clojure.core/declare shen-dot-strip-protect) (clojure.core/fn [X] (shen-dot-strip-protect X))) V1454)] (clojure.core/let [Abstractions (map (do (clojure.core/declare shen-dot-abstract_rule) (clojure.core/fn [X] (shen-dot-abstract_rule X))) Strip)] (clojure.core/let [Applications (map (do (clojure.core/declare shen-dot-application_build) (clojure.core/fn [X] (shen-dot-application_build Variables X))) Abstractions)] (cons Variables (cons Applications ())))))))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-update-symbol-table [V1457 V1458] (clojure.core/cond (= 0 V1458) (quote shen-dot-skip) true (put V1457 (quote shen-dot-lambda-form) (eval-kl (shen-dot-lambda-form V1457 V1458)) (value (quote *property-vector*))) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-free_variable_check [V1461 V1462] (clojure.core/cond (clojure.core/and (cons? V1462) (clojure.core/and (cons? (tl V1462)) (= () (tl (tl V1462))))) (clojure.core/let [Bound (shen-dot-extract_vars (hd V1462))] (clojure.core/let [Free (shen-dot-extract_free_vars Bound (hd (tl V1462)))] (shen-dot-free_variable_warnings V1461 Free))) true (shen-dot-f_error (quote shen-dot-free_variable_check)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare variable? cons cons? union shen-dot-extract_vars hd tl) (clojure.core/defn shen-dot-extract_vars [V1464] (clojure.core/cond (variable? V1464) (cons V1464 ()) (cons? V1464) (union (shen-dot-extract_vars (hd V1464)) (shen-dot-extract_vars (tl V1464))) true () :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-extract_free_vars [V1476 V1477] (clojure.core/cond (clojure.core/and (cons? V1477) (clojure.core/and (cons? (tl V1477)) (clojure.core/and (= () (tl (tl V1477))) (= (hd V1477) (quote protect))))) () (clojure.core/and (variable? V1477) (not (element? V1477 V1476))) (cons V1477 ()) (clojure.core/and (cons? V1477) (clojure.core/and (= (quote lambda) (hd V1477)) (clojure.core/and (cons? (tl V1477)) (clojure.core/and (cons? (tl (tl V1477))) (= () (tl (tl (tl V1477)))))))) (shen-dot-extract_free_vars (cons (hd (tl V1477)) V1476) (hd (tl (tl V1477)))) (clojure.core/and (cons? V1477) (clojure.core/and (= (quote let) (hd V1477)) (clojure.core/and (cons? (tl V1477)) (clojure.core/and (cons? (tl (tl V1477))) (clojure.core/and (cons? (tl (tl (tl V1477)))) (= () (tl (tl (tl (tl V1477)))))))))) (union (shen-dot-extract_free_vars V1476 (hd (tl (tl V1477)))) (shen-dot-extract_free_vars (cons (hd (tl V1477)) V1476) (hd (tl (tl (tl V1477)))))) (cons? V1477) (union (shen-dot-extract_free_vars V1476 (hd V1477)) (shen-dot-extract_free_vars V1476 (tl V1477))) true () :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-free_variable_warnings [V1482 V1483] (clojure.core/cond (= () V1483) (quote _) true (simple-error (cn "error: the following variables are free in " (shen-dot-app V1482 (cn ": " (shen-dot-app (shen-dot-list_variables V1483) "" (quote shen-dot-a))) (quote shen-dot-a)))) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? = tl cn str hd shen-dot-list_variables shen-dot-f_error) (clojure.core/defn shen-dot-list_variables [V1485] (clojure.core/cond (clojure.core/and (cons? V1485) (= () (tl V1485))) (cn (str (hd V1485)) ".") (cons? V1485) (cn (str (hd V1485)) (cn ", " (shen-dot-list_variables (tl V1485)))) true (shen-dot-f_error (quote shen-dot-list_variables)) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-strip-protect cons? tl = hd map) (clojure.core/defn shen-dot-strip-protect [V1487] (clojure.core/cond (clojure.core/and (cons? V1487) (clojure.core/and (cons? (tl V1487)) (clojure.core/and (= () (tl (tl V1487))) (= (hd V1487) (quote protect))))) (shen-dot-strip-protect (hd (tl V1487))) (cons? V1487) (map (do (clojure.core/declare shen-dot-strip-protect) (clojure.core/fn [Z] (shen-dot-strip-protect Z))) V1487) true V1487 :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? tl = shen-dot-linearise_help shen-dot-flatten hd shen-dot-f_error) (clojure.core/defn shen-dot-linearise [V1489] (clojure.core/cond (clojure.core/and (cons? V1489) (clojure.core/and (cons? (tl V1489)) (= () (tl (tl V1489))))) (shen-dot-linearise_help (shen-dot-flatten (hd V1489)) (hd V1489) (hd (tl V1489))) true (shen-dot-f_error (quote shen-dot-linearise)) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare = cons? append shen-dot-flatten hd tl cons) (clojure.core/defn shen-dot-flatten [V1491] (clojure.core/cond (= () V1491) () (cons? V1491) (append (shen-dot-flatten (hd V1491)) (shen-dot-flatten (tl V1491))) true (cons V1491 ()) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-linearise_help [V1495 V1496 V1497] (clojure.core/cond (= () V1495) (cons V1496 (cons V1497 ())) (cons? V1495) (if (clojure.core/and (variable? (hd V1495)) (element? (hd V1495) (tl V1495))) (clojure.core/let [Var (gensym (hd V1495))] (clojure.core/let [NewAction (cons (quote where) (cons (cons (quote =) (cons (hd V1495) (cons Var ()))) (cons V1497 ())))] (clojure.core/let [NewPatts (shen-dot-linearise_X (hd V1495) Var V1496)] (shen-dot-linearise_help (tl V1495) NewPatts NewAction)))) (shen-dot-linearise_help (tl V1495) V1496 V1497)) true (shen-dot-f_error (quote shen-dot-linearise_help)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-linearise_X [V1510 V1511 V1512] (clojure.core/cond (= V1512 V1510) V1511 (cons? V1512) (clojure.core/let [L (shen-dot-linearise_X V1510 V1511 (hd V1512))] (if (= L (hd V1512)) (cons (hd V1512) (shen-dot-linearise_X V1510 V1511 (tl V1512))) (cons L (tl V1512)))) true V1512 :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-aritycheck [V1515 V1516] (clojure.core/cond (clojure.core/and (cons? V1516) (clojure.core/and (cons? (hd V1516)) (clojure.core/and (cons? (tl (hd V1516))) (clojure.core/and (= () (tl (tl (hd V1516)))) (= () (tl V1516)))))) (do (shen-dot-aritycheck-action (hd (tl (hd V1516)))) (shen-dot-aritycheck-name V1515 (arity V1515) (length (hd (hd V1516))))) (clojure.core/and (cons? V1516) (clojure.core/and (cons? (hd V1516)) (clojure.core/and (cons? (tl (hd V1516))) (clojure.core/and (= () (tl (tl (hd V1516)))) (clojure.core/and (cons? (tl V1516)) (clojure.core/and (cons? (hd (tl V1516))) (clojure.core/and (cons? (tl (hd (tl V1516)))) (= () (tl (tl (hd (tl V1516)))))))))))) (if (= (length (hd (hd V1516))) (length (hd (hd (tl V1516))))) (do (shen-dot-aritycheck-action (hd (tl (hd V1516)))) (shen-dot-aritycheck V1515 (tl V1516))) (simple-error (cn "arity error in " (shen-dot-app V1515 "\n" (quote shen-dot-a))))) true (shen-dot-f_error (quote shen-dot-aritycheck)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-aritycheck-name [V1529 V1530 V1531] (clojure.core/cond (= -1 V1530) V1531 (= V1531 V1530) V1531 true (do (shen-dot-prhush (cn "\nwarning: changing the arity of " (shen-dot-app V1529 " can cause errors.\n" (quote shen-dot-a))) (stoutput)) V1531) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-aritycheck-action cons? shen-dot-aah hd tl shen-dot-for-each) (clojure.core/defn shen-dot-aritycheck-action [V1537] (clojure.core/cond (cons? V1537) (do (shen-dot-aah (hd V1537) (tl V1537)) (shen-dot-for-each (do (clojure.core/declare shen-dot-aritycheck-action) (clojure.core/fn [Y] (shen-dot-aritycheck-action Y))) V1537)) true (quote shen-dot-skip) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-aah [V1540 V1541] (clojure.core/let [Arity (arity V1540)] (clojure.core/let [Len (length V1541)] (if (clojure.core/and (> Arity -1) (> Len Arity)) (shen-dot-prhush (cn "warning: " (shen-dot-app V1540 (cn " might not like " (shen-dot-app Len (cn " argument" (shen-dot-app (if (> Len 1) "s" "") ".\n" (quote shen-dot-a))) (quote shen-dot-a))) (quote shen-dot-a))) (stoutput)) (quote shen-dot-skip))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? tl = shen-dot-abstraction_build hd shen-dot-f_error) (clojure.core/defn shen-dot-abstract_rule [V1543] (clojure.core/cond (clojure.core/and (cons? V1543) (clojure.core/and (cons? (tl V1543)) (= () (tl (tl V1543))))) (shen-dot-abstraction_build (hd V1543) (hd (tl V1543))) true (shen-dot-f_error (quote shen-dot-abstract_rule)) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-abstraction_build [V1546 V1547] (clojure.core/cond (= () V1546) V1547 (cons? V1546) (cons (quote -slash--dot-) (cons (hd V1546) (cons (shen-dot-abstraction_build (tl V1546) V1547) ()))) true (shen-dot-f_error (quote shen-dot-abstraction_build)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare = cons gensym shen-dot-parameters -) (clojure.core/defn shen-dot-parameters [V1549] (clojure.core/cond (= 0 V1549) () true (cons (gensym (quote V)) (shen-dot-parameters (- V1549 1))) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-application_build [V1552 V1553] (clojure.core/cond (= () V1552) V1553 (cons? V1552) (shen-dot-application_build (tl V1552) (cons V1553 (cons (hd V1552) ()))) true (shen-dot-f_error (quote shen-dot-application_build)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-compile_to_kl [V1556 V1557] (clojure.core/cond (clojure.core/and (cons? V1557) (clojure.core/and (cons? (tl V1557)) (= () (tl (tl V1557))))) (clojure.core/let [Arity (shen-dot-store-arity V1556 (length (hd V1557)))] (clojure.core/let [Reduce (map (do (clojure.core/declare shen-dot-reduce) (clojure.core/fn [X] (shen-dot-reduce X))) (hd (tl V1557)))] (clojure.core/let [CondExpression (shen-dot-cond-expression V1556 (hd V1557) Reduce)] (clojure.core/let [TypeTable (if (value (quote shen-dot-*optimise*)) (shen-dot-typextable (shen-dot-get-type V1556) (hd V1557)) (quote shen-dot-skip))] (clojure.core/let [TypedCondExpression (if (value (quote shen-dot-*optimise*)) (shen-dot-assign-types (hd V1557) TypeTable CondExpression) CondExpression)] (cons (quote defun) (cons V1556 (cons (hd V1557) (cons TypedCondExpression ()))))))))) true (shen-dot-f_error (quote shen-dot-compile_to_kl)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? assoc value empty? tl) (clojure.core/defn shen-dot-get-type [V1563] (clojure.core/cond (cons? V1563) (quote shen-dot-skip) true (clojure.core/let [FType (assoc V1563 (value (quote shen-dot-*signedfuncs*)))] (if (empty? FType) (quote shen-dot-skip) (tl FType))) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-typextable [V1574 V1575] (clojure.core/cond (clojure.core/and (cons? V1574) (clojure.core/and (cons? (tl V1574)) (clojure.core/and (= (quote -->) (hd (tl V1574))) (clojure.core/and (cons? (tl (tl V1574))) (clojure.core/and (= () (tl (tl (tl V1574)))) (cons? V1575)))))) (if (variable? (hd V1574)) (shen-dot-typextable (hd (tl (tl V1574))) (tl V1575)) (cons (cons (hd V1575) (hd V1574)) (shen-dot-typextable (hd (tl (tl V1574))) (tl V1575)))) true () :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-assign-types [V1579 V1580 V1581] (clojure.core/cond (clojure.core/and (cons? V1581) (clojure.core/and (= (quote let) (hd V1581)) (clojure.core/and (cons? (tl V1581)) (clojure.core/and (cons? (tl (tl V1581))) (clojure.core/and (cons? (tl (tl (tl V1581)))) (= () (tl (tl (tl (tl V1581)))))))))) (cons (quote let) (cons (hd (tl V1581)) (cons (shen-dot-assign-types V1579 V1580 (hd (tl (tl V1581)))) (cons (shen-dot-assign-types (cons (hd (tl V1581)) V1579) V1580 (hd (tl (tl (tl V1581))))) ())))) (clojure.core/and (cons? V1581) (clojure.core/and (= (quote lambda) (hd V1581)) (clojure.core/and (cons? (tl V1581)) (clojure.core/and (cons? (tl (tl V1581))) (= () (tl (tl (tl V1581)))))))) (cons (quote lambda) (cons (hd (tl V1581)) (cons (shen-dot-assign-types (cons (hd (tl V1581)) V1579) V1580 (hd (tl (tl V1581)))) ()))) (clojure.core/and (cons? V1581) (= (quote cond) (hd V1581))) (cons (quote cond) (map (do (clojure.core/declare cons shen-dot-assign-types hd tl) (clojure.core/fn [Y] (cons (shen-dot-assign-types V1579 V1580 (hd Y)) (cons (shen-dot-assign-types V1579 V1580 (hd (tl Y))) ())))) (tl V1581))) (cons? V1581) (clojure.core/let [NewTable (shen-dot-typextable (shen-dot-get-type (hd V1581)) (tl V1581))] (cons (hd V1581) (map (do (clojure.core/declare shen-dot-assign-types append) (clojure.core/fn [Y] (shen-dot-assign-types V1579 (append V1580 NewTable) Y))) (tl V1581)))) true (clojure.core/let [AtomType (assoc V1581 V1580)] (if (cons? AtomType) (cons (quote type) (cons V1581 (cons (tl AtomType) ()))) (if (element? V1581 V1579) V1581 (shen-dot-atom-type V1581)))) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare string? cons number? boolean? symbol?) (clojure.core/defn shen-dot-atom-type [V1583] (if (string? V1583) (cons (quote type) (cons V1583 (cons (quote string) ()))) (if (number? V1583) (cons (quote type) (cons V1583 (cons (quote number) ()))) (if (boolean? V1583) (cons (quote type) (cons V1583 (cons (quote boolean) ()))) (if (symbol? V1583) (cons (quote type) (cons V1583 (cons (quote symbol) ()))) V1583)))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-store-arity [V1588 V1589] (clojure.core/cond (value (quote shen-dot-*installing-kl*)) (quote shen-dot-skip) true (put V1588 (quote arity) V1589 (value (quote *property-vector*))) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare set shen-dot-reduce_help cons reverse value) (clojure.core/defn shen-dot-reduce [V1591] (do (set (quote shen-dot-*teststack*) ()) (clojure.core/let [Result (shen-dot-reduce_help V1591)] (cons (cons (quote -colon-) (cons (quote shen-dot-tests) (reverse (value (quote shen-dot-*teststack*))))) (cons Result ())))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? hd = tl shen-dot-add_test cons shen-dot-ebr shen-dot-reduce_help not variable?) (clojure.core/defn shen-dot-reduce_help [V1593] (clojure.core/cond (clojure.core/and (cons? V1593) (clojure.core/and (cons? (hd V1593)) (clojure.core/and (= (quote -slash--dot-) (hd (hd V1593))) (clojure.core/and (cons? (tl (hd V1593))) (clojure.core/and (cons? (hd (tl (hd V1593)))) (clojure.core/and (= (quote cons) (hd (hd (tl (hd V1593))))) (clojure.core/and (cons? (tl (hd (tl (hd V1593))))) (clojure.core/and (cons? (tl (tl (hd (tl (hd V1593)))))) (clojure.core/and (= () (tl (tl (tl (hd (tl (hd V1593))))))) (clojure.core/and (cons? (tl (tl (hd V1593)))) (clojure.core/and (= () (tl (tl (tl (hd V1593))))) (clojure.core/and (cons? (tl V1593)) (= () (tl (tl V1593))))))))))))))) (do (shen-dot-add_test (cons (quote cons?) (tl V1593))) (clojure.core/let [Abstraction (cons (quote -slash--dot-) (cons (hd (tl (hd (tl (hd V1593))))) (cons (cons (quote -slash--dot-) (cons (hd (tl (tl (hd (tl (hd V1593)))))) (cons (shen-dot-ebr (hd (tl V1593)) (hd (tl (hd V1593))) (hd (tl (tl (hd V1593))))) ()))) ())))] (clojure.core/let [Application (cons (cons Abstraction (cons (cons (quote hd) (tl V1593)) ())) (cons (cons (quote tl) (tl V1593)) ()))] (shen-dot-reduce_help Application)))) (clojure.core/and (cons? V1593) (clojure.core/and (cons? (hd V1593)) (clojure.core/and (= (quote -slash--dot-) (hd (hd V1593))) (clojure.core/and (cons? (tl (hd V1593))) (clojure.core/and (cons? (hd (tl (hd V1593)))) (clojure.core/and (= (quote -at-p) (hd (hd (tl (hd V1593))))) (clojure.core/and (cons? (tl (hd (tl (hd V1593))))) (clojure.core/and (cons? (tl (tl (hd (tl (hd V1593)))))) (clojure.core/and (= () (tl (tl (tl (hd (tl (hd V1593))))))) (clojure.core/and (cons? (tl (tl (hd V1593)))) (clojure.core/and (= () (tl (tl (tl (hd V1593))))) (clojure.core/and (cons? (tl V1593)) (= () (tl (tl V1593))))))))))))))) (do (shen-dot-add_test (cons (quote tuple?) (tl V1593))) (clojure.core/let [Abstraction (cons (quote -slash--dot-) (cons (hd (tl (hd (tl (hd V1593))))) (cons (cons (quote -slash--dot-) (cons (hd (tl (tl (hd (tl (hd V1593)))))) (cons (shen-dot-ebr (hd (tl V1593)) (hd (tl (hd V1593))) (hd (tl (tl (hd V1593))))) ()))) ())))] (clojure.core/let [Application (cons (cons Abstraction (cons (cons (quote fst) (tl V1593)) ())) (cons (cons (quote snd) (tl V1593)) ()))] (shen-dot-reduce_help Application)))) (clojure.core/and (cons? V1593) (clojure.core/and (cons? (hd V1593)) (clojure.core/and (= (quote -slash--dot-) (hd (hd V1593))) (clojure.core/and (cons? (tl (hd V1593))) (clojure.core/and (cons? (hd (tl (hd V1593)))) (clojure.core/and (= (quote -at-v) (hd (hd (tl (hd V1593))))) (clojure.core/and (cons? (tl (hd (tl (hd V1593))))) (clojure.core/and (cons? (tl (tl (hd (tl (hd V1593)))))) (clojure.core/and (= () (tl (tl (tl (hd (tl (hd V1593))))))) (clojure.core/and (cons? (tl (tl (hd V1593)))) (clojure.core/and (= () (tl (tl (tl (hd V1593))))) (clojure.core/and (cons? (tl V1593)) (= () (tl (tl V1593))))))))))))))) (do (shen-dot-add_test (cons (quote shen-dot-+vector?) (tl V1593))) (clojure.core/let [Abstraction (cons (quote -slash--dot-) (cons (hd (tl (hd (tl (hd V1593))))) (cons (cons (quote -slash--dot-) (cons (hd (tl (tl (hd (tl (hd V1593)))))) (cons (shen-dot-ebr (hd (tl V1593)) (hd (tl (hd V1593))) (hd (tl (tl (hd V1593))))) ()))) ())))] (clojure.core/let [Application (cons (cons Abstraction (cons (cons (quote hdv) (tl V1593)) ())) (cons (cons (quote tlv) (tl V1593)) ()))] (shen-dot-reduce_help Application)))) (clojure.core/and (cons? V1593) (clojure.core/and (cons? (hd V1593)) (clojure.core/and (= (quote -slash--dot-) (hd (hd V1593))) (clojure.core/and (cons? (tl (hd V1593))) (clojure.core/and (cons? (hd (tl (hd V1593)))) (clojure.core/and (= (quote -at-s) (hd (hd (tl (hd V1593))))) (clojure.core/and (cons? (tl (hd (tl (hd V1593))))) (clojure.core/and (cons? (tl (tl (hd (tl (hd V1593)))))) (clojure.core/and (= () (tl (tl (tl (hd (tl (hd V1593))))))) (clojure.core/and (cons? (tl (tl (hd V1593)))) (clojure.core/and (= () (tl (tl (tl (hd V1593))))) (clojure.core/and (cons? (tl V1593)) (= () (tl (tl V1593))))))))))))))) (do (shen-dot-add_test (cons (quote shen-dot-+string?) (tl V1593))) (clojure.core/let [Abstraction (cons (quote -slash--dot-) (cons (hd (tl (hd (tl (hd V1593))))) (cons (cons (quote -slash--dot-) (cons (hd (tl (tl (hd (tl (hd V1593)))))) (cons (shen-dot-ebr (hd (tl V1593)) (hd (tl (hd V1593))) (hd (tl (tl (hd V1593))))) ()))) ())))] (clojure.core/let [Application (cons (cons Abstraction (cons (cons (quote pos) (cons (hd (tl V1593)) (cons 0 ()))) ())) (cons (cons (quote tlstr) (tl V1593)) ()))] (shen-dot-reduce_help Application)))) (clojure.core/and (cons? V1593) (clojure.core/and (cons? (hd V1593)) (clojure.core/and (= (quote -slash--dot-) (hd (hd V1593))) (clojure.core/and (cons? (tl (hd V1593))) (clojure.core/and (cons? (tl (tl (hd V1593)))) (clojure.core/and (= () (tl (tl (tl (hd V1593))))) (clojure.core/and (cons? (tl V1593)) (clojure.core/and (= () (tl (tl V1593))) (not (variable? (hd (tl (hd V1593))))))))))))) (do (shen-dot-add_test (cons (quote =) (cons (hd (tl (hd V1593))) (tl V1593)))) (shen-dot-reduce_help (hd (tl (tl (hd V1593)))))) (clojure.core/and (cons? V1593) (clojure.core/and (cons? (hd V1593)) (clojure.core/and (= (quote -slash--dot-) (hd (hd V1593))) (clojure.core/and (cons? (tl (hd V1593))) (clojure.core/and (cons? (tl (tl (hd V1593)))) (clojure.core/and (= () (tl (tl (tl (hd V1593))))) (clojure.core/and (cons? (tl V1593)) (= () (tl (tl V1593)))))))))) (shen-dot-reduce_help (shen-dot-ebr (hd (tl V1593)) (hd (tl (hd V1593))) (hd (tl (tl (hd V1593)))))) (clojure.core/and (cons? V1593) (clojure.core/and (= (quote where) (hd V1593)) (clojure.core/and (cons? (tl V1593)) (clojure.core/and (cons? (tl (tl V1593))) (= () (tl (tl (tl V1593)))))))) (do (shen-dot-add_test (hd (tl V1593))) (shen-dot-reduce_help (hd (tl (tl V1593))))) (clojure.core/and (cons? V1593) (clojure.core/and (cons? (tl V1593)) (= () (tl (tl V1593))))) (clojure.core/let [Z (shen-dot-reduce_help (hd V1593))] (if (= (hd V1593) Z) V1593 (shen-dot-reduce_help (cons Z (tl V1593))))) true V1593 :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare = string?) (clojure.core/defn shen-dot-+string? [V1595] (clojure.core/cond (= "" V1595) false true (string? V1595) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare absvector? > <-address) (clojure.core/defn shen-dot-+vector? [V1597] (clojure.core/and (absvector? V1597) (> (<-address V1597 0) 0)))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-ebr [V1611 V1612 V1613] (clojure.core/cond (= V1613 V1612) V1611 (clojure.core/and (cons? V1613) (clojure.core/and (= (quote -slash--dot-) (hd V1613)) (clojure.core/and (cons? (tl V1613)) (clojure.core/and (cons? (tl (tl V1613))) (clojure.core/and (= () (tl (tl (tl V1613)))) (> (occurrences V1612 (hd (tl V1613))) 0)))))) V1613 (clojure.core/and (cons? V1613) (clojure.core/and (= (quote lambda) (hd V1613)) (clojure.core/and (cons? (tl V1613)) (clojure.core/and (cons? (tl (tl V1613))) (clojure.core/and (= () (tl (tl (tl V1613)))) (> (occurrences V1612 (hd (tl V1613))) 0)))))) V1613 (clojure.core/and (cons? V1613) (clojure.core/and (= (quote let) (hd V1613)) (clojure.core/and (cons? (tl V1613)) (clojure.core/and (cons? (tl (tl V1613))) (clojure.core/and (cons? (tl (tl (tl V1613)))) (clojure.core/and (= () (tl (tl (tl (tl V1613))))) (= (hd (tl V1613)) V1612))))))) (cons (quote let) (cons (hd (tl V1613)) (cons (shen-dot-ebr V1611 (hd (tl V1613)) (hd (tl (tl V1613)))) (tl (tl (tl V1613)))))) (cons? V1613) (cons (shen-dot-ebr V1611 V1612 (hd V1613)) (shen-dot-ebr V1611 V1612 (tl V1613))) true V1613 :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare set cons value) (clojure.core/defn shen-dot-add_test [V1615] (set (quote shen-dot-*teststack*) (cons V1615 (value (quote shen-dot-*teststack*)))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-cond-expression [V1619 V1620 V1621] (clojure.core/let [Err (shen-dot-err-condition V1619)] (clojure.core/let [Cases (shen-dot-case-form V1621 Err)] (clojure.core/let [EncodeChoices (shen-dot-encode-choices Cases V1619)] (shen-dot-cond-form EncodeChoices))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? hd = tl cons) (clojure.core/defn shen-dot-cond-form [V1625] (clojure.core/cond (clojure.core/and (cons? V1625) (clojure.core/and (cons? (hd V1625)) (clojure.core/and (= true (hd (hd V1625))) (clojure.core/and (cons? (tl (hd V1625))) (= () (tl (tl (hd V1625)))))))) (hd (tl (hd V1625))) true (cons (quote cond) V1625) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-encode-choices [V1630 V1631] (clojure.core/cond (= () V1630) () (clojure.core/and (cons? V1630) (clojure.core/and (cons? (hd V1630)) (clojure.core/and (= true (hd (hd V1630))) (clojure.core/and (cons? (tl (hd V1630))) (clojure.core/and (cons? (hd (tl (hd V1630)))) (clojure.core/and (= (quote shen-dot-choicepoint!) (hd (hd (tl (hd V1630))))) (clojure.core/and (cons? (tl (hd (tl (hd V1630))))) (clojure.core/and (= () (tl (tl (hd (tl (hd V1630)))))) (clojure.core/and (= () (tl (tl (hd V1630)))) (= () (tl V1630))))))))))) (cons (cons true (cons (cons (quote let) (cons (quote Result) (cons (hd (tl (hd (tl (hd V1630))))) (cons (cons (quote if) (cons (cons (quote =) (cons (quote Result) (cons (cons (quote fail) ()) ()))) (cons (if (value (quote shen-dot-*installing-kl*)) (cons (quote shen-dot-sys-error) (cons V1631 ())) (cons (quote shen-dot-f_error) (cons V1631 ()))) (cons (quote Result) ())))) ())))) ())) ()) (clojure.core/and (cons? V1630) (clojure.core/and (cons? (hd V1630)) (clojure.core/and (= true (hd (hd V1630))) (clojure.core/and (cons? (tl (hd V1630))) (clojure.core/and (cons? (hd (tl (hd V1630)))) (clojure.core/and (= (quote shen-dot-choicepoint!) (hd (hd (tl (hd V1630))))) (clojure.core/and (cons? (tl (hd (tl (hd V1630))))) (clojure.core/and (= () (tl (tl (hd (tl (hd V1630)))))) (= () (tl (tl (hd V1630)))))))))))) (cons (cons true (cons (cons (quote let) (cons (quote Result) (cons (hd (tl (hd (tl (hd V1630))))) (cons (cons (quote if) (cons (cons (quote =) (cons (quote Result) (cons (cons (quote fail) ()) ()))) (cons (shen-dot-cond-form (shen-dot-encode-choices (tl V1630) V1631)) (cons (quote Result) ())))) ())))) ())) ()) (clojure.core/and (cons? V1630) (clojure.core/and (cons? (hd V1630)) (clojure.core/and (cons? (tl (hd V1630))) (clojure.core/and (cons? (hd (tl (hd V1630)))) (clojure.core/and (= (quote shen-dot-choicepoint!) (hd (hd (tl (hd V1630))))) (clojure.core/and (cons? (tl (hd (tl (hd V1630))))) (clojure.core/and (= () (tl (tl (hd (tl (hd V1630)))))) (= () (tl (tl (hd V1630))))))))))) (cons (cons true (cons (cons (quote let) (cons (quote Freeze) (cons (cons (quote freeze) (cons (shen-dot-cond-form (shen-dot-encode-choices (tl V1630) V1631)) ())) (cons (cons (quote if) (cons (hd (hd V1630)) (cons (cons (quote let) (cons (quote Result) (cons (hd (tl (hd (tl (hd V1630))))) (cons (cons (quote if) (cons (cons (quote =) (cons (quote Result) (cons (cons (quote fail) ()) ()))) (cons (cons (quote thaw) (cons (quote Freeze) ())) (cons (quote Result) ())))) ())))) (cons (cons (quote thaw) (cons (quote Freeze) ())) ())))) ())))) ())) ()) (clojure.core/and (cons? V1630) (clojure.core/and (cons? (hd V1630)) (clojure.core/and (cons? (tl (hd V1630))) (= () (tl (tl (hd V1630))))))) (cons (hd V1630) (shen-dot-encode-choices (tl V1630) V1631)) true (shen-dot-f_error (quote shen-dot-encode-choices)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-case-form [V1638 V1639] (clojure.core/cond (= () V1638) (cons V1639 ()) (clojure.core/and (cons? V1638) (clojure.core/and (cons? (hd V1638)) (clojure.core/and (cons? (hd (hd V1638))) (clojure.core/and (= (quote -colon-) (hd (hd (hd V1638)))) (clojure.core/and (cons? (tl (hd (hd V1638)))) (clojure.core/and (= (quote shen-dot-tests) (hd (tl (hd (hd V1638))))) (clojure.core/and (= () (tl (tl (hd (hd V1638))))) (clojure.core/and (cons? (tl (hd V1638))) (clojure.core/and (cons? (hd (tl (hd V1638)))) (clojure.core/and (= (quote shen-dot-choicepoint!) (hd (hd (tl (hd V1638))))) (clojure.core/and (cons? (tl (hd (tl (hd V1638))))) (clojure.core/and (= () (tl (tl (hd (tl (hd V1638)))))) (= () (tl (tl (hd V1638)))))))))))))))) (cons (cons true (tl (hd V1638))) (shen-dot-case-form (tl V1638) V1639)) (clojure.core/and (cons? V1638) (clojure.core/and (cons? (hd V1638)) (clojure.core/and (cons? (hd (hd V1638))) (clojure.core/and (= (quote -colon-) (hd (hd (hd V1638)))) (clojure.core/and (cons? (tl (hd (hd V1638)))) (clojure.core/and (= (quote shen-dot-tests) (hd (tl (hd (hd V1638))))) (clojure.core/and (= () (tl (tl (hd (hd V1638))))) (clojure.core/and (cons? (tl (hd V1638))) (= () (tl (tl (hd V1638)))))))))))) (cons (cons true (tl (hd V1638))) ()) (clojure.core/and (cons? V1638) (clojure.core/and (cons? (hd V1638)) (clojure.core/and (cons? (hd (hd V1638))) (clojure.core/and (= (quote -colon-) (hd (hd (hd V1638)))) (clojure.core/and (cons? (tl (hd (hd V1638)))) (clojure.core/and (= (quote shen-dot-tests) (hd (tl (hd (hd V1638))))) (clojure.core/and (cons? (tl (hd V1638))) (= () (tl (tl (hd V1638))))))))))) (cons (cons (shen-dot-embed-and (tl (tl (hd (hd V1638))))) (tl (hd V1638))) (shen-dot-case-form (tl V1638) V1639)) true (shen-dot-f_error (quote shen-dot-case-form)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? = tl hd cons shen-dot-embed-and shen-dot-f_error) (clojure.core/defn shen-dot-embed-and [V1641] (clojure.core/cond (clojure.core/and (cons? V1641) (= () (tl V1641))) (hd V1641) (cons? V1641) (cons (quote and) (cons (hd V1641) (cons (shen-dot-embed-and (tl V1641)) ()))) true (shen-dot-f_error (quote shen-dot-embed-and)) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons) (clojure.core/defn shen-dot-err-condition [V1643] (cons true (cons (cons (quote shen-dot-f_error) (cons V1643 ())) ())))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare simple-error cn shen-dot-app) (clojure.core/defn shen-dot-sys-error [V1645] (simple-error (cn "system function " (shen-dot-app V1645 ": unexpected argument\n" (quote shen-dot-a)))))))
(clojure.core/comment sys.kl)
(clojure.core/comment "Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.")
(shen-port.primitives/with-ns (quote shen.functions) (clojure.core/defn thaw [V2827] ((shen.primitives/resolve-fn V2827))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-eval-without-macros shen-dot-walk macroexpand shen-dot-packaged? map shen-dot-package-contents) (clojure.core/defn eval [V2829] (clojure.core/let [Macroexpand (shen-dot-walk (do (clojure.core/declare macroexpand) (clojure.core/fn [Y] (macroexpand Y))) V2829)] (if (shen-dot-packaged? Macroexpand) (map (do (clojure.core/declare shen-dot-eval-without-macros) (clojure.core/fn [Z] (shen-dot-eval-without-macros Z))) (shen-dot-package-contents Macroexpand)) (shen-dot-eval-without-macros Macroexpand))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare eval-kl shen-dot-elim-def shen-dot-proc-input+) (clojure.core/defn shen-dot-eval-without-macros [V2831] (eval-kl (shen-dot-elim-def (shen-dot-proc-input+ V2831))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-proc-input+ cons? = hd tl cons shen-dot-rcons_form map) (clojure.core/defn shen-dot-proc-input+ [V2833] (clojure.core/cond (clojure.core/and (cons? V2833) (clojure.core/and (= (quote input+) (hd V2833)) (clojure.core/and (cons? (tl V2833)) (clojure.core/and (cons? (tl (tl V2833))) (= () (tl (tl (tl V2833)))))))) (cons (quote input+) (cons (shen-dot-rcons_form (hd (tl V2833))) (tl (tl V2833)))) (clojure.core/and (cons? V2833) (clojure.core/and (= (quote shen-dot-read+) (hd V2833)) (clojure.core/and (cons? (tl V2833)) (clojure.core/and (cons? (tl (tl V2833))) (= () (tl (tl (tl V2833)))))))) (cons (quote shen-dot-read+) (cons (shen-dot-rcons_form (hd (tl V2833))) (tl (tl V2833)))) (cons? V2833) (map (do (clojure.core/declare shen-dot-proc-input+) (clojure.core/fn [Z] (shen-dot-proc-input+ Z))) V2833) true V2833 :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-elim-def cons? = hd tl shen-dot-shen->kl cons append shen-dot-add-macro shen-dot-yacc map) (clojure.core/defn shen-dot-elim-def [V2835] (clojure.core/cond (clojure.core/and (cons? V2835) (clojure.core/and (= (quote define) (hd V2835)) (cons? (tl V2835)))) (shen-dot-shen->kl (hd (tl V2835)) (tl (tl V2835))) (clojure.core/and (cons? V2835) (clojure.core/and (= (quote defmacro) (hd V2835)) (cons? (tl V2835)))) (clojure.core/let [Default (cons (quote X) (cons (quote ->) (cons (quote X) ())))] (clojure.core/let [Def (shen-dot-elim-def (cons (quote define) (cons (hd (tl V2835)) (append (tl (tl V2835)) Default))))] (clojure.core/let [MacroAdd (shen-dot-add-macro (hd (tl V2835)))] Def))) (clojure.core/and (cons? V2835) (clojure.core/and (= (quote defcc) (hd V2835)) (cons? (tl V2835)))) (shen-dot-elim-def (shen-dot-yacc V2835)) (cons? V2835) (map (do (clojure.core/declare shen-dot-elim-def) (clojure.core/fn [Z] (shen-dot-elim-def Z))) V2835) true V2835 :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare value set adjoin = cons function) (clojure.core/defn shen-dot-add-macro [V2837] (clojure.core/let [MacroReg (value (quote shen-dot-*macroreg*))] (clojure.core/let [NewMacroReg (set (quote shen-dot-*macroreg*) (adjoin V2837 (value (quote shen-dot-*macroreg*))))] (if (= MacroReg NewMacroReg) (quote shen-dot-skip) (set (quote *macros*) (cons (function V2837) (value (quote *macros*))))))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? = hd tl) (clojure.core/defn shen-dot-packaged? [V2845] (clojure.core/cond (clojure.core/and (cons? V2845) (clojure.core/and (= (quote package) (hd V2845)) (clojure.core/and (cons? (tl V2845)) (cons? (tl (tl V2845)))))) true true false :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare get value simple-error cn shen-dot-app) (clojure.core/defn external [V2847] (try (get V2847 (quote shen-dot-external-symbols) (value (quote *property-vector*))) (catch Exception e7491 ((do (clojure.core/declare simple-error cn shen-dot-app) (clojure.core/fn [E] (simple-error (cn "package " (shen-dot-app V2847 " has not been used.\n" (quote shen-dot-a)))))) e7491))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare get value simple-error cn shen-dot-app) (clojure.core/defn internal [V2849] (try (get V2849 (quote shen-dot-internal-symbols) (value (quote *property-vector*))) (catch Exception e7495 ((do (clojure.core/declare simple-error cn shen-dot-app) (clojure.core/fn [E] (simple-error (cn "package " (shen-dot-app V2849 " has not been used.\n" (quote shen-dot-a)))))) e7495))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? = hd tl intern cn str explode shen-dot-packageh shen-dot-f_error) (clojure.core/defn shen-dot-package-contents [V2853] (clojure.core/cond (clojure.core/and (cons? V2853) (clojure.core/and (= (quote package) (hd V2853)) (clojure.core/and (cons? (tl V2853)) (clojure.core/and (= (quote null) (hd (tl V2853))) (cons? (tl (tl V2853))))))) (tl (tl (tl V2853))) (clojure.core/and (cons? V2853) (clojure.core/and (= (quote package) (hd V2853)) (clojure.core/and (cons? (tl V2853)) (cons? (tl (tl V2853)))))) (clojure.core/let [PackageNameDot (intern (cn (str (hd (tl V2853))) "."))] (clojure.core/let [ExpPackageNameDot (explode PackageNameDot)] (shen-dot-packageh (hd (tl V2853)) (hd (tl (tl V2853))) (tl (tl (tl V2853))) ExpPackageNameDot))) true (shen-dot-f_error (quote shen-dot-package-contents)) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-walk [V2856 V2857] (clojure.core/cond (cons? V2857) ((shen.primitives/resolve-fn V2856) (map (do (clojure.core/declare shen-dot-walk) (clojure.core/fn [Z] (shen-dot-walk V2856 Z))) V2857)) true ((shen.primitives/resolve-fn V2856) V2857) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried compile [V2861 V2862 V2863] (clojure.core/let [O ((shen.primitives/resolve-fn V2861) (cons V2862 (cons () ())))] (if (clojure.core/or (= (fail) O) (not (empty? (hd O)))) ((shen.primitives/resolve-fn V2863) O) (shen-dot-hdtl O)))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried fail-if [V2866 V2867] (if ((shen.primitives/resolve-fn V2866) V2867) (fail) V2867)))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried -at-s [V2870 V2871] (cn V2870 V2871)))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare value) (clojure.core/defn tc? [] (value (quote shen-dot-*tc*)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare get value simple-error shen-dot-app) (clojure.core/defn ps [V2873] (try (get V2873 (quote shen-dot-source) (value (quote *property-vector*))) (catch Exception e7501 ((do (clojure.core/declare simple-error shen-dot-app) (clojure.core/fn [E] (simple-error (shen-dot-app V2873 " not found.\n" (quote shen-dot-a))))) e7501))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare value) (clojure.core/defn stinput [] (value (quote *stinput*)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare absvector + address-> = shen-dot-fillvector fail) (clojure.core/defn vector [V2875] (clojure.core/let [Vector (absvector (+ V2875 1))] (clojure.core/let [ZeroStamp (address-> Vector 0 V2875)] (clojure.core/let [Standard (if (= V2875 0) ZeroStamp (shen-dot-fillvector ZeroStamp 1 V2875 (fail)))] Standard))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare absvector? <-address number? >=) (clojure.core/defn vector? [V2886] (clojure.core/and (absvector? V2886) (clojure.core/let [X (try (<-address V2886 0) (catch Exception e7507 ((clojure.core/fn [E] -1) e7507)))] (clojure.core/and (number? X) (>= X 0)))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried vector-> [V2890 V2891 V2892] (if (= V2891 0) (simple-error "cannot access 0th element of a vector\n") (address-> V2890 V2891 V2892))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried <-vector [V2895 V2896] (if (= V2896 0) (simple-error "cannot access 0th element of a vector\n") (clojure.core/let [VectorElement (<-address V2895 V2896)] (if (= VectorElement (fail)) (simple-error "vector element not found\n") VectorElement)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare integer? >=) (clojure.core/defn shen-dot-posint? [V2898] (clojure.core/and (integer? V2898) (>= V2898 0)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare <-address) (clojure.core/defn limit [V2900] (<-address V2900 0))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare boolean? number? string? str shen-dot-analyse-symbol?) (clojure.core/defn symbol? [V2902] (clojure.core/cond (clojure.core/or (boolean? V2902) (clojure.core/or (number? V2902) (string? V2902))) false true (try (clojure.core/let [String (str V2902)] (shen-dot-analyse-symbol? String)) (catch Exception e7513 ((clojure.core/fn [E] false) e7513))) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare = shen-dot-+string? shen-dot-alpha? pos shen-dot-alphanums? tlstr shen-dot-f_error) (clojure.core/defn shen-dot-analyse-symbol? [V2904] (clojure.core/cond (= "" V2904) false (shen-dot-+string? V2904) (clojure.core/and (shen-dot-alpha? (pos V2904 0)) (shen-dot-alphanums? (tlstr V2904))) true (shen-dot-f_error (quote shen-dot-analyse-symbol?)) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare element? cons) (clojure.core/defn shen-dot-alpha? [V2906] (element? V2906 (cons "A" (cons "B" (cons "C" (cons "D" (cons "E" (cons "F" (cons "G" (cons "H" (cons "I" (cons "J" (cons "K" (cons "L" (cons "M" (cons "N" (cons "O" (cons "P" (cons "Q" (cons "R" (cons "S" (cons "T" (cons "U" (cons "V" (cons "W" (cons "X" (cons "Y" (cons "Z" (cons "a" (cons "b" (cons "c" (cons "d" (cons "e" (cons "f" (cons "g" (cons "h" (cons "i" (cons "j" (cons "k" (cons "l" (cons "m" (cons "n" (cons "o" (cons "p" (cons "q" (cons "r" (cons "s" (cons "t" (cons "u" (cons "v" (cons "w" (cons "x" (cons "y" (cons "z" (cons "=" (cons "*" (cons "/" (cons "+" (cons "-" (cons "_" (cons "?" (cons "$" (cons "!" (cons "@" (cons "~" (cons ">" (cons "<" (cons "&" (cons "%" (cons "{" (cons "}" (cons ":" (cons ";" (cons "`" (cons "#" (cons "'" (cons "." ())))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare = shen-dot-+string? shen-dot-alphanum? pos shen-dot-alphanums? tlstr shen-dot-f_error) (clojure.core/defn shen-dot-alphanums? [V2908] (clojure.core/cond (= "" V2908) true (shen-dot-+string? V2908) (clojure.core/and (shen-dot-alphanum? (pos V2908 0)) (shen-dot-alphanums? (tlstr V2908))) true (shen-dot-f_error (quote shen-dot-alphanums?)) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-alpha? shen-dot-digit?) (clojure.core/defn shen-dot-alphanum? [V2910] (clojure.core/or (shen-dot-alpha? V2910) (shen-dot-digit? V2910)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare element? cons) (clojure.core/defn shen-dot-digit? [V2912] (element? V2912 (cons "1" (cons "2" (cons "3" (cons "4" (cons "5" (cons "6" (cons "7" (cons "8" (cons "9" (cons "0" ()))))))))))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare boolean? number? string? str shen-dot-analyse-variable?) (clojure.core/defn variable? [V2914] (clojure.core/cond (clojure.core/or (boolean? V2914) (clojure.core/or (number? V2914) (string? V2914))) false true (try (clojure.core/let [String (str V2914)] (shen-dot-analyse-variable? String)) (catch Exception e7523 ((clojure.core/fn [E] false) e7523))) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-+string? shen-dot-uppercase? pos shen-dot-alphanums? tlstr shen-dot-f_error) (clojure.core/defn shen-dot-analyse-variable? [V2916] (clojure.core/cond (shen-dot-+string? V2916) (clojure.core/and (shen-dot-uppercase? (pos V2916 0)) (shen-dot-alphanums? (tlstr V2916))) true (shen-dot-f_error (quote shen-dot-analyse-variable?)) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare element? cons) (clojure.core/defn shen-dot-uppercase? [V2918] (element? V2918 (cons "A" (cons "B" (cons "C" (cons "D" (cons "E" (cons "F" (cons "G" (cons "H" (cons "I" (cons "J" (cons "K" (cons "L" (cons "M" (cons "N" (cons "O" (cons "P" (cons "Q" (cons "R" (cons "S" (cons "T" (cons "U" (cons "V" (cons "W" (cons "X" (cons "Y" (cons "Z" ()))))))))))))))))))))))))))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare concat set + value) (clojure.core/defn gensym [V2920] (concat V2920 (set (quote shen-dot-*gensym*) (+ 1 (value (quote shen-dot-*gensym*))))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried concat [V2923 V2924] (intern (cn (str V2923) (str V2924)))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried -at-p [V2927 V2928] (clojure.core/let [Vector (absvector 3)] (clojure.core/let [Tag (address-> Vector 0 (quote shen-dot-tuple))] (clojure.core/let [Fst (address-> Vector 1 V2927)] (clojure.core/let [Snd (address-> Vector 2 V2928)] Vector))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare <-address) (clojure.core/defn fst [V2930] (<-address V2930 1))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare <-address) (clojure.core/defn snd [V2932] (<-address V2932 2))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare absvector? = <-address) (clojure.core/defn tuple? [V2934] (clojure.core/and (absvector? V2934) (= (quote shen-dot-tuple) (try (<-address V2934 0) (catch Exception e7533 ((clojure.core/fn [E] (quote shen-dot-not-tuple)) e7533))))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried append [V2937 V2938] (clojure.core/cond (= () V2937) V2938 (cons? V2937) (cons (hd V2937) (append (tl V2937) V2938)) true (shen-dot-f_error (quote append)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried -at-v [V2941 V2942] (clojure.core/let [Limit (limit V2942)] (clojure.core/let [NewVector (vector (+ Limit 1))] (clojure.core/let [X+NewVector (vector-> NewVector 1 V2941)] (if (= Limit 0) X+NewVector (shen-dot--at-v-help V2942 1 Limit X+NewVector)))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot--at-v-help [V2948 V2949 V2950 V2951] (clojure.core/cond (= V2950 V2949) (shen-dot-copyfromvector V2948 V2951 V2950 (+ V2950 1)) true (shen-dot--at-v-help V2948 (+ V2949 1) V2950 (shen-dot-copyfromvector V2948 V2951 V2949 (+ V2949 1))) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-copyfromvector [V2956 V2957 V2958 V2959] (try (vector-> V2957 V2959 (<-vector V2956 V2958)) (catch Exception e7536 ((clojure.core/fn [E] V2957) e7536)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare <-vector simple-error cn shen-dot-app) (clojure.core/defn hdv [V2961] (try (<-vector V2961 1) (catch Exception e7538 ((do (clojure.core/declare simple-error cn shen-dot-app) (clojure.core/fn [E] (simple-error (cn "hdv needs a non-empty vector as an argument; not " (shen-dot-app V2961 "\n" (quote shen-dot-s)))))) e7538))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare limit = simple-error vector - shen-dot-tlv-help) (clojure.core/defn tlv [V2963] (clojure.core/let [Limit (limit V2963)] (if (= Limit 0) (simple-error "cannot take the tail of the empty vector\n") (if (= Limit 1) (vector 0) (clojure.core/let [NewVector (vector (- Limit 1))] (shen-dot-tlv-help V2963 2 Limit (vector (- Limit 1))))))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-tlv-help [V2969 V2970 V2971 V2972] (clojure.core/cond (= V2971 V2970) (shen-dot-copyfromvector V2969 V2972 V2971 (- V2971 1)) true (shen-dot-tlv-help V2969 (+ V2970 1) V2971 (shen-dot-copyfromvector V2969 V2972 V2970 (- V2970 1))) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried assoc [V2984 V2985] (clojure.core/cond (= () V2985) () (clojure.core/and (cons? V2985) (clojure.core/and (cons? (hd V2985)) (= (hd (hd V2985)) V2984))) (hd V2985) (cons? V2985) (assoc V2984 (tl V2985)) true (shen-dot-f_error (quote assoc)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-assoc-set [V2992 V2993 V2994] (clojure.core/cond (= () V2994) (cons (cons V2992 V2993) ()) (clojure.core/and (cons? V2994) (clojure.core/and (cons? (hd V2994)) (= (hd (hd V2994)) V2992))) (cons (cons (hd (hd V2994)) V2993) (tl V2994)) (cons? V2994) (cons (hd V2994) (shen-dot-assoc-set V2992 V2993 (tl V2994))) true (shen-dot-f_error (quote shen-dot-assoc-set)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-assoc-rm [V3000 V3001] (clojure.core/cond (= () V3001) () (clojure.core/and (cons? V3001) (clojure.core/and (cons? (hd V3001)) (= (hd (hd V3001)) V3000))) (tl V3001) (cons? V3001) (cons (hd V3001) (shen-dot-assoc-rm V3000 (tl V3001))) true (shen-dot-f_error (quote shen-dot-assoc-rm)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare =) (clojure.core/defn boolean? [V3007] (clojure.core/cond (= true V3007) true (= false V3007) true true false :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare = shen-dot-prhush stoutput nl -) (clojure.core/defn nl [V3009] (clojure.core/cond (= 0 V3009) 0 true (do (shen-dot-prhush "\n" (stoutput)) (nl (- V3009 1))) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried difference [V3014 V3015] (clojure.core/cond (= () V3014) () (cons? V3014) (if (element? (hd V3014) V3015) (difference (tl V3014) V3015) (cons (hd V3014) (difference (tl V3014) V3015))) true (shen-dot-f_error (quote difference)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried do [V3018 V3019] V3019))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried element? [V3031 V3032] (clojure.core/cond (= () V3032) false (clojure.core/and (cons? V3032) (= (hd V3032) V3031)) true (cons? V3032) (element? V3031 (tl V3032)) true (shen-dot-f_error (quote element?)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare =) (clojure.core/defn empty? [V3038] (clojure.core/cond (= () V3038) true true false :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried fix [V3041 V3042] (shen-dot-fix-help V3041 V3042 ((shen.primitives/resolve-fn V3041) V3042))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-fix-help [V3053 V3054 V3055] (clojure.core/cond (= V3055 V3054) V3055 true (shen-dot-fix-help V3053 V3055 ((shen.primitives/resolve-fn V3053) V3055)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried put [V3060 V3061 V3062 V3063] (clojure.core/let [Curr (try (shen-dot-<-dict V3063 V3060) (catch Exception e7546 ((clojure.core/fn [E] ()) e7546)))] (clojure.core/let [Added (shen-dot-assoc-set V3061 V3062 Curr)] (clojure.core/let [Update (shen-dot-dict-> V3063 V3060 Added)] V3062)))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried unput [V3067 V3068 V3069] (clojure.core/let [Curr (try (shen-dot-<-dict V3069 V3067) (catch Exception e7548 ((clojure.core/fn [E] ()) e7548)))] (clojure.core/let [Removed (shen-dot-assoc-rm V3068 Curr)] (clojure.core/let [Update (shen-dot-dict-> V3069 V3067 Removed)] V3067)))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried get [V3073 V3074 V3075] (clojure.core/let [Entry (try (shen-dot-<-dict V3075 V3073) (catch Exception e7550 ((clojure.core/fn [E] ()) e7550)))] (clojure.core/let [Result (assoc V3074 Entry)] (if (empty? Result) (simple-error "value not found\n") (tl Result))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried hash [V3078 V3079] (shen-dot-mod (sum (map (do (clojure.core/declare string->n) (clojure.core/fn [X] (string->n X))) (explode V3078))) V3079)))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-mod [V3082 V3083] (shen-dot-modh V3082 (shen-dot-multiples V3082 (cons V3083 ())))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-multiples [V3086 V3087] (clojure.core/cond (clojure.core/and (cons? V3087) (> (hd V3087) V3086)) (tl V3087) (cons? V3087) (shen-dot-multiples V3086 (cons (* 2 (hd V3087)) V3087)) true (shen-dot-f_error (quote shen-dot-multiples)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-modh [V3092 V3093] (clojure.core/cond (= 0 V3092) 0 (= () V3093) V3092 (clojure.core/and (cons? V3093) (> (hd V3093) V3092)) (if (empty? (tl V3093)) V3092 (shen-dot-modh V3092 (tl V3093))) (cons? V3093) (shen-dot-modh (- V3092 (hd V3093)) V3093) true (shen-dot-f_error (quote shen-dot-modh)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare = cons? + hd sum tl shen-dot-f_error) (clojure.core/defn sum [V3095] (clojure.core/cond (= () V3095) 0 (cons? V3095) (+ (hd V3095) (sum (tl V3095))) true (shen-dot-f_error (quote sum)) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? hd simple-error) (clojure.core/defn head [V3103] (clojure.core/cond (cons? V3103) (hd V3103) true (simple-error "head expects a non-empty list") :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? tl simple-error) (clojure.core/defn tail [V3111] (clojure.core/cond (cons? V3111) (tl V3111) true (simple-error "tail expects a non-empty list") :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare pos) (clojure.core/defn hdstr [V3113] (pos V3113 0))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried intersection [V3118 V3119] (clojure.core/cond (= () V3118) () (cons? V3118) (if (element? (hd V3118) V3119) (cons (hd V3118) (intersection (tl V3118) V3119)) (intersection (tl V3118) V3119)) true (shen-dot-f_error (quote intersection)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-reverse_help) (clojure.core/defn reverse [V3121] (shen-dot-reverse_help V3121 ()))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-reverse_help [V3124 V3125] (clojure.core/cond (= () V3124) V3125 (cons? V3124) (shen-dot-reverse_help (tl V3124) (cons (hd V3124) V3125)) true (shen-dot-f_error (quote shen-dot-reverse_help)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried union [V3128 V3129] (clojure.core/cond (= () V3128) V3129 (cons? V3128) (if (element? (hd V3128) V3129) (union (tl V3128) V3129) (cons (hd V3128) (union (tl V3128) V3129))) true (shen-dot-f_error (quote union)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-prhush shen-dot-proc-nl stoutput shen-dot-app read stinput = y-or-n?) (clojure.core/defn y-or-n? [V3131] (clojure.core/let [Message (shen-dot-prhush (shen-dot-proc-nl V3131) (stoutput))] (clojure.core/let [Y-or-N (shen-dot-prhush " (y/n) " (stoutput))] (clojure.core/let [Input (shen-dot-app (read (stinput)) "" (quote shen-dot-s))] (if (= "y" Input) true (if (= "n" Input) false (do (shen-dot-prhush "please answer y or n\n" (stoutput)) (y-or-n? V3131))))))))))
(shen-port.primitives/with-ns (quote shen.functions) (clojure.core/defn not [V3133] (if V3133 false true)))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried subst [V3146 V3147 V3148] (clojure.core/cond (= V3148 V3147) V3146 (cons? V3148) (map (do (clojure.core/declare subst) (clojure.core/fn [W] (subst V3146 V3147 W))) V3148) true V3148 :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-explode-h shen-dot-app) (clojure.core/defn explode [V3150] (shen-dot-explode-h (shen-dot-app V3150 "" (quote shen-dot-a))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare = shen-dot-+string? cons pos shen-dot-explode-h tlstr shen-dot-f_error) (clojure.core/defn shen-dot-explode-h [V3152] (clojure.core/cond (= "" V3152) () (shen-dot-+string? V3152) (cons (pos V3152 0) (shen-dot-explode-h (tlstr V3152))) true (shen-dot-f_error (quote shen-dot-explode-h)) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare set = shen-dot-app) (clojure.core/defn cd [V3154] (set (quote *home-directory*) (if (= V3154 "") "" (shen-dot-app V3154 "/" (quote shen-dot-a)))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-for-each [V3157 V3158] (clojure.core/cond (= () V3158) true (cons? V3158) (clojure.core/let [_ ((shen.primitives/resolve-fn V3157) (hd V3158))] (shen-dot-for-each V3157 (tl V3158))) true (shen-dot-f_error (quote shen-dot-for-each)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried map [V3161 V3162] (shen-dot-map-h V3161 V3162 ())))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-map-h [V3168 V3169 V3170] (clojure.core/cond (= () V3169) (reverse V3170) (cons? V3169) (shen-dot-map-h V3168 (tl V3169) (cons ((shen.primitives/resolve-fn V3168) (hd V3169)) V3170)) true (shen-dot-f_error (quote shen-dot-map-h)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-length-h) (clojure.core/defn length [V3172] (shen-dot-length-h V3172 0))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-length-h [V3175 V3176] (clojure.core/cond (= () V3175) V3176 true (shen-dot-length-h (tl V3175) (+ V3176 1)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried occurrences [V3188 V3189] (clojure.core/cond (= V3189 V3188) 1 (cons? V3189) (+ (occurrences V3188 (hd V3189)) (occurrences V3188 (tl V3189))) true 0 :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried nth [V3196 V3197] (clojure.core/cond (clojure.core/and (= 1 V3196) (cons? V3197)) (hd V3197) (cons? V3197) (nth (- V3196 1) (tl V3197)) true (simple-error (cn "nth applied to " (shen-dot-app V3196 (cn ", " (shen-dot-app V3197 "\n" (quote shen-dot-a))) (quote shen-dot-a)))) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare number? shen-dot-abs shen-dot-integer-test? shen-dot-magless) (clojure.core/defn integer? [V3199] (clojure.core/and (number? V3199) (clojure.core/let [Abs (shen-dot-abs V3199)] (shen-dot-integer-test? Abs (shen-dot-magless Abs 1)))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare > -) (clojure.core/defn shen-dot-abs [V3201] (if (> V3201 0) V3201 (- 0 V3201)))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-magless [V3204 V3205] (clojure.core/let [Nx2 (* V3205 2)] (if (> Nx2 V3204) V3205 (shen-dot-magless V3204 Nx2)))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-integer-test? [V3211 V3212] (clojure.core/cond (= 0 V3211) true (> 1 V3211) false true (clojure.core/let [Abs-N (- V3211 V3212)] (if (> 0 Abs-N) (integer? V3211) (shen-dot-integer-test? Abs-N V3212))) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried mapcan [V3217 V3218] (clojure.core/cond (= () V3218) () (cons? V3218) (append ((shen.primitives/resolve-fn V3217) (hd V3218)) (mapcan V3217 (tl V3218))) true (shen-dot-f_error (quote mapcan)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried == [V3230 V3231] (clojure.core/cond (= V3231 V3230) true true false :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare simple-error) (clojure.core/defn abort [] (simple-error ""))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare symbol? value =) (clojure.core/defn bound? [V3233] (clojure.core/and (symbol? V3233) (clojure.core/let [Val (try (value V3233) (catch Exception e7567 ((clojure.core/fn [E] (quote shen-dot-this-symbol-is-unbound)) e7567)))] (if (= Val (quote shen-dot-this-symbol-is-unbound)) false true))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare = cons string->n pos shen-dot-string->bytes tlstr) (clojure.core/defn shen-dot-string->bytes [V3235] (clojure.core/cond (= "" V3235) () true (cons (string->n (pos V3235 0)) (shen-dot-string->bytes (tlstr V3235))) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare set) (clojure.core/defn maxinferences [V3237] (set (quote shen-dot-*maxinferences*) V3237))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare value) (clojure.core/defn inferences [] (value (quote shen-dot-*infs*)))))
(shen-port.primitives/with-ns (quote shen.functions) (clojure.core/defn protect [V3239] V3239))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare value) (clojure.core/defn stoutput [] (value (quote *stoutput*)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare value) (clojure.core/defn sterror [] (value (quote *sterror*)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare intern symbol? simple-error cn shen-dot-app) (clojure.core/defn string->symbol [V3241] (clojure.core/let [Symbol (intern V3241)] (if (symbol? Symbol) Symbol (simple-error (cn "cannot intern " (shen-dot-app V3241 " to a symbol" (quote shen-dot-s)))))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare = set simple-error) (clojure.core/defn optimise [V3247] (clojure.core/cond (= (quote +) V3247) (set (quote shen-dot-*optimise*) true) (= (quote -) V3247) (set (quote shen-dot-*optimise*) false) true (simple-error "optimise expects a + or a -.\n") :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare value) (clojure.core/defn os [] (value (quote *os*)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare value) (clojure.core/defn language [] (value (quote *language*)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare value) (clojure.core/defn version [] (value (quote *version*)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare value) (clojure.core/defn port [] (value (quote *port*)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare value) (clojure.core/defn porters [] (value (quote *porters*)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare value) (clojure.core/defn implementation [] (value (quote *implementation*)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare value) (clojure.core/defn release [] (value (quote *release*)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare external) (clojure.core/defn package? [V3249] (try (do (external V3249) true) (catch Exception e7587 ((clojure.core/fn [E] false) e7587))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-lookup-func) (clojure.core/defn function [V3251] (shen-dot-lookup-func V3251))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare get value simple-error shen-dot-app) (clojure.core/defn shen-dot-lookup-func [V3253] (try (get V3253 (quote shen-dot-lambda-form) (value (quote *property-vector*))) (catch Exception e7592 ((do (clojure.core/declare simple-error shen-dot-app) (clojure.core/fn [E] (simple-error (shen-dot-app V3253 " has no lambda expansion\n" (quote shen-dot-a))))) e7592))))))
(clojure.core/comment dict.kl)
(clojure.core/comment "Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.")
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare < simple-error cn shen-dot-app absvector + address-> shen-dot-fillvector) (clojure.core/defn shen-dot-dict [V3255] (clojure.core/cond (< V3255 1) (simple-error (cn "invalid initial dict size: " (shen-dot-app V3255 "" (quote shen-dot-s)))) true (clojure.core/let [D (absvector (+ 3 V3255))] (clojure.core/let [Tag (address-> D 0 (quote shen-dot-dictionary))] (clojure.core/let [Capacity (address-> D 1 V3255)] (clojure.core/let [Count (address-> D 2 0)] (clojure.core/let [Fill (shen-dot-fillvector D 3 (+ 2 V3255) ())] D))))) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare absvector? = <-address) (clojure.core/defn shen-dot-dict? [V3257] (clojure.core/and (absvector? V3257) (= (try (<-address V3257 0) (catch Exception e7598 ((clojure.core/fn [E] (quote shen-dot-not-dictionary)) e7598))) (quote shen-dot-dictionary))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare <-address) (clojure.core/defn shen-dot-dict-capacity [V3259] (<-address V3259 1))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare <-address) (clojure.core/defn shen-dot-dict-count [V3261] (<-address V3261 2))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-dict-count-> [V3264 V3265] (address-> V3264 2 V3265)))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-<-dict-bucket [V3268 V3269] (<-address V3268 (+ 3 V3269))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-dict-bucket-> [V3273 V3274 V3275] (address-> V3273 (+ 3 V3274) V3275)))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-dict-update-count [V3279 V3280 V3281] (clojure.core/let [Diff (- (length V3281) (length V3280))] (shen-dot-dict-count-> V3279 (+ Diff (shen-dot-dict-count V3279))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-dict-> [V3285 V3286 V3287] (clojure.core/let [N (hash V3286 (shen-dot-dict-capacity V3285))] (clojure.core/let [Bucket (shen-dot-<-dict-bucket V3285 N)] (clojure.core/let [NewBucket (shen-dot-assoc-set V3286 V3287 Bucket)] (clojure.core/let [Change (shen-dot-dict-bucket-> V3285 N NewBucket)] (clojure.core/let [Count (shen-dot-dict-update-count V3285 Bucket NewBucket)] V3287)))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-<-dict [V3290 V3291] (clojure.core/let [N (hash V3291 (shen-dot-dict-capacity V3290))] (clojure.core/let [Bucket (shen-dot-<-dict-bucket V3290 N)] (clojure.core/let [Result (assoc V3291 Bucket)] (if (empty? Result) (simple-error (cn "value " (shen-dot-app V3291 " not found in dict\n" (quote shen-dot-a)))) (tl Result)))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-dict-rm [V3294 V3295] (clojure.core/let [N (hash V3295 (shen-dot-dict-capacity V3294))] (clojure.core/let [Bucket (shen-dot-<-dict-bucket V3294 N)] (clojure.core/let [NewBucket (shen-dot-assoc-rm V3295 Bucket)] (clojure.core/let [Change (shen-dot-dict-bucket-> V3294 N NewBucket)] (clojure.core/let [Count (shen-dot-dict-update-count V3294 Bucket NewBucket)] V3295)))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-dict-fold [V3299 V3300 V3301] (clojure.core/let [Limit (shen-dot-dict-capacity V3300)] (shen-dot-dict-fold-h V3299 V3300 V3301 0 Limit))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-dict-fold-h [V3308 V3309 V3310 V3311 V3312] (clojure.core/cond (= V3312 V3311) V3310 true (clojure.core/let [B (shen-dot-<-dict-bucket V3309 V3311)] (clojure.core/let [Acc (shen-dot-bucket-fold V3308 B V3310)] (shen-dot-dict-fold-h V3308 V3309 Acc (+ 1 V3311) V3312))) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-bucket-fold [V3316 V3317 V3318] (clojure.core/cond (= () V3317) V3318 (clojure.core/and (cons? V3317) (cons? (hd V3317))) ((shen.primitives/resolve-fn V3316) (hd (hd V3317)) (tl (hd V3317)) (shen-dot-bucket-fold V3316 (tl V3317) V3318)) true (shen-dot-f_error (quote shen-dot-bucket-fold)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons shen-dot-dict-fold) (clojure.core/defn shen-dot-dict-keys [V3320] (shen-dot-dict-fold (do (clojure.core/declare cons) (clojure.core/fn [K] (do (clojure.core/declare cons) (clojure.core/fn [_] (do (clojure.core/declare cons) (clojure.core/fn [Acc] (cons K Acc))))))) V3320 ()))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons shen-dot-dict-fold) (clojure.core/defn shen-dot-dict-values [V3322] (shen-dot-dict-fold (do (clojure.core/declare cons) (clojure.core/fn [_] (do (clojure.core/declare cons) (clojure.core/fn [V] (do (clojure.core/declare cons) (clojure.core/fn [Acc] (cons V Acc))))))) V3322 ()))))
(clojure.core/comment sequent.kl)
(clojure.core/comment "Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.")
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? tl = simple-error cn shen-dot-app shen-dot-next-50 hd shen-dot-f_error) (clojure.core/defn shen-dot-datatype-error [V2635] (clojure.core/cond (clojure.core/and (cons? V2635) (clojure.core/and (cons? (tl V2635)) (= () (tl (tl V2635))))) (simple-error (cn "datatype syntax error here:\n\n " (shen-dot-app (shen-dot-next-50 50 (hd V2635)) "\n" (quote shen-dot-a)))) true (shen-dot-f_error (quote shen-dot-datatype-error)) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-<datatype-rule> not = fail shen-dot-<datatype-rules> shen-dot-pair hd cons shen-dot-hdtl <e>) (clojure.core/defn shen-dot-<datatype-rules> [V2637] (clojure.core/let [YaccParse (clojure.core/let [Parse_shen-dot-<datatype-rule> (shen-dot-<datatype-rule> V2637)] (if (not (= (fail) Parse_shen-dot-<datatype-rule>)) (clojure.core/let [Parse_shen-dot-<datatype-rules> (shen-dot-<datatype-rules> Parse_shen-dot-<datatype-rule>)] (if (not (= (fail) Parse_shen-dot-<datatype-rules>)) (shen-dot-pair (hd Parse_shen-dot-<datatype-rules>) (cons (shen-dot-hdtl Parse_shen-dot-<datatype-rule>) (shen-dot-hdtl Parse_shen-dot-<datatype-rules>))) (fail))) (fail)))] (if (= YaccParse (fail)) (clojure.core/let [Parse_<e> (<e> V2637)] (if (not (= (fail) Parse_<e>)) (shen-dot-pair (hd Parse_<e>) ()) (fail))) YaccParse)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-<side-conditions> not = fail shen-dot-<premises> shen-dot-<singleunderline> shen-dot-<conclusion> shen-dot-pair hd shen-dot-sequent cons shen-dot-hdtl shen-dot-<doubleunderline>) (clojure.core/defn shen-dot-<datatype-rule> [V2639] (clojure.core/let [YaccParse (clojure.core/let [Parse_shen-dot-<side-conditions> (shen-dot-<side-conditions> V2639)] (if (not (= (fail) Parse_shen-dot-<side-conditions>)) (clojure.core/let [Parse_shen-dot-<premises> (shen-dot-<premises> Parse_shen-dot-<side-conditions>)] (if (not (= (fail) Parse_shen-dot-<premises>)) (clojure.core/let [Parse_shen-dot-<singleunderline> (shen-dot-<singleunderline> Parse_shen-dot-<premises>)] (if (not (= (fail) Parse_shen-dot-<singleunderline>)) (clojure.core/let [Parse_shen-dot-<conclusion> (shen-dot-<conclusion> Parse_shen-dot-<singleunderline>)] (if (not (= (fail) Parse_shen-dot-<conclusion>)) (shen-dot-pair (hd Parse_shen-dot-<conclusion>) (shen-dot-sequent (quote shen-dot-single) (cons (shen-dot-hdtl Parse_shen-dot-<side-conditions>) (cons (shen-dot-hdtl Parse_shen-dot-<premises>) (cons (shen-dot-hdtl Parse_shen-dot-<conclusion>) ()))))) (fail))) (fail))) (fail))) (fail)))] (if (= YaccParse (fail)) (clojure.core/let [Parse_shen-dot-<side-conditions> (shen-dot-<side-conditions> V2639)] (if (not (= (fail) Parse_shen-dot-<side-conditions>)) (clojure.core/let [Parse_shen-dot-<premises> (shen-dot-<premises> Parse_shen-dot-<side-conditions>)] (if (not (= (fail) Parse_shen-dot-<premises>)) (clojure.core/let [Parse_shen-dot-<doubleunderline> (shen-dot-<doubleunderline> Parse_shen-dot-<premises>)] (if (not (= (fail) Parse_shen-dot-<doubleunderline>)) (clojure.core/let [Parse_shen-dot-<conclusion> (shen-dot-<conclusion> Parse_shen-dot-<doubleunderline>)] (if (not (= (fail) Parse_shen-dot-<conclusion>)) (shen-dot-pair (hd Parse_shen-dot-<conclusion>) (shen-dot-sequent (quote shen-dot-double) (cons (shen-dot-hdtl Parse_shen-dot-<side-conditions>) (cons (shen-dot-hdtl Parse_shen-dot-<premises>) (cons (shen-dot-hdtl Parse_shen-dot-<conclusion>) ()))))) (fail))) (fail))) (fail))) (fail))) YaccParse)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-<side-condition> not = fail shen-dot-<side-conditions> shen-dot-pair hd cons shen-dot-hdtl <e>) (clojure.core/defn shen-dot-<side-conditions> [V2641] (clojure.core/let [YaccParse (clojure.core/let [Parse_shen-dot-<side-condition> (shen-dot-<side-condition> V2641)] (if (not (= (fail) Parse_shen-dot-<side-condition>)) (clojure.core/let [Parse_shen-dot-<side-conditions> (shen-dot-<side-conditions> Parse_shen-dot-<side-condition>)] (if (not (= (fail) Parse_shen-dot-<side-conditions>)) (shen-dot-pair (hd Parse_shen-dot-<side-conditions>) (cons (shen-dot-hdtl Parse_shen-dot-<side-condition>) (shen-dot-hdtl Parse_shen-dot-<side-conditions>))) (fail))) (fail)))] (if (= YaccParse (fail)) (clojure.core/let [Parse_<e> (<e> V2641)] (if (not (= (fail) Parse_<e>)) (shen-dot-pair (hd Parse_<e>) ()) (fail))) YaccParse)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? hd = shen-dot-<expr> shen-dot-pair tl shen-dot-hdtl not fail cons shen-dot-<variable?>) (clojure.core/defn shen-dot-<side-condition> [V2643] (clojure.core/let [YaccParse (if (clojure.core/and (cons? (hd V2643)) (= (quote if) (hd (hd V2643)))) (clojure.core/let [Parse_shen-dot-<expr> (shen-dot-<expr> (shen-dot-pair (tl (hd V2643)) (shen-dot-hdtl V2643)))] (if (not (= (fail) Parse_shen-dot-<expr>)) (shen-dot-pair (hd Parse_shen-dot-<expr>) (cons (quote if) (cons (shen-dot-hdtl Parse_shen-dot-<expr>) ()))) (fail))) (fail))] (if (= YaccParse (fail)) (if (clojure.core/and (cons? (hd V2643)) (= (quote let) (hd (hd V2643)))) (clojure.core/let [Parse_shen-dot-<variable?> (shen-dot-<variable?> (shen-dot-pair (tl (hd V2643)) (shen-dot-hdtl V2643)))] (if (not (= (fail) Parse_shen-dot-<variable?>)) (clojure.core/let [Parse_shen-dot-<expr> (shen-dot-<expr> Parse_shen-dot-<variable?>)] (if (not (= (fail) Parse_shen-dot-<expr>)) (shen-dot-pair (hd Parse_shen-dot-<expr>) (cons (quote let) (cons (shen-dot-hdtl Parse_shen-dot-<variable?>) (cons (shen-dot-hdtl Parse_shen-dot-<expr>) ())))) (fail))) (fail))) (fail)) YaccParse)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? hd variable? shen-dot-pair tl shen-dot-hdtl fail) (clojure.core/defn shen-dot-<variable?> [V2645] (if (cons? (hd V2645)) (clojure.core/let [Parse_X (hd (hd V2645))] (if (variable? Parse_X) (shen-dot-pair (hd (shen-dot-pair (tl (hd V2645)) (shen-dot-hdtl V2645))) Parse_X) (fail))) (fail)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? hd not element? cons shen-dot-singleunderline? shen-dot-doubleunderline? shen-dot-pair tl shen-dot-hdtl shen-dot-remove-bar fail) (clojure.core/defn shen-dot-<expr> [V2647] (if (cons? (hd V2647)) (clojure.core/let [Parse_X (hd (hd V2647))] (if (not (clojure.core/or (element? Parse_X (cons (quote >>) (cons (quote -semicol-) ()))) (clojure.core/or (shen-dot-singleunderline? Parse_X) (shen-dot-doubleunderline? Parse_X)))) (shen-dot-pair (hd (shen-dot-pair (tl (hd V2647)) (shen-dot-hdtl V2647))) (shen-dot-remove-bar Parse_X)) (fail))) (fail)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? tl = hd cons shen-dot-remove-bar) (clojure.core/defn shen-dot-remove-bar [V2649] (clojure.core/cond (clojure.core/and (cons? V2649) (clojure.core/and (cons? (tl V2649)) (clojure.core/and (cons? (tl (tl V2649))) (clojure.core/and (= () (tl (tl (tl V2649)))) (= (hd (tl V2649)) (quote bar!)))))) (cons (hd V2649) (hd (tl (tl V2649)))) (cons? V2649) (cons (shen-dot-remove-bar (hd V2649)) (shen-dot-remove-bar (tl V2649))) true V2649 :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-<premise> not = fail shen-dot-<semicolon-symbol> shen-dot-<premises> shen-dot-pair hd cons shen-dot-hdtl <e>) (clojure.core/defn shen-dot-<premises> [V2651] (clojure.core/let [YaccParse (clojure.core/let [Parse_shen-dot-<premise> (shen-dot-<premise> V2651)] (if (not (= (fail) Parse_shen-dot-<premise>)) (clojure.core/let [Parse_shen-dot-<semicolon-symbol> (shen-dot-<semicolon-symbol> Parse_shen-dot-<premise>)] (if (not (= (fail) Parse_shen-dot-<semicolon-symbol>)) (clojure.core/let [Parse_shen-dot-<premises> (shen-dot-<premises> Parse_shen-dot-<semicolon-symbol>)] (if (not (= (fail) Parse_shen-dot-<premises>)) (shen-dot-pair (hd Parse_shen-dot-<premises>) (cons (shen-dot-hdtl Parse_shen-dot-<premise>) (shen-dot-hdtl Parse_shen-dot-<premises>))) (fail))) (fail))) (fail)))] (if (= YaccParse (fail)) (clojure.core/let [Parse_<e> (<e> V2651)] (if (not (= (fail) Parse_<e>)) (shen-dot-pair (hd Parse_<e>) ()) (fail))) YaccParse)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? hd = shen-dot-pair tl shen-dot-hdtl fail) (clojure.core/defn shen-dot-<semicolon-symbol> [V2653] (if (cons? (hd V2653)) (clojure.core/let [Parse_X (hd (hd V2653))] (if (= Parse_X (quote -semicol-)) (shen-dot-pair (hd (shen-dot-pair (tl (hd V2653)) (shen-dot-hdtl V2653))) (quote shen-dot-skip)) (fail))) (fail)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? hd = shen-dot-pair tl shen-dot-hdtl fail shen-dot-<formulae> not shen-dot-<formula> shen-dot-sequent) (clojure.core/defn shen-dot-<premise> [V2655] (clojure.core/let [YaccParse (if (clojure.core/and (cons? (hd V2655)) (= (quote !) (hd (hd V2655)))) (shen-dot-pair (hd (shen-dot-pair (tl (hd V2655)) (shen-dot-hdtl V2655))) (quote !)) (fail))] (if (= YaccParse (fail)) (clojure.core/let [YaccParse (clojure.core/let [Parse_shen-dot-<formulae> (shen-dot-<formulae> V2655)] (if (not (= (fail) Parse_shen-dot-<formulae>)) (if (clojure.core/and (cons? (hd Parse_shen-dot-<formulae>)) (= (quote >>) (hd (hd Parse_shen-dot-<formulae>)))) (clojure.core/let [Parse_shen-dot-<formula> (shen-dot-<formula> (shen-dot-pair (tl (hd Parse_shen-dot-<formulae>)) (shen-dot-hdtl Parse_shen-dot-<formulae>)))] (if (not (= (fail) Parse_shen-dot-<formula>)) (shen-dot-pair (hd Parse_shen-dot-<formula>) (shen-dot-sequent (shen-dot-hdtl Parse_shen-dot-<formulae>) (shen-dot-hdtl Parse_shen-dot-<formula>))) (fail))) (fail)) (fail)))] (if (= YaccParse (fail)) (clojure.core/let [Parse_shen-dot-<formula> (shen-dot-<formula> V2655)] (if (not (= (fail) Parse_shen-dot-<formula>)) (shen-dot-pair (hd Parse_shen-dot-<formula>) (shen-dot-sequent () (shen-dot-hdtl Parse_shen-dot-<formula>))) (fail))) YaccParse)) YaccParse)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-<formulae> not = fail cons? hd shen-dot-<formula> shen-dot-pair tl shen-dot-hdtl shen-dot-<semicolon-symbol> shen-dot-sequent) (clojure.core/defn shen-dot-<conclusion> [V2657] (clojure.core/let [YaccParse (clojure.core/let [Parse_shen-dot-<formulae> (shen-dot-<formulae> V2657)] (if (not (= (fail) Parse_shen-dot-<formulae>)) (if (clojure.core/and (cons? (hd Parse_shen-dot-<formulae>)) (= (quote >>) (hd (hd Parse_shen-dot-<formulae>)))) (clojure.core/let [Parse_shen-dot-<formula> (shen-dot-<formula> (shen-dot-pair (tl (hd Parse_shen-dot-<formulae>)) (shen-dot-hdtl Parse_shen-dot-<formulae>)))] (if (not (= (fail) Parse_shen-dot-<formula>)) (clojure.core/let [Parse_shen-dot-<semicolon-symbol> (shen-dot-<semicolon-symbol> Parse_shen-dot-<formula>)] (if (not (= (fail) Parse_shen-dot-<semicolon-symbol>)) (shen-dot-pair (hd Parse_shen-dot-<semicolon-symbol>) (shen-dot-sequent (shen-dot-hdtl Parse_shen-dot-<formulae>) (shen-dot-hdtl Parse_shen-dot-<formula>))) (fail))) (fail))) (fail)) (fail)))] (if (= YaccParse (fail)) (clojure.core/let [Parse_shen-dot-<formula> (shen-dot-<formula> V2657)] (if (not (= (fail) Parse_shen-dot-<formula>)) (clojure.core/let [Parse_shen-dot-<semicolon-symbol> (shen-dot-<semicolon-symbol> Parse_shen-dot-<formula>)] (if (not (= (fail) Parse_shen-dot-<semicolon-symbol>)) (shen-dot-pair (hd Parse_shen-dot-<semicolon-symbol>) (shen-dot-sequent () (shen-dot-hdtl Parse_shen-dot-<formula>))) (fail))) (fail))) YaccParse)))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-sequent [V2660 V2661] (-at-p V2660 V2661)))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-<formula> not = fail shen-dot-<comma-symbol> shen-dot-<formulae> shen-dot-pair hd cons shen-dot-hdtl <e>) (clojure.core/defn shen-dot-<formulae> [V2663] (clojure.core/let [YaccParse (clojure.core/let [Parse_shen-dot-<formula> (shen-dot-<formula> V2663)] (if (not (= (fail) Parse_shen-dot-<formula>)) (clojure.core/let [Parse_shen-dot-<comma-symbol> (shen-dot-<comma-symbol> Parse_shen-dot-<formula>)] (if (not (= (fail) Parse_shen-dot-<comma-symbol>)) (clojure.core/let [Parse_shen-dot-<formulae> (shen-dot-<formulae> Parse_shen-dot-<comma-symbol>)] (if (not (= (fail) Parse_shen-dot-<formulae>)) (shen-dot-pair (hd Parse_shen-dot-<formulae>) (cons (shen-dot-hdtl Parse_shen-dot-<formula>) (shen-dot-hdtl Parse_shen-dot-<formulae>))) (fail))) (fail))) (fail)))] (if (= YaccParse (fail)) (clojure.core/let [YaccParse (clojure.core/let [Parse_shen-dot-<formula> (shen-dot-<formula> V2663)] (if (not (= (fail) Parse_shen-dot-<formula>)) (shen-dot-pair (hd Parse_shen-dot-<formula>) (cons (shen-dot-hdtl Parse_shen-dot-<formula>) ())) (fail)))] (if (= YaccParse (fail)) (clojure.core/let [Parse_<e> (<e> V2663)] (if (not (= (fail) Parse_<e>)) (shen-dot-pair (hd Parse_<e>) ()) (fail))) YaccParse)) YaccParse)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? hd = intern shen-dot-pair tl shen-dot-hdtl fail) (clojure.core/defn shen-dot-<comma-symbol> [V2665] (if (cons? (hd V2665)) (clojure.core/let [Parse_X (hd (hd V2665))] (if (= Parse_X (intern ",")) (shen-dot-pair (hd (shen-dot-pair (tl (hd V2665)) (shen-dot-hdtl V2665))) (quote shen-dot-skip)) (fail))) (fail)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-<expr> not = fail cons? hd shen-dot-<type> shen-dot-pair tl shen-dot-hdtl cons shen-dot-curry shen-dot-demodulate) (clojure.core/defn shen-dot-<formula> [V2667] (clojure.core/let [YaccParse (clojure.core/let [Parse_shen-dot-<expr> (shen-dot-<expr> V2667)] (if (not (= (fail) Parse_shen-dot-<expr>)) (if (clojure.core/and (cons? (hd Parse_shen-dot-<expr>)) (= (quote -colon-) (hd (hd Parse_shen-dot-<expr>)))) (clojure.core/let [Parse_shen-dot-<type> (shen-dot-<type> (shen-dot-pair (tl (hd Parse_shen-dot-<expr>)) (shen-dot-hdtl Parse_shen-dot-<expr>)))] (if (not (= (fail) Parse_shen-dot-<type>)) (shen-dot-pair (hd Parse_shen-dot-<type>) (cons (shen-dot-curry (shen-dot-hdtl Parse_shen-dot-<expr>)) (cons (quote -colon-) (cons (shen-dot-demodulate (shen-dot-hdtl Parse_shen-dot-<type>)) ())))) (fail))) (fail)) (fail)))] (if (= YaccParse (fail)) (clojure.core/let [Parse_shen-dot-<expr> (shen-dot-<expr> V2667)] (if (not (= (fail) Parse_shen-dot-<expr>)) (shen-dot-pair (hd Parse_shen-dot-<expr>) (shen-dot-hdtl Parse_shen-dot-<expr>)) (fail))) YaccParse)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-<expr> not = fail shen-dot-pair hd shen-dot-curry-type shen-dot-hdtl) (clojure.core/defn shen-dot-<type> [V2669] (clojure.core/let [Parse_shen-dot-<expr> (shen-dot-<expr> V2669)] (if (not (= (fail) Parse_shen-dot-<expr>)) (shen-dot-pair (hd Parse_shen-dot-<expr>) (shen-dot-curry-type (shen-dot-hdtl Parse_shen-dot-<expr>))) (fail))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? hd shen-dot-doubleunderline? shen-dot-pair tl shen-dot-hdtl fail) (clojure.core/defn shen-dot-<doubleunderline> [V2671] (if (cons? (hd V2671)) (clojure.core/let [Parse_X (hd (hd V2671))] (if (shen-dot-doubleunderline? Parse_X) (shen-dot-pair (hd (shen-dot-pair (tl (hd V2671)) (shen-dot-hdtl V2671))) Parse_X) (fail))) (fail)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? hd shen-dot-singleunderline? shen-dot-pair tl shen-dot-hdtl fail) (clojure.core/defn shen-dot-<singleunderline> [V2673] (if (cons? (hd V2673)) (clojure.core/let [Parse_X (hd (hd V2673))] (if (shen-dot-singleunderline? Parse_X) (shen-dot-pair (hd (shen-dot-pair (tl (hd V2673)) (shen-dot-hdtl V2673))) Parse_X) (fail))) (fail)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare symbol? shen-dot-sh? str) (clojure.core/defn shen-dot-singleunderline? [V2675] (clojure.core/and (symbol? V2675) (shen-dot-sh? (str V2675))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare = pos shen-dot-sh? tlstr) (clojure.core/defn shen-dot-sh? [V2677] (clojure.core/cond (= "_" V2677) true true (clojure.core/and (= (pos V2677 0) "_") (shen-dot-sh? (tlstr V2677))) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare symbol? shen-dot-dh? str) (clojure.core/defn shen-dot-doubleunderline? [V2679] (clojure.core/and (symbol? V2679) (shen-dot-dh? (str V2679))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare = pos shen-dot-dh? tlstr) (clojure.core/defn shen-dot-dh? [V2681] (clojure.core/cond (= "=" V2681) true true (clojure.core/and (= (pos V2681 0) "=") (shen-dot-dh? (tlstr V2681))) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-process-datatype [V2684 V2685] (shen-dot-remember-datatype (shen-dot-s-prolog (shen-dot-rules->horn-clauses V2684 V2685)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? set adjoin hd value shen-dot-f_error) (clojure.core/defn shen-dot-remember-datatype [V2691] (clojure.core/cond (cons? V2691) (do (set (quote shen-dot-*datatypes*) (adjoin (hd V2691) (value (quote shen-dot-*datatypes*)))) (do (set (quote shen-dot-*alldatatypes*) (adjoin (hd V2691) (value (quote shen-dot-*alldatatypes*)))) (hd V2691))) true (shen-dot-f_error (quote shen-dot-remember-datatype)) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-rules->horn-clauses [V2696 V2697] (clojure.core/cond (= () V2697) () (clojure.core/and (cons? V2697) (clojure.core/and (tuple? (hd V2697)) (= (quote shen-dot-single) (fst (hd V2697))))) (cons (shen-dot-rule->horn-clause V2696 (snd (hd V2697))) (shen-dot-rules->horn-clauses V2696 (tl V2697))) (clojure.core/and (cons? V2697) (clojure.core/and (tuple? (hd V2697)) (= (quote shen-dot-double) (fst (hd V2697))))) (shen-dot-rules->horn-clauses V2696 (append (shen-dot-double->singles (snd (hd V2697))) (tl V2697))) true (shen-dot-f_error (quote shen-dot-rules->horn-clauses)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons shen-dot-right-rule shen-dot-left-rule) (clojure.core/defn shen-dot-double->singles [V2699] (cons (shen-dot-right-rule V2699) (cons (shen-dot-left-rule V2699) ())))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare -at-p) (clojure.core/defn shen-dot-right-rule [V2701] (-at-p (quote shen-dot-single) V2701))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-right->left cons? tl tuple? hd = fst gensym -at-p cons snd map shen-dot-f_error) (clojure.core/defn shen-dot-left-rule [V2703] (clojure.core/cond (clojure.core/and (cons? V2703) (clojure.core/and (cons? (tl V2703)) (clojure.core/and (cons? (tl (tl V2703))) (clojure.core/and (tuple? (hd (tl (tl V2703)))) (clojure.core/and (= () (fst (hd (tl (tl V2703))))) (= () (tl (tl (tl V2703))))))))) (clojure.core/let [Q (gensym (quote Qv))] (clojure.core/let [NewConclusion (-at-p (cons (snd (hd (tl (tl V2703)))) ()) Q)] (clojure.core/let [NewPremises (cons (-at-p (map (do (clojure.core/declare shen-dot-right->left) (clojure.core/fn [X] (shen-dot-right->left X))) (hd (tl V2703))) Q) ())] (-at-p (quote shen-dot-single) (cons (hd V2703) (cons NewPremises (cons NewConclusion ()))))))) true (shen-dot-f_error (quote shen-dot-left-rule)) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare tuple? = fst snd simple-error) (clojure.core/defn shen-dot-right->left [V2709] (clojure.core/cond (clojure.core/and (tuple? V2709) (= () (fst V2709))) (snd V2709) true (simple-error "syntax error with ==========\n") :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-rule->horn-clause [V2712 V2713] (clojure.core/cond (clojure.core/and (cons? V2713) (clojure.core/and (cons? (tl V2713)) (clojure.core/and (cons? (tl (tl V2713))) (clojure.core/and (tuple? (hd (tl (tl V2713)))) (= () (tl (tl (tl V2713)))))))) (cons (shen-dot-rule->horn-clause-head V2712 (snd (hd (tl (tl V2713))))) (cons (quote -colon--) (cons (shen-dot-rule->horn-clause-body (hd V2713) (hd (tl V2713)) (fst (hd (tl (tl V2713))))) ()))) true (shen-dot-f_error (quote shen-dot-rule->horn-clause)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-rule->horn-clause-head [V2716 V2717] (cons V2716 (cons (shen-dot-mode-ify V2717) (cons (quote Context_1957) ())))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? tl = hd cons) (clojure.core/defn shen-dot-mode-ify [V2719] (clojure.core/cond (clojure.core/and (cons? V2719) (clojure.core/and (cons? (tl V2719)) (clojure.core/and (= (quote -colon-) (hd (tl V2719))) (clojure.core/and (cons? (tl (tl V2719))) (= () (tl (tl (tl V2719)))))))) (cons (quote mode) (cons (cons (hd V2719) (cons (quote -colon-) (cons (cons (quote mode) (cons (hd (tl (tl V2719))) (cons (quote +) ()))) ()))) (cons (quote -) ()))) true V2719 :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-rule->horn-clause-body [V2723 V2724 V2725] (clojure.core/let [Variables (map (do (clojure.core/declare shen-dot-extract_vars) (clojure.core/fn [X] (shen-dot-extract_vars X))) V2725)] (clojure.core/let [Predicates (map (do (clojure.core/declare gensym) (clojure.core/fn [X] (gensym (quote shen-dot-cl)))) V2725)] (clojure.core/let [SearchLiterals (shen-dot-construct-search-literals Predicates Variables (quote Context_1957) (quote Context1_1957))] (clojure.core/let [SearchClauses (shen-dot-construct-search-clauses Predicates V2725 Variables)] (clojure.core/let [SideLiterals (shen-dot-construct-side-literals V2723)] (clojure.core/let [PremissLiterals (map (do (clojure.core/declare shen-dot-construct-premiss-literal empty?) (clojure.core/fn [X] (shen-dot-construct-premiss-literal X (empty? V2725)))) V2724)] (append SearchLiterals (append SideLiterals PremissLiterals))))))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-construct-search-literals [V2734 V2735 V2736 V2737] (clojure.core/cond (clojure.core/and (= () V2734) (= () V2735)) () true (shen-dot-csl-help V2734 V2735 V2736 V2737) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-csl-help [V2744 V2745 V2746 V2747] (clojure.core/cond (clojure.core/and (= () V2744) (= () V2745)) (cons (cons (quote bind) (cons (quote ContextOut_1957) (cons V2746 ()))) ()) (clojure.core/and (cons? V2744) (cons? V2745)) (cons (cons (hd V2744) (cons V2746 (cons V2747 (hd V2745)))) (shen-dot-csl-help (tl V2744) (tl V2745) V2747 (gensym (quote Context)))) true (shen-dot-f_error (quote shen-dot-csl-help)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-construct-search-clauses [V2751 V2752 V2753] (clojure.core/cond (clojure.core/and (= () V2751) (clojure.core/and (= () V2752) (= () V2753))) (quote shen-dot-skip) (clojure.core/and (cons? V2751) (clojure.core/and (cons? V2752) (cons? V2753))) (do (shen-dot-construct-search-clause (hd V2751) (hd V2752) (hd V2753)) (shen-dot-construct-search-clauses (tl V2751) (tl V2752) (tl V2753))) true (shen-dot-f_error (quote shen-dot-construct-search-clauses)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-construct-search-clause [V2757 V2758 V2759] (shen-dot-s-prolog (cons (shen-dot-construct-base-search-clause V2757 V2758 V2759) (cons (shen-dot-construct-recursive-search-clause V2757 V2758 V2759) ())))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-construct-base-search-clause [V2763 V2764 V2765] (cons (cons V2763 (cons (cons (shen-dot-mode-ify V2764) (quote In_1957)) (cons (quote In_1957) V2765))) (cons (quote -colon--) (cons () ())))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-construct-recursive-search-clause [V2769 V2770 V2771] (cons (cons V2769 (cons (cons (quote Assumption_1957) (quote Assumptions_1957)) (cons (cons (quote Assumption_1957) (quote Out_1957)) V2771))) (cons (quote -colon--) (cons (cons (cons V2769 (cons (quote Assumptions_1957) (cons (quote Out_1957) V2771))) ()) ())))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare = cons? hd tl cons shen-dot-construct-side-literals shen-dot-f_error) (clojure.core/defn shen-dot-construct-side-literals [V2777] (clojure.core/cond (= () V2777) () (clojure.core/and (cons? V2777) (clojure.core/and (cons? (hd V2777)) (clojure.core/and (= (quote if) (hd (hd V2777))) (clojure.core/and (cons? (tl (hd V2777))) (= () (tl (tl (hd V2777)))))))) (cons (cons (quote when) (tl (hd V2777))) (shen-dot-construct-side-literals (tl V2777))) (clojure.core/and (cons? V2777) (clojure.core/and (cons? (hd V2777)) (clojure.core/and (= (quote let) (hd (hd V2777))) (clojure.core/and (cons? (tl (hd V2777))) (clojure.core/and (cons? (tl (tl (hd V2777)))) (= () (tl (tl (tl (hd V2777)))))))))) (cons (cons (quote is) (tl (hd V2777))) (shen-dot-construct-side-literals (tl V2777))) (cons? V2777) (shen-dot-construct-side-literals (tl V2777)) true (shen-dot-f_error (quote shen-dot-construct-side-literals)) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-construct-premiss-literal [V2784 V2785] (clojure.core/cond (tuple? V2784) (cons (quote shen-dot-t*) (cons (shen-dot-recursive_cons_form (snd V2784)) (cons (shen-dot-construct-context V2785 (fst V2784)) ()))) (= (quote !) V2784) (cons (quote cut) (cons (quote Throwcontrol) ())) true (shen-dot-f_error (quote shen-dot-construct-premiss-literal)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-construct-context [V2788 V2789] (clojure.core/cond (clojure.core/and (= true V2788) (= () V2789)) (quote Context_1957) (clojure.core/and (= false V2788) (= () V2789)) (quote ContextOut_1957) (cons? V2789) (cons (quote cons) (cons (shen-dot-recursive_cons_form (hd V2789)) (cons (shen-dot-construct-context V2788 (tl V2789)) ()))) true (shen-dot-f_error (quote shen-dot-construct-context)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? cons shen-dot-recursive_cons_form hd tl) (clojure.core/defn shen-dot-recursive_cons_form [V2791] (clojure.core/cond (cons? V2791) (cons (quote cons) (cons (shen-dot-recursive_cons_form (hd V2791)) (cons (shen-dot-recursive_cons_form (tl V2791)) ()))) true V2791 :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-intern-type shen-dot-preclude-h map) (clojure.core/defn preclude [V2793] (shen-dot-preclude-h (map (do (clojure.core/declare shen-dot-intern-type) (clojure.core/fn [X] (shen-dot-intern-type X))) V2793)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare set difference value) (clojure.core/defn shen-dot-preclude-h [V2795] (clojure.core/let [FilterDatatypes (set (quote shen-dot-*datatypes*) (difference (value (quote shen-dot-*datatypes*)) V2795))] (value (quote shen-dot-*datatypes*))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-intern-type shen-dot-include-h map) (clojure.core/defn include [V2797] (shen-dot-include-h (map (do (clojure.core/declare shen-dot-intern-type) (clojure.core/fn [X] (shen-dot-intern-type X))) V2797)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare intersection value set union) (clojure.core/defn shen-dot-include-h [V2799] (clojure.core/let [ValidTypes (intersection V2799 (value (quote shen-dot-*alldatatypes*)))] (clojure.core/let [NewDatatypes (set (quote shen-dot-*datatypes*) (union ValidTypes (value (quote shen-dot-*datatypes*))))] (value (quote shen-dot-*datatypes*)))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-intern-type shen-dot-preclude-h difference value map) (clojure.core/defn preclude-all-but [V2801] (shen-dot-preclude-h (difference (value (quote shen-dot-*alldatatypes*)) (map (do (clojure.core/declare shen-dot-intern-type) (clojure.core/fn [X] (shen-dot-intern-type X))) V2801))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-intern-type shen-dot-include-h difference value map) (clojure.core/defn include-all-but [V2803] (shen-dot-include-h (difference (value (quote shen-dot-*alldatatypes*)) (map (do (clojure.core/declare shen-dot-intern-type) (clojure.core/fn [X] (shen-dot-intern-type X))) V2803))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-demod-rule = shen-dot-update-demodulation-function value mapcan cons? tl difference shen-dot-extract_vars hd empty? shen-dot-pushnew cons shen-dot-synonyms-help shen-dot-free_variable_warnings simple-error) (clojure.core/defn shen-dot-synonyms-help [V2809] (clojure.core/cond (= () V2809) (shen-dot-update-demodulation-function (value (quote shen-dot-*tc*)) (mapcan (do (clojure.core/declare shen-dot-demod-rule) (clojure.core/fn [X] (shen-dot-demod-rule X))) (value (quote shen-dot-*synonyms*)))) (clojure.core/and (cons? V2809) (cons? (tl V2809))) (clojure.core/let [Vs (difference (shen-dot-extract_vars (hd (tl V2809))) (shen-dot-extract_vars (hd V2809)))] (if (empty? Vs) (do (shen-dot-pushnew (cons (hd V2809) (cons (hd (tl V2809)) ())) (quote shen-dot-*synonyms*)) (shen-dot-synonyms-help (tl (tl V2809)))) (shen-dot-free_variable_warnings (hd (tl V2809)) Vs))) true (simple-error "odd number of synonyms\n") :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-pushnew [V2812 V2813] (if (element? V2812 (value V2813)) (value V2813) (set V2813 (cons V2812 (value V2813))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? tl = cons shen-dot-rcons_form hd shen-dot-f_error) (clojure.core/defn shen-dot-demod-rule [V2815] (clojure.core/cond (clojure.core/and (cons? V2815) (clojure.core/and (cons? (tl V2815)) (= () (tl (tl V2815))))) (cons (shen-dot-rcons_form (hd V2815)) (cons (quote ->) (cons (shen-dot-rcons_form (hd (tl V2815))) ()))) true (shen-dot-f_error (quote shen-dot-demod-rule)) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? = hd tl eval cons shen-dot-f_error) (clojure.core/defn shen-dot-lambda-of-defun [V2821] (clojure.core/cond (clojure.core/and (cons? V2821) (clojure.core/and (= (quote defun) (hd V2821)) (clojure.core/and (cons? (tl V2821)) (clojure.core/and (cons? (tl (tl V2821))) (clojure.core/and (cons? (hd (tl (tl V2821)))) (clojure.core/and (= () (tl (hd (tl (tl V2821))))) (clojure.core/and (cons? (tl (tl (tl V2821)))) (= () (tl (tl (tl (tl V2821)))))))))))) (eval (cons (quote -slash--dot-) (cons (hd (hd (tl (tl V2821)))) (tl (tl (tl V2821)))))) true (shen-dot-f_error (quote shen-dot-lambda-of-defun)) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-update-demodulation-function [V2824 V2825] (do (tc (quote -)) (do (set (quote shen-dot-*demodulation-function*) (shen-dot-lambda-of-defun (shen-dot-elim-def (cons (quote define) (cons (quote shen-dot-demod) (append V2825 (shen-dot-default-rule))))))) (do (if V2824 (tc (quote +)) (quote shen-dot-skip)) (quote synonyms))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons) (clojure.core/defn shen-dot-default-rule [] (cons (quote X) (cons (quote ->) (cons (quote X) ()))))))
(clojure.core/comment yacc.kl)
(clojure.core/comment "Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.")
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? = hd tl shen-dot-yacc->shen shen-dot-f_error) (clojure.core/defn shen-dot-yacc [V4275] (clojure.core/cond (clojure.core/and (cons? V4275) (clojure.core/and (= (quote defcc) (hd V4275)) (cons? (tl V4275)))) (shen-dot-yacc->shen (hd (tl V4275)) (tl (tl V4275))) true (shen-dot-f_error (quote shen-dot-yacc)) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-yacc->shen [V4278 V4279] (clojure.core/let [CCRules (shen-dot-split_cc_rules true V4279 ())] (clojure.core/let [CCBody (map (do (clojure.core/declare shen-dot-cc_body) (clojure.core/fn [X] (shen-dot-cc_body X))) CCRules)] (clojure.core/let [YaccCases (shen-dot-yacc_cases CCBody)] (cons (quote define) (cons V4278 (cons (quote Stream) (cons (quote ->) (cons (shen-dot-kill-code YaccCases) ()))))))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare > occurrences cons) (clojure.core/defn shen-dot-kill-code [V4281] (clojure.core/cond (> (occurrences (quote kill) V4281) 0) (cons (quote trap-error) (cons V4281 (cons (cons (quote lambda) (cons (quote E) (cons (cons (quote shen-dot-analyse-kill) (cons (quote E) ())) ()))) ()))) true V4281 :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare simple-error) (clojure.core/defn kill [] (simple-error "yacc kill"))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare error-to-string = fail) (clojure.core/defn shen-dot-analyse-kill [V4283] (clojure.core/let [String (error-to-string V4283)] (if (= String "yacc kill") (fail) V4283)))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-split_cc_rules [V4289 V4290 V4291] (clojure.core/cond (clojure.core/and (= () V4290) (= () V4291)) () (= () V4290) (cons (shen-dot-split_cc_rule V4289 (reverse V4291) ()) ()) (clojure.core/and (cons? V4290) (= (quote -semicol-) (hd V4290))) (cons (shen-dot-split_cc_rule V4289 (reverse V4291) ()) (shen-dot-split_cc_rules V4289 (tl V4290) ())) (cons? V4290) (shen-dot-split_cc_rules V4289 (tl V4290) (cons (hd V4290) V4291)) true (shen-dot-f_error (quote shen-dot-split_cc_rules)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-split_cc_rule [V4299 V4300 V4301] (clojure.core/cond (clojure.core/and (cons? V4300) (clojure.core/and (= (quote -colon-=) (hd V4300)) (clojure.core/and (cons? (tl V4300)) (= () (tl (tl V4300)))))) (cons (reverse V4301) (tl V4300)) (clojure.core/and (cons? V4300) (clojure.core/and (= (quote -colon-=) (hd V4300)) (clojure.core/and (cons? (tl V4300)) (clojure.core/and (cons? (tl (tl V4300))) (clojure.core/and (= (quote where) (hd (tl (tl V4300)))) (clojure.core/and (cons? (tl (tl (tl V4300)))) (= () (tl (tl (tl (tl V4300))))))))))) (cons (reverse V4301) (cons (cons (quote where) (cons (hd (tl (tl (tl V4300)))) (cons (hd (tl V4300)) ()))) ())) (= () V4300) (do (shen-dot-semantic-completion-warning V4299 V4301) (shen-dot-split_cc_rule V4299 (cons (quote -colon-=) (cons (shen-dot-default_semantics (reverse V4301)) ())) V4301)) (cons? V4300) (shen-dot-split_cc_rule V4299 (tl V4300) (cons (hd V4300) V4301)) true (shen-dot-f_error (quote shen-dot-split_cc_rule)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-semantic-completion-warning [V4312 V4313] (clojure.core/cond (= true V4312) (do (shen-dot-prhush "warning: " (stoutput)) (do (shen-dot-for-each (do (clojure.core/declare shen-dot-prhush shen-dot-app stoutput) (clojure.core/fn [X] (shen-dot-prhush (shen-dot-app X " " (quote shen-dot-a)) (stoutput)))) (reverse V4313)) (shen-dot-prhush "has no semantics.\n" (stoutput)))) true (quote shen-dot-skip) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare = cons? tl shen-dot-grammar_symbol? hd cons shen-dot-default_semantics shen-dot-f_error) (clojure.core/defn shen-dot-default_semantics [V4315] (clojure.core/cond (= () V4315) () (clojure.core/and (cons? V4315) (clojure.core/and (= () (tl V4315)) (shen-dot-grammar_symbol? (hd V4315)))) (hd V4315) (clojure.core/and (cons? V4315) (shen-dot-grammar_symbol? (hd V4315))) (cons (quote append) (cons (hd V4315) (cons (shen-dot-default_semantics (tl V4315)) ()))) (cons? V4315) (cons (quote cons) (cons (hd V4315) (cons (shen-dot-default_semantics (tl V4315)) ()))) true (shen-dot-f_error (quote shen-dot-default_semantics)) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare symbol? shen-dot-strip-pathname explode = hd reverse) (clojure.core/defn shen-dot-grammar_symbol? [V4317] (clojure.core/and (symbol? V4317) (clojure.core/let [Cs (shen-dot-strip-pathname (explode V4317))] (clojure.core/and (= (hd Cs) "<") (= (hd (reverse Cs)) ">")))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? = tl hd cons shen-dot-yacc_cases shen-dot-f_error) (clojure.core/defn shen-dot-yacc_cases [V4319] (clojure.core/cond (clojure.core/and (cons? V4319) (= () (tl V4319))) (hd V4319) (cons? V4319) (clojure.core/let [P (quote YaccParse)] (cons (quote let) (cons P (cons (hd V4319) (cons (cons (quote if) (cons (cons (quote =) (cons P (cons (cons (quote fail) ()) ()))) (cons (shen-dot-yacc_cases (tl V4319)) (cons P ())))) ()))))) true (shen-dot-f_error (quote shen-dot-yacc_cases)) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? tl = shen-dot-syntax hd shen-dot-f_error) (clojure.core/defn shen-dot-cc_body [V4321] (clojure.core/cond (clojure.core/and (cons? V4321) (clojure.core/and (cons? (tl V4321)) (= () (tl (tl V4321))))) (shen-dot-syntax (hd V4321) (quote Stream) (hd (tl V4321))) true (shen-dot-f_error (quote shen-dot-cc_body)) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-syntax [V4325 V4326 V4327] (clojure.core/cond (clojure.core/and (= () V4325) (clojure.core/and (cons? V4327) (clojure.core/and (= (quote where) (hd V4327)) (clojure.core/and (cons? (tl V4327)) (clojure.core/and (cons? (tl (tl V4327))) (= () (tl (tl (tl V4327))))))))) (cons (quote if) (cons (shen-dot-semantics (hd (tl V4327))) (cons (cons (quote shen-dot-pair) (cons (cons (quote hd) (cons V4326 ())) (cons (shen-dot-semantics (hd (tl (tl V4327)))) ()))) (cons (cons (quote fail) ()) ())))) (= () V4325) (cons (quote shen-dot-pair) (cons (cons (quote hd) (cons V4326 ())) (cons (shen-dot-semantics V4327) ()))) (cons? V4325) (if (shen-dot-grammar_symbol? (hd V4325)) (shen-dot-recursive_descent V4325 V4326 V4327) (if (variable? (hd V4325)) (shen-dot-variable-match V4325 V4326 V4327) (if (shen-dot-jump_stream? (hd V4325)) (shen-dot-jump_stream V4325 V4326 V4327) (if (shen-dot-terminal? (hd V4325)) (shen-dot-check_stream V4325 V4326 V4327) (if (cons? (hd V4325)) (shen-dot-list-stream (shen-dot-decons (hd V4325)) (tl V4325) V4326 V4327) (simple-error (shen-dot-app (hd V4325) " is not legal syntax\n" (quote shen-dot-a)))))))) true (shen-dot-f_error (quote shen-dot-syntax)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-list-stream [V4332 V4333 V4334 V4335] (clojure.core/let [Test (cons (quote and) (cons (cons (quote cons?) (cons (cons (quote hd) (cons V4334 ())) ())) (cons (cons (quote cons?) (cons (cons (quote shen-dot-hdhd) (cons V4334 ())) ())) ())))] (clojure.core/let [Placeholder (gensym (quote shen-dot-place))] (clojure.core/let [RunOn (shen-dot-syntax V4333 (cons (quote shen-dot-pair) (cons (cons (quote shen-dot-tlhd) (cons V4334 ())) (cons (cons (quote shen-dot-hdtl) (cons V4334 ())) ()))) V4335)] (clojure.core/let [Action (shen-dot-insert-runon RunOn Placeholder (shen-dot-syntax V4332 (cons (quote shen-dot-pair) (cons (cons (quote shen-dot-hdhd) (cons V4334 ())) (cons (cons (quote shen-dot-hdtl) (cons V4334 ())) ()))) Placeholder))] (cons (quote if) (cons Test (cons Action (cons (cons (quote fail) ()) ()))))))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? = hd tl cons shen-dot-decons) (clojure.core/defn shen-dot-decons [V4337] (clojure.core/cond (clojure.core/and (cons? V4337) (clojure.core/and (= (quote cons) (hd V4337)) (clojure.core/and (cons? (tl V4337)) (clojure.core/and (cons? (tl (tl V4337))) (clojure.core/and (= () (hd (tl (tl V4337)))) (= () (tl (tl (tl V4337))))))))) (cons (hd (tl V4337)) ()) (clojure.core/and (cons? V4337) (clojure.core/and (= (quote cons) (hd V4337)) (clojure.core/and (cons? (tl V4337)) (clojure.core/and (cons? (tl (tl V4337))) (= () (tl (tl (tl V4337)))))))) (cons (hd (tl V4337)) (shen-dot-decons (hd (tl (tl V4337))))) true V4337 :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-insert-runon [V4352 V4353 V4354] (clojure.core/cond (clojure.core/and (cons? V4354) (clojure.core/and (= (quote shen-dot-pair) (hd V4354)) (clojure.core/and (cons? (tl V4354)) (clojure.core/and (cons? (tl (tl V4354))) (clojure.core/and (= () (tl (tl (tl V4354)))) (= (hd (tl (tl V4354))) V4353)))))) V4352 (cons? V4354) (map (do (clojure.core/declare shen-dot-insert-runon) (clojure.core/fn [Z] (shen-dot-insert-runon V4352 V4353 Z))) V4354) true V4354 :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare not element? cons? shen-dot-strip-pathname tl shen-dot-f_error) (clojure.core/defn shen-dot-strip-pathname [V4360] (clojure.core/cond (not (element? "." V4360)) V4360 (cons? V4360) (shen-dot-strip-pathname (tl V4360)) true (shen-dot-f_error (quote shen-dot-strip-pathname)) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-recursive_descent [V4364 V4365 V4366] (clojure.core/cond (cons? V4364) (clojure.core/let [Test (cons (hd V4364) (cons V4365 ()))] (clojure.core/let [Action (shen-dot-syntax (tl V4364) (concat (quote Parse_) (hd V4364)) V4366)] (clojure.core/let [Else (cons (quote fail) ())] (cons (quote let) (cons (concat (quote Parse_) (hd V4364)) (cons Test (cons (cons (quote if) (cons (cons (quote not) (cons (cons (quote =) (cons (cons (quote fail) ()) (cons (concat (quote Parse_) (hd V4364)) ()))) ())) (cons Action (cons Else ())))) ()))))))) true (shen-dot-f_error (quote shen-dot-recursive_descent)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-variable-match [V4370 V4371 V4372] (clojure.core/cond (cons? V4370) (clojure.core/let [Test (cons (quote cons?) (cons (cons (quote hd) (cons V4371 ())) ()))] (clojure.core/let [Action (cons (quote let) (cons (concat (quote Parse_) (hd V4370)) (cons (cons (quote shen-dot-hdhd) (cons V4371 ())) (cons (shen-dot-syntax (tl V4370) (cons (quote shen-dot-pair) (cons (cons (quote shen-dot-tlhd) (cons V4371 ())) (cons (cons (quote shen-dot-hdtl) (cons V4371 ())) ()))) V4372) ()))))] (clojure.core/let [Else (cons (quote fail) ())] (cons (quote if) (cons Test (cons Action (cons Else ()))))))) true (shen-dot-f_error (quote shen-dot-variable-match)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? variable?) (clojure.core/defn shen-dot-terminal? [V4382] (clojure.core/cond (cons? V4382) false (variable? V4382) false true true :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare =) (clojure.core/defn shen-dot-jump_stream? [V4388] (clojure.core/cond (= V4388 (quote _)) true true false :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-check_stream [V4392 V4393 V4394] (clojure.core/cond (cons? V4392) (clojure.core/let [Test (cons (quote and) (cons (cons (quote cons?) (cons (cons (quote hd) (cons V4393 ())) ())) (cons (cons (quote =) (cons (hd V4392) (cons (cons (quote shen-dot-hdhd) (cons V4393 ())) ()))) ())))] (clojure.core/let [NewStr (gensym (quote NewStream))] (clojure.core/let [Action (cons (quote let) (cons NewStr (cons (cons (quote shen-dot-pair) (cons (cons (quote shen-dot-tlhd) (cons V4393 ())) (cons (cons (quote shen-dot-hdtl) (cons V4393 ())) ()))) (cons (shen-dot-syntax (tl V4392) NewStr V4394) ()))))] (clojure.core/let [Else (cons (quote fail) ())] (cons (quote if) (cons Test (cons Action (cons Else ())))))))) true (shen-dot-f_error (quote shen-dot-check_stream)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-jump_stream [V4398 V4399 V4400] (clojure.core/cond (cons? V4398) (clojure.core/let [Test (cons (quote cons?) (cons (cons (quote hd) (cons V4399 ())) ()))] (clojure.core/let [Action (shen-dot-syntax (tl V4398) (cons (quote shen-dot-pair) (cons (cons (quote shen-dot-tlhd) (cons V4399 ())) (cons (cons (quote shen-dot-hdtl) (cons V4399 ())) ()))) V4400)] (clojure.core/let [Else (cons (quote fail) ())] (cons (quote if) (cons Test (cons Action (cons Else ()))))))) true (shen-dot-f_error (quote shen-dot-jump_stream)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-semantics = shen-dot-grammar_symbol? cons concat variable? cons? map) (clojure.core/defn shen-dot-semantics [V4402] (clojure.core/cond (= () V4402) () (shen-dot-grammar_symbol? V4402) (cons (quote shen-dot-hdtl) (cons (concat (quote Parse_) V4402) ())) (variable? V4402) (concat (quote Parse_) V4402) (cons? V4402) (map (do (clojure.core/declare shen-dot-semantics) (clojure.core/fn [Z] (shen-dot-semantics Z))) V4402) true V4402 :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-pair [V4405 V4406] (cons V4405 (cons V4406 ()))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare hd tl) (clojure.core/defn shen-dot-hdtl [V4408] (hd (tl V4408)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare hd) (clojure.core/defn shen-dot-hdhd [V4410] (hd (hd V4410)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare tl hd) (clojure.core/defn shen-dot-tlhd [V4412] (tl (hd V4412)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? tl = hd fail) (clojure.core/defn shen-dot-snd-or-fail [V4420] (clojure.core/cond (clojure.core/and (cons? V4420) (clojure.core/and (cons? (tl V4420)) (= () (tl (tl V4420))))) (hd (tl V4420)) true (fail) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (clojure.core/defn fail [] (quote shen-dot-fail!)))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? tl = cons hd fail) (clojure.core/defn <!> [V4428] (clojure.core/cond (clojure.core/and (cons? V4428) (clojure.core/and (cons? (tl V4428)) (= () (tl (tl V4428))))) (cons () (cons (hd V4428) ())) true (fail) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? tl = cons hd shen-dot-f_error) (clojure.core/defn <e> [V4434] (clojure.core/cond (clojure.core/and (cons? V4434) (clojure.core/and (cons? (tl V4434)) (= () (tl (tl V4434))))) (cons (hd V4434) (cons () ())) true (shen-dot-f_error (quote <e>)) :else (throw (Exception. "No matching cond clause"))))))
(clojure.core/comment reader.kl)
(clojure.core/comment "Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.")
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare read-byte) (clojure.core/defn shen-dot-read-char-code [V2358] (read-byte V2358))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare read-byte shen-dot-read-file-as-Xlist) (clojure.core/defn read-file-as-bytelist [V2360] (shen-dot-read-file-as-Xlist V2360 (do (clojure.core/declare read-byte) (clojure.core/fn [S] (read-byte S)))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-read-char-code shen-dot-read-file-as-Xlist) (clojure.core/defn shen-dot-read-file-as-charlist [V2362] (shen-dot-read-file-as-Xlist V2362 (do (clojure.core/declare shen-dot-read-char-code) (clojure.core/fn [S] (shen-dot-read-char-code S)))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-read-file-as-Xlist [V2365 V2366] (clojure.core/let [Stream (open V2365 (quote in))] (clojure.core/let [X ((shen.primitives/resolve-fn V2366) Stream)] (clojure.core/let [Xs (shen-dot-read-file-as-Xlist-help Stream V2366 X ())] (clojure.core/let [Close (close Stream)] (reverse Xs)))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-read-file-as-Xlist-help [V2371 V2372 V2373 V2374] (clojure.core/cond (= -1 V2373) V2374 true (shen-dot-read-file-as-Xlist-help V2371 V2372 ((shen.primitives/resolve-fn V2372) V2371) (cons V2373 V2374)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare open shen-dot-rfas-h shen-dot-read-char-code) (clojure.core/defn read-file-as-string [V2376] (clojure.core/let [Stream (open V2376 (quote in))] (shen-dot-rfas-h Stream (shen-dot-read-char-code Stream) "")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-rfas-h [V2380 V2381 V2382] (clojure.core/cond (= -1 V2381) (do (close V2380) V2382) true (shen-dot-rfas-h V2380 (shen-dot-read-char-code V2380) (cn V2382 (n->string V2381))) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare eval-kl read) (clojure.core/defn input [V2384] (eval-kl (read V2384)))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried input+ [V2387 V2388] (clojure.core/let [Mono? (shen-dot-monotype V2387)] (clojure.core/let [Input (read V2388)] (if (= false (shen-dot-typecheck Input (shen-dot-demodulate V2387))) (simple-error (cn "type error: " (shen-dot-app Input (cn " is not of type " (shen-dot-app V2387 "\n" (quote shen-dot-r))) (quote shen-dot-r)))) (eval-kl Input))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-monotype cons? map variable? simple-error cn shen-dot-app) (clojure.core/defn shen-dot-monotype [V2390] (clojure.core/cond (cons? V2390) (map (do (clojure.core/declare shen-dot-monotype) (clojure.core/fn [Z] (shen-dot-monotype Z))) V2390) true (if (variable? V2390) (simple-error (cn "input+ expects a monotype: not " (shen-dot-app V2390 "\n" (quote shen-dot-a)))) V2390) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare hd shen-dot-read-loop shen-dot-read-char-code) (clojure.core/defn read [V2392] (hd (shen-dot-read-loop V2392 (shen-dot-read-char-code V2392) ())))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare value) (clojure.core/defn it [] (value (quote shen-dot-*it*)))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-read-loop [V2400 V2401 V2402] (clojure.core/cond (= 94 V2401) (simple-error "read aborted") (= -1 V2401) (if (empty? V2402) (simple-error "error: empty stream") (compile (do (clojure.core/declare shen-dot-<st_input>) (clojure.core/fn [X] (shen-dot-<st_input> X))) V2402 (clojure.core/fn [E] E))) (shen-dot-terminator? V2401) (clojure.core/let [AllChars (append V2402 (cons V2401 ()))] (clojure.core/let [It (shen-dot-record-it AllChars)] (clojure.core/let [Read (compile (do (clojure.core/declare shen-dot-<st_input>) (clojure.core/fn [X] (shen-dot-<st_input> X))) AllChars (clojure.core/fn [E] (quote shen-dot-nextbyte)))] (if (clojure.core/or (= Read (quote shen-dot-nextbyte)) (empty? Read)) (shen-dot-read-loop V2400 (shen-dot-read-char-code V2400) AllChars) Read)))) true (shen-dot-read-loop V2400 (shen-dot-read-char-code V2400) (append V2402 (cons V2401 ()))) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare element? cons) (clojure.core/defn shen-dot-terminator? [V2404] (element? V2404 (cons 9 (cons 10 (cons 13 (cons 32 (cons 34 (cons 41 (cons 93 ())))))))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-lineread-loop shen-dot-read-char-code) (clojure.core/defn lineread [V2406] (shen-dot-lineread-loop (shen-dot-read-char-code V2406) () V2406))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-lineread-loop [V2411 V2412 V2413] (clojure.core/cond (= -1 V2411) (if (empty? V2412) (simple-error "empty stream") (compile (do (clojure.core/declare shen-dot-<st_input>) (clojure.core/fn [X] (shen-dot-<st_input> X))) V2412 (clojure.core/fn [E] E))) (= V2411 (shen-dot-hat)) (simple-error "line read aborted") (element? V2411 (cons (shen-dot-newline) (cons (shen-dot-carriage-return) ()))) (clojure.core/let [Line (compile (do (clojure.core/declare shen-dot-<st_input>) (clojure.core/fn [X] (shen-dot-<st_input> X))) V2412 (clojure.core/fn [E] (quote shen-dot-nextline)))] (clojure.core/let [It (shen-dot-record-it V2412)] (if (clojure.core/or (= Line (quote shen-dot-nextline)) (empty? Line)) (shen-dot-lineread-loop (shen-dot-read-char-code V2413) (append V2412 (cons V2411 ())) V2413) Line))) true (shen-dot-lineread-loop (shen-dot-read-char-code V2413) (append V2412 (cons V2411 ())) V2413) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-trim-whitespace reverse shen-dot-record-it-h) (clojure.core/defn shen-dot-record-it [V2415] (clojure.core/let [TrimLeft (shen-dot-trim-whitespace V2415)] (clojure.core/let [TrimRight (shen-dot-trim-whitespace (reverse TrimLeft))] (clojure.core/let [Trimmed (reverse TrimRight)] (shen-dot-record-it-h Trimmed)))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? element? hd cons shen-dot-trim-whitespace tl) (clojure.core/defn shen-dot-trim-whitespace [V2417] (clojure.core/cond (clojure.core/and (cons? V2417) (element? (hd V2417) (cons 9 (cons 10 (cons 13 (cons 32 ())))))) (shen-dot-trim-whitespace (tl V2417)) true V2417 :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare n->string set shen-dot-cn-all map) (clojure.core/defn shen-dot-record-it-h [V2419] (do (set (quote shen-dot-*it*) (shen-dot-cn-all (map (do (clojure.core/declare n->string) (clojure.core/fn [X] (n->string X))) V2419))) V2419))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare = cons? cn hd shen-dot-cn-all tl shen-dot-f_error) (clojure.core/defn shen-dot-cn-all [V2421] (clojure.core/cond (= () V2421) "" (cons? V2421) (cn (hd V2421) (shen-dot-cn-all (tl V2421))) true (shen-dot-f_error (quote shen-dot-cn-all)) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-read-error shen-dot-read-file-as-charlist compile shen-dot-<st_input>) (clojure.core/defn read-file [V2423] (clojure.core/let [Charlist (shen-dot-read-file-as-charlist V2423)] (compile (do (clojure.core/declare shen-dot-<st_input>) (clojure.core/fn [X] (shen-dot-<st_input> X))) Charlist (do (clojure.core/declare shen-dot-read-error) (clojure.core/fn [X] (shen-dot-read-error X))))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-read-error map string->n explode compile shen-dot-<st_input>) (clojure.core/defn read-from-string [V2425] (clojure.core/let [Ns (map (do (clojure.core/declare string->n) (clojure.core/fn [X] (string->n X))) (explode V2425))] (compile (do (clojure.core/declare shen-dot-<st_input>) (clojure.core/fn [X] (shen-dot-<st_input> X))) Ns (do (clojure.core/declare shen-dot-read-error) (clojure.core/fn [X] (shen-dot-read-error X))))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? hd tl = simple-error cn shen-dot-app shen-dot-compress-50) (clojure.core/defn shen-dot-read-error [V2433] (clojure.core/cond (clojure.core/and (cons? V2433) (clojure.core/and (cons? (hd V2433)) (clojure.core/and (cons? (tl V2433)) (= () (tl (tl V2433)))))) (simple-error (cn "read error here:\n\n " (shen-dot-app (shen-dot-compress-50 50 (hd V2433)) "\n" (quote shen-dot-a)))) true (simple-error "read error\n") :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-compress-50 [V2440 V2441] (clojure.core/cond (= () V2441) "" (= 0 V2440) "" (cons? V2441) (cn (n->string (hd V2441)) (shen-dot-compress-50 (- V2440 1) (tl V2441))) true (shen-dot-f_error (quote shen-dot-compress-50)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-<lsb> not = fail shen-dot-<st_input1> shen-dot-<rsb> shen-dot-<st_input2> shen-dot-pair hd cons macroexpand shen-dot-cons_form shen-dot-hdtl shen-dot-<lrb> shen-dot-<rrb> shen-dot-package-macro shen-dot-<lcurly> shen-dot-<st_input> shen-dot-<rcurly> shen-dot-<bar> shen-dot-<semicolon> shen-dot-<colon> shen-dot-<equal> shen-dot-<minus> shen-dot-<comma> intern shen-dot-<comment> shen-dot-<atom> shen-dot-<whitespaces> <e>) (clojure.core/defn shen-dot-<st_input> [V2443] (clojure.core/let [YaccParse (clojure.core/let [Parse_shen-dot-<lsb> (shen-dot-<lsb> V2443)] (if (not (= (fail) Parse_shen-dot-<lsb>)) (clojure.core/let [Parse_shen-dot-<st_input1> (shen-dot-<st_input1> Parse_shen-dot-<lsb>)] (if (not (= (fail) Parse_shen-dot-<st_input1>)) (clojure.core/let [Parse_shen-dot-<rsb> (shen-dot-<rsb> Parse_shen-dot-<st_input1>)] (if (not (= (fail) Parse_shen-dot-<rsb>)) (clojure.core/let [Parse_shen-dot-<st_input2> (shen-dot-<st_input2> Parse_shen-dot-<rsb>)] (if (not (= (fail) Parse_shen-dot-<st_input2>)) (shen-dot-pair (hd Parse_shen-dot-<st_input2>) (cons (macroexpand (shen-dot-cons_form (shen-dot-hdtl Parse_shen-dot-<st_input1>))) (shen-dot-hdtl Parse_shen-dot-<st_input2>))) (fail))) (fail))) (fail))) (fail)))] (if (= YaccParse (fail)) (clojure.core/let [YaccParse (clojure.core/let [Parse_shen-dot-<lrb> (shen-dot-<lrb> V2443)] (if (not (= (fail) Parse_shen-dot-<lrb>)) (clojure.core/let [Parse_shen-dot-<st_input1> (shen-dot-<st_input1> Parse_shen-dot-<lrb>)] (if (not (= (fail) Parse_shen-dot-<st_input1>)) (clojure.core/let [Parse_shen-dot-<rrb> (shen-dot-<rrb> Parse_shen-dot-<st_input1>)] (if (not (= (fail) Parse_shen-dot-<rrb>)) (clojure.core/let [Parse_shen-dot-<st_input2> (shen-dot-<st_input2> Parse_shen-dot-<rrb>)] (if (not (= (fail) Parse_shen-dot-<st_input2>)) (shen-dot-pair (hd Parse_shen-dot-<st_input2>) (shen-dot-package-macro (macroexpand (shen-dot-hdtl Parse_shen-dot-<st_input1>)) (shen-dot-hdtl Parse_shen-dot-<st_input2>))) (fail))) (fail))) (fail))) (fail)))] (if (= YaccParse (fail)) (clojure.core/let [YaccParse (clojure.core/let [Parse_shen-dot-<lcurly> (shen-dot-<lcurly> V2443)] (if (not (= (fail) Parse_shen-dot-<lcurly>)) (clojure.core/let [Parse_shen-dot-<st_input> (shen-dot-<st_input> Parse_shen-dot-<lcurly>)] (if (not (= (fail) Parse_shen-dot-<st_input>)) (shen-dot-pair (hd Parse_shen-dot-<st_input>) (cons (quote -lcurlybrac-) (shen-dot-hdtl Parse_shen-dot-<st_input>))) (fail))) (fail)))] (if (= YaccParse (fail)) (clojure.core/let [YaccParse (clojure.core/let [Parse_shen-dot-<rcurly> (shen-dot-<rcurly> V2443)] (if (not (= (fail) Parse_shen-dot-<rcurly>)) (clojure.core/let [Parse_shen-dot-<st_input> (shen-dot-<st_input> Parse_shen-dot-<rcurly>)] (if (not (= (fail) Parse_shen-dot-<st_input>)) (shen-dot-pair (hd Parse_shen-dot-<st_input>) (cons (quote -rcurlybrac-) (shen-dot-hdtl Parse_shen-dot-<st_input>))) (fail))) (fail)))] (if (= YaccParse (fail)) (clojure.core/let [YaccParse (clojure.core/let [Parse_shen-dot-<bar> (shen-dot-<bar> V2443)] (if (not (= (fail) Parse_shen-dot-<bar>)) (clojure.core/let [Parse_shen-dot-<st_input> (shen-dot-<st_input> Parse_shen-dot-<bar>)] (if (not (= (fail) Parse_shen-dot-<st_input>)) (shen-dot-pair (hd Parse_shen-dot-<st_input>) (cons (quote bar!) (shen-dot-hdtl Parse_shen-dot-<st_input>))) (fail))) (fail)))] (if (= YaccParse (fail)) (clojure.core/let [YaccParse (clojure.core/let [Parse_shen-dot-<semicolon> (shen-dot-<semicolon> V2443)] (if (not (= (fail) Parse_shen-dot-<semicolon>)) (clojure.core/let [Parse_shen-dot-<st_input> (shen-dot-<st_input> Parse_shen-dot-<semicolon>)] (if (not (= (fail) Parse_shen-dot-<st_input>)) (shen-dot-pair (hd Parse_shen-dot-<st_input>) (cons (quote -semicol-) (shen-dot-hdtl Parse_shen-dot-<st_input>))) (fail))) (fail)))] (if (= YaccParse (fail)) (clojure.core/let [YaccParse (clojure.core/let [Parse_shen-dot-<colon> (shen-dot-<colon> V2443)] (if (not (= (fail) Parse_shen-dot-<colon>)) (clojure.core/let [Parse_shen-dot-<equal> (shen-dot-<equal> Parse_shen-dot-<colon>)] (if (not (= (fail) Parse_shen-dot-<equal>)) (clojure.core/let [Parse_shen-dot-<st_input> (shen-dot-<st_input> Parse_shen-dot-<equal>)] (if (not (= (fail) Parse_shen-dot-<st_input>)) (shen-dot-pair (hd Parse_shen-dot-<st_input>) (cons (quote -colon-=) (shen-dot-hdtl Parse_shen-dot-<st_input>))) (fail))) (fail))) (fail)))] (if (= YaccParse (fail)) (clojure.core/let [YaccParse (clojure.core/let [Parse_shen-dot-<colon> (shen-dot-<colon> V2443)] (if (not (= (fail) Parse_shen-dot-<colon>)) (clojure.core/let [Parse_shen-dot-<minus> (shen-dot-<minus> Parse_shen-dot-<colon>)] (if (not (= (fail) Parse_shen-dot-<minus>)) (clojure.core/let [Parse_shen-dot-<st_input> (shen-dot-<st_input> Parse_shen-dot-<minus>)] (if (not (= (fail) Parse_shen-dot-<st_input>)) (shen-dot-pair (hd Parse_shen-dot-<st_input>) (cons (quote -colon--) (shen-dot-hdtl Parse_shen-dot-<st_input>))) (fail))) (fail))) (fail)))] (if (= YaccParse (fail)) (clojure.core/let [YaccParse (clojure.core/let [Parse_shen-dot-<colon> (shen-dot-<colon> V2443)] (if (not (= (fail) Parse_shen-dot-<colon>)) (clojure.core/let [Parse_shen-dot-<st_input> (shen-dot-<st_input> Parse_shen-dot-<colon>)] (if (not (= (fail) Parse_shen-dot-<st_input>)) (shen-dot-pair (hd Parse_shen-dot-<st_input>) (cons (quote -colon-) (shen-dot-hdtl Parse_shen-dot-<st_input>))) (fail))) (fail)))] (if (= YaccParse (fail)) (clojure.core/let [YaccParse (clojure.core/let [Parse_shen-dot-<comma> (shen-dot-<comma> V2443)] (if (not (= (fail) Parse_shen-dot-<comma>)) (clojure.core/let [Parse_shen-dot-<st_input> (shen-dot-<st_input> Parse_shen-dot-<comma>)] (if (not (= (fail) Parse_shen-dot-<st_input>)) (shen-dot-pair (hd Parse_shen-dot-<st_input>) (cons (intern ",") (shen-dot-hdtl Parse_shen-dot-<st_input>))) (fail))) (fail)))] (if (= YaccParse (fail)) (clojure.core/let [YaccParse (clojure.core/let [Parse_shen-dot-<comment> (shen-dot-<comment> V2443)] (if (not (= (fail) Parse_shen-dot-<comment>)) (clojure.core/let [Parse_shen-dot-<st_input> (shen-dot-<st_input> Parse_shen-dot-<comment>)] (if (not (= (fail) Parse_shen-dot-<st_input>)) (shen-dot-pair (hd Parse_shen-dot-<st_input>) (shen-dot-hdtl Parse_shen-dot-<st_input>)) (fail))) (fail)))] (if (= YaccParse (fail)) (clojure.core/let [YaccParse (clojure.core/let [Parse_shen-dot-<atom> (shen-dot-<atom> V2443)] (if (not (= (fail) Parse_shen-dot-<atom>)) (clojure.core/let [Parse_shen-dot-<st_input> (shen-dot-<st_input> Parse_shen-dot-<atom>)] (if (not (= (fail) Parse_shen-dot-<st_input>)) (shen-dot-pair (hd Parse_shen-dot-<st_input>) (cons (macroexpand (shen-dot-hdtl Parse_shen-dot-<atom>)) (shen-dot-hdtl Parse_shen-dot-<st_input>))) (fail))) (fail)))] (if (= YaccParse (fail)) (clojure.core/let [YaccParse (clojure.core/let [Parse_shen-dot-<whitespaces> (shen-dot-<whitespaces> V2443)] (if (not (= (fail) Parse_shen-dot-<whitespaces>)) (clojure.core/let [Parse_shen-dot-<st_input> (shen-dot-<st_input> Parse_shen-dot-<whitespaces>)] (if (not (= (fail) Parse_shen-dot-<st_input>)) (shen-dot-pair (hd Parse_shen-dot-<st_input>) (shen-dot-hdtl Parse_shen-dot-<st_input>)) (fail))) (fail)))] (if (= YaccParse (fail)) (clojure.core/let [Parse_<e> (<e> V2443)] (if (not (= (fail) Parse_<e>)) (shen-dot-pair (hd Parse_<e>) ()) (fail))) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? hd = shen-dot-pair tl shen-dot-hdtl fail) (clojure.core/defn shen-dot-<lsb> [V2445] (if (clojure.core/and (cons? (hd V2445)) (= 91 (hd (hd V2445)))) (shen-dot-pair (hd (shen-dot-pair (tl (hd V2445)) (shen-dot-hdtl V2445))) (quote shen-dot-skip)) (fail)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? hd = shen-dot-pair tl shen-dot-hdtl fail) (clojure.core/defn shen-dot-<rsb> [V2447] (if (clojure.core/and (cons? (hd V2447)) (= 93 (hd (hd V2447)))) (shen-dot-pair (hd (shen-dot-pair (tl (hd V2447)) (shen-dot-hdtl V2447))) (quote shen-dot-skip)) (fail)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? hd = shen-dot-pair tl shen-dot-hdtl fail) (clojure.core/defn shen-dot-<lcurly> [V2449] (if (clojure.core/and (cons? (hd V2449)) (= 123 (hd (hd V2449)))) (shen-dot-pair (hd (shen-dot-pair (tl (hd V2449)) (shen-dot-hdtl V2449))) (quote shen-dot-skip)) (fail)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? hd = shen-dot-pair tl shen-dot-hdtl fail) (clojure.core/defn shen-dot-<rcurly> [V2451] (if (clojure.core/and (cons? (hd V2451)) (= 125 (hd (hd V2451)))) (shen-dot-pair (hd (shen-dot-pair (tl (hd V2451)) (shen-dot-hdtl V2451))) (quote shen-dot-skip)) (fail)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? hd = shen-dot-pair tl shen-dot-hdtl fail) (clojure.core/defn shen-dot-<bar> [V2453] (if (clojure.core/and (cons? (hd V2453)) (= 124 (hd (hd V2453)))) (shen-dot-pair (hd (shen-dot-pair (tl (hd V2453)) (shen-dot-hdtl V2453))) (quote shen-dot-skip)) (fail)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? hd = shen-dot-pair tl shen-dot-hdtl fail) (clojure.core/defn shen-dot-<semicolon> [V2455] (if (clojure.core/and (cons? (hd V2455)) (= 59 (hd (hd V2455)))) (shen-dot-pair (hd (shen-dot-pair (tl (hd V2455)) (shen-dot-hdtl V2455))) (quote shen-dot-skip)) (fail)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? hd = shen-dot-pair tl shen-dot-hdtl fail) (clojure.core/defn shen-dot-<colon> [V2457] (if (clojure.core/and (cons? (hd V2457)) (= 58 (hd (hd V2457)))) (shen-dot-pair (hd (shen-dot-pair (tl (hd V2457)) (shen-dot-hdtl V2457))) (quote shen-dot-skip)) (fail)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? hd = shen-dot-pair tl shen-dot-hdtl fail) (clojure.core/defn shen-dot-<comma> [V2459] (if (clojure.core/and (cons? (hd V2459)) (= 44 (hd (hd V2459)))) (shen-dot-pair (hd (shen-dot-pair (tl (hd V2459)) (shen-dot-hdtl V2459))) (quote shen-dot-skip)) (fail)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? hd = shen-dot-pair tl shen-dot-hdtl fail) (clojure.core/defn shen-dot-<equal> [V2461] (if (clojure.core/and (cons? (hd V2461)) (= 61 (hd (hd V2461)))) (shen-dot-pair (hd (shen-dot-pair (tl (hd V2461)) (shen-dot-hdtl V2461))) (quote shen-dot-skip)) (fail)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? hd = shen-dot-pair tl shen-dot-hdtl fail) (clojure.core/defn shen-dot-<minus> [V2463] (if (clojure.core/and (cons? (hd V2463)) (= 45 (hd (hd V2463)))) (shen-dot-pair (hd (shen-dot-pair (tl (hd V2463)) (shen-dot-hdtl V2463))) (quote shen-dot-skip)) (fail)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? hd = shen-dot-pair tl shen-dot-hdtl fail) (clojure.core/defn shen-dot-<lrb> [V2465] (if (clojure.core/and (cons? (hd V2465)) (= 40 (hd (hd V2465)))) (shen-dot-pair (hd (shen-dot-pair (tl (hd V2465)) (shen-dot-hdtl V2465))) (quote shen-dot-skip)) (fail)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? hd = shen-dot-pair tl shen-dot-hdtl fail) (clojure.core/defn shen-dot-<rrb> [V2467] (if (clojure.core/and (cons? (hd V2467)) (= 41 (hd (hd V2467)))) (shen-dot-pair (hd (shen-dot-pair (tl (hd V2467)) (shen-dot-hdtl V2467))) (quote shen-dot-skip)) (fail)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-<str> not = fail shen-dot-pair hd shen-dot-control-chars shen-dot-hdtl shen-dot-<number> shen-dot-<sym> cons intern) (clojure.core/defn shen-dot-<atom> [V2469] (clojure.core/let [YaccParse (clojure.core/let [Parse_shen-dot-<str> (shen-dot-<str> V2469)] (if (not (= (fail) Parse_shen-dot-<str>)) (shen-dot-pair (hd Parse_shen-dot-<str>) (shen-dot-control-chars (shen-dot-hdtl Parse_shen-dot-<str>))) (fail)))] (if (= YaccParse (fail)) (clojure.core/let [YaccParse (clojure.core/let [Parse_shen-dot-<number> (shen-dot-<number> V2469)] (if (not (= (fail) Parse_shen-dot-<number>)) (shen-dot-pair (hd Parse_shen-dot-<number>) (shen-dot-hdtl Parse_shen-dot-<number>)) (fail)))] (if (= YaccParse (fail)) (clojure.core/let [Parse_shen-dot-<sym> (shen-dot-<sym> V2469)] (if (not (= (fail) Parse_shen-dot-<sym>)) (shen-dot-pair (hd Parse_shen-dot-<sym>) (if (= (shen-dot-hdtl Parse_shen-dot-<sym>) "<>") (cons (quote vector) (cons 0 ())) (intern (shen-dot-hdtl Parse_shen-dot-<sym>)))) (fail))) YaccParse)) YaccParse)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare = cons? hd tl shen-dot-code-point shen-dot-after-codepoint -at-s n->string shen-dot-decimalise shen-dot-control-chars shen-dot-f_error) (clojure.core/defn shen-dot-control-chars [V2471] (clojure.core/cond (= () V2471) "" (clojure.core/and (cons? V2471) (clojure.core/and (= "c" (hd V2471)) (clojure.core/and (cons? (tl V2471)) (= "#" (hd (tl V2471)))))) (clojure.core/let [CodePoint (shen-dot-code-point (tl (tl V2471)))] (clojure.core/let [AfterCodePoint (shen-dot-after-codepoint (tl (tl V2471)))] (-at-s (n->string (shen-dot-decimalise CodePoint)) (shen-dot-control-chars AfterCodePoint)))) (cons? V2471) (-at-s (hd V2471) (shen-dot-control-chars (tl V2471))) true (shen-dot-f_error (quote shen-dot-control-chars)) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? = hd element? cons shen-dot-code-point tl simple-error cn shen-dot-app) (clojure.core/defn shen-dot-code-point [V2475] (clojure.core/cond (clojure.core/and (cons? V2475) (= ";" (hd V2475))) "" (clojure.core/and (cons? V2475) (element? (hd V2475) (cons "0" (cons "1" (cons "2" (cons "3" (cons "4" (cons "5" (cons "6" (cons "7" (cons "8" (cons "9" (cons "0" ()))))))))))))) (cons (hd V2475) (shen-dot-code-point (tl V2475))) true (simple-error (cn "code point parse error " (shen-dot-app V2475 "\n" (quote shen-dot-a)))) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare = cons? hd tl shen-dot-after-codepoint shen-dot-f_error) (clojure.core/defn shen-dot-after-codepoint [V2481] (clojure.core/cond (= () V2481) () (clojure.core/and (cons? V2481) (= ";" (hd V2481))) (tl V2481) (cons? V2481) (shen-dot-after-codepoint (tl V2481)) true (shen-dot-f_error (quote shen-dot-after-codepoint)) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-pre reverse shen-dot-digits->integers) (clojure.core/defn shen-dot-decimalise [V2483] (shen-dot-pre (reverse (shen-dot-digits->integers V2483)) 0))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? = hd cons shen-dot-digits->integers tl) (clojure.core/defn shen-dot-digits->integers [V2489] (clojure.core/cond (clojure.core/and (cons? V2489) (= "0" (hd V2489))) (cons 0 (shen-dot-digits->integers (tl V2489))) (clojure.core/and (cons? V2489) (= "1" (hd V2489))) (cons 1 (shen-dot-digits->integers (tl V2489))) (clojure.core/and (cons? V2489) (= "2" (hd V2489))) (cons 2 (shen-dot-digits->integers (tl V2489))) (clojure.core/and (cons? V2489) (= "3" (hd V2489))) (cons 3 (shen-dot-digits->integers (tl V2489))) (clojure.core/and (cons? V2489) (= "4" (hd V2489))) (cons 4 (shen-dot-digits->integers (tl V2489))) (clojure.core/and (cons? V2489) (= "5" (hd V2489))) (cons 5 (shen-dot-digits->integers (tl V2489))) (clojure.core/and (cons? V2489) (= "6" (hd V2489))) (cons 6 (shen-dot-digits->integers (tl V2489))) (clojure.core/and (cons? V2489) (= "7" (hd V2489))) (cons 7 (shen-dot-digits->integers (tl V2489))) (clojure.core/and (cons? V2489) (= "8" (hd V2489))) (cons 8 (shen-dot-digits->integers (tl V2489))) (clojure.core/and (cons? V2489) (= "9" (hd V2489))) (cons 9 (shen-dot-digits->integers (tl V2489))) true () :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-<alpha> not = fail shen-dot-<alphanums> shen-dot-pair hd -at-s shen-dot-hdtl) (clojure.core/defn shen-dot-<sym> [V2491] (clojure.core/let [Parse_shen-dot-<alpha> (shen-dot-<alpha> V2491)] (if (not (= (fail) Parse_shen-dot-<alpha>)) (clojure.core/let [Parse_shen-dot-<alphanums> (shen-dot-<alphanums> Parse_shen-dot-<alpha>)] (if (not (= (fail) Parse_shen-dot-<alphanums>)) (shen-dot-pair (hd Parse_shen-dot-<alphanums>) (-at-s (shen-dot-hdtl Parse_shen-dot-<alpha>) (shen-dot-hdtl Parse_shen-dot-<alphanums>))) (fail))) (fail))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-<alphanum> not = fail shen-dot-<alphanums> shen-dot-pair hd -at-s shen-dot-hdtl <e>) (clojure.core/defn shen-dot-<alphanums> [V2493] (clojure.core/let [YaccParse (clojure.core/let [Parse_shen-dot-<alphanum> (shen-dot-<alphanum> V2493)] (if (not (= (fail) Parse_shen-dot-<alphanum>)) (clojure.core/let [Parse_shen-dot-<alphanums> (shen-dot-<alphanums> Parse_shen-dot-<alphanum>)] (if (not (= (fail) Parse_shen-dot-<alphanums>)) (shen-dot-pair (hd Parse_shen-dot-<alphanums>) (-at-s (shen-dot-hdtl Parse_shen-dot-<alphanum>) (shen-dot-hdtl Parse_shen-dot-<alphanums>))) (fail))) (fail)))] (if (= YaccParse (fail)) (clojure.core/let [Parse_<e> (<e> V2493)] (if (not (= (fail) Parse_<e>)) (shen-dot-pair (hd Parse_<e>) "") (fail))) YaccParse)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-<alpha> not = fail shen-dot-pair hd shen-dot-hdtl shen-dot-<num>) (clojure.core/defn shen-dot-<alphanum> [V2495] (clojure.core/let [YaccParse (clojure.core/let [Parse_shen-dot-<alpha> (shen-dot-<alpha> V2495)] (if (not (= (fail) Parse_shen-dot-<alpha>)) (shen-dot-pair (hd Parse_shen-dot-<alpha>) (shen-dot-hdtl Parse_shen-dot-<alpha>)) (fail)))] (if (= YaccParse (fail)) (clojure.core/let [Parse_shen-dot-<num> (shen-dot-<num> V2495)] (if (not (= (fail) Parse_shen-dot-<num>)) (shen-dot-pair (hd Parse_shen-dot-<num>) (shen-dot-hdtl Parse_shen-dot-<num>)) (fail))) YaccParse)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? hd shen-dot-numbyte? shen-dot-pair tl shen-dot-hdtl n->string fail) (clojure.core/defn shen-dot-<num> [V2497] (if (cons? (hd V2497)) (clojure.core/let [Parse_Char (hd (hd V2497))] (if (shen-dot-numbyte? Parse_Char) (shen-dot-pair (hd (shen-dot-pair (tl (hd V2497)) (shen-dot-hdtl V2497))) (n->string Parse_Char)) (fail))) (fail)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare =) (clojure.core/defn shen-dot-numbyte? [V2503] (clojure.core/cond (= 48 V2503) true (= 49 V2503) true (= 50 V2503) true (= 51 V2503) true (= 52 V2503) true (= 53 V2503) true (= 54 V2503) true (= 55 V2503) true (= 56 V2503) true (= 57 V2503) true true false :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? hd shen-dot-symbol-code? shen-dot-pair tl shen-dot-hdtl n->string fail) (clojure.core/defn shen-dot-<alpha> [V2505] (if (cons? (hd V2505)) (clojure.core/let [Parse_Char (hd (hd V2505))] (if (shen-dot-symbol-code? Parse_Char) (shen-dot-pair (hd (shen-dot-pair (tl (hd V2505)) (shen-dot-hdtl V2505))) (n->string Parse_Char)) (fail))) (fail)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare = > < not) (clojure.core/defn shen-dot-symbol-code? [V2507] (clojure.core/or (= V2507 126) (clojure.core/or (clojure.core/and (> V2507 94) (< V2507 123)) (clojure.core/or (clojure.core/and (> V2507 59) (< V2507 91)) (clojure.core/or (clojure.core/and (> V2507 41) (clojure.core/and (< V2507 58) (not (= V2507 44)))) (clojure.core/or (clojure.core/and (> V2507 34) (< V2507 40)) (= V2507 33)))))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-<dbq> not = fail shen-dot-<strcontents> shen-dot-pair hd shen-dot-hdtl) (clojure.core/defn shen-dot-<str> [V2509] (clojure.core/let [Parse_shen-dot-<dbq> (shen-dot-<dbq> V2509)] (if (not (= (fail) Parse_shen-dot-<dbq>)) (clojure.core/let [Parse_shen-dot-<strcontents> (shen-dot-<strcontents> Parse_shen-dot-<dbq>)] (if (not (= (fail) Parse_shen-dot-<strcontents>)) (clojure.core/let [Parse_shen-dot-<dbq> (shen-dot-<dbq> Parse_shen-dot-<strcontents>)] (if (not (= (fail) Parse_shen-dot-<dbq>)) (shen-dot-pair (hd Parse_shen-dot-<dbq>) (shen-dot-hdtl Parse_shen-dot-<strcontents>)) (fail))) (fail))) (fail))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? hd = shen-dot-pair tl shen-dot-hdtl fail) (clojure.core/defn shen-dot-<dbq> [V2511] (if (cons? (hd V2511)) (clojure.core/let [Parse_Char (hd (hd V2511))] (if (= Parse_Char 34) (shen-dot-pair (hd (shen-dot-pair (tl (hd V2511)) (shen-dot-hdtl V2511))) Parse_Char) (fail))) (fail)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-<strc> not = fail shen-dot-<strcontents> shen-dot-pair hd cons shen-dot-hdtl <e>) (clojure.core/defn shen-dot-<strcontents> [V2513] (clojure.core/let [YaccParse (clojure.core/let [Parse_shen-dot-<strc> (shen-dot-<strc> V2513)] (if (not (= (fail) Parse_shen-dot-<strc>)) (clojure.core/let [Parse_shen-dot-<strcontents> (shen-dot-<strcontents> Parse_shen-dot-<strc>)] (if (not (= (fail) Parse_shen-dot-<strcontents>)) (shen-dot-pair (hd Parse_shen-dot-<strcontents>) (cons (shen-dot-hdtl Parse_shen-dot-<strc>) (shen-dot-hdtl Parse_shen-dot-<strcontents>))) (fail))) (fail)))] (if (= YaccParse (fail)) (clojure.core/let [Parse_<e> (<e> V2513)] (if (not (= (fail) Parse_<e>)) (shen-dot-pair (hd Parse_<e>) ()) (fail))) YaccParse)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? hd shen-dot-pair tl shen-dot-hdtl n->string fail) (clojure.core/defn shen-dot-<byte> [V2515] (if (cons? (hd V2515)) (clojure.core/let [Parse_Char (hd (hd V2515))] (shen-dot-pair (hd (shen-dot-pair (tl (hd V2515)) (shen-dot-hdtl V2515))) (n->string Parse_Char))) (fail)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? hd not = shen-dot-pair tl shen-dot-hdtl n->string fail) (clojure.core/defn shen-dot-<strc> [V2517] (if (cons? (hd V2517)) (clojure.core/let [Parse_Char (hd (hd V2517))] (if (not (= Parse_Char 34)) (shen-dot-pair (hd (shen-dot-pair (tl (hd V2517)) (shen-dot-hdtl V2517))) (n->string Parse_Char)) (fail))) (fail)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-<minus> not = fail shen-dot-<number> shen-dot-pair hd - shen-dot-hdtl shen-dot-<plus> shen-dot-<predigits> shen-dot-<stop> shen-dot-<postdigits> shen-dot-<E> shen-dot-<log10> * shen-dot-expt + shen-dot-pre reverse shen-dot-post shen-dot-<digits>) (clojure.core/defn shen-dot-<number> [V2519] (clojure.core/let [YaccParse (clojure.core/let [Parse_shen-dot-<minus> (shen-dot-<minus> V2519)] (if (not (= (fail) Parse_shen-dot-<minus>)) (clojure.core/let [Parse_shen-dot-<number> (shen-dot-<number> Parse_shen-dot-<minus>)] (if (not (= (fail) Parse_shen-dot-<number>)) (shen-dot-pair (hd Parse_shen-dot-<number>) (- 0 (shen-dot-hdtl Parse_shen-dot-<number>))) (fail))) (fail)))] (if (= YaccParse (fail)) (clojure.core/let [YaccParse (clojure.core/let [Parse_shen-dot-<plus> (shen-dot-<plus> V2519)] (if (not (= (fail) Parse_shen-dot-<plus>)) (clojure.core/let [Parse_shen-dot-<number> (shen-dot-<number> Parse_shen-dot-<plus>)] (if (not (= (fail) Parse_shen-dot-<number>)) (shen-dot-pair (hd Parse_shen-dot-<number>) (shen-dot-hdtl Parse_shen-dot-<number>)) (fail))) (fail)))] (if (= YaccParse (fail)) (clojure.core/let [YaccParse (clojure.core/let [Parse_shen-dot-<predigits> (shen-dot-<predigits> V2519)] (if (not (= (fail) Parse_shen-dot-<predigits>)) (clojure.core/let [Parse_shen-dot-<stop> (shen-dot-<stop> Parse_shen-dot-<predigits>)] (if (not (= (fail) Parse_shen-dot-<stop>)) (clojure.core/let [Parse_shen-dot-<postdigits> (shen-dot-<postdigits> Parse_shen-dot-<stop>)] (if (not (= (fail) Parse_shen-dot-<postdigits>)) (clojure.core/let [Parse_shen-dot-<E> (shen-dot-<E> Parse_shen-dot-<postdigits>)] (if (not (= (fail) Parse_shen-dot-<E>)) (clojure.core/let [Parse_shen-dot-<log10> (shen-dot-<log10> Parse_shen-dot-<E>)] (if (not (= (fail) Parse_shen-dot-<log10>)) (shen-dot-pair (hd Parse_shen-dot-<log10>) (* (shen-dot-expt 10 (shen-dot-hdtl Parse_shen-dot-<log10>)) (+ (shen-dot-pre (reverse (shen-dot-hdtl Parse_shen-dot-<predigits>)) 0) (shen-dot-post (shen-dot-hdtl Parse_shen-dot-<postdigits>) 1)))) (fail))) (fail))) (fail))) (fail))) (fail)))] (if (= YaccParse (fail)) (clojure.core/let [YaccParse (clojure.core/let [Parse_shen-dot-<digits> (shen-dot-<digits> V2519)] (if (not (= (fail) Parse_shen-dot-<digits>)) (clojure.core/let [Parse_shen-dot-<E> (shen-dot-<E> Parse_shen-dot-<digits>)] (if (not (= (fail) Parse_shen-dot-<E>)) (clojure.core/let [Parse_shen-dot-<log10> (shen-dot-<log10> Parse_shen-dot-<E>)] (if (not (= (fail) Parse_shen-dot-<log10>)) (shen-dot-pair (hd Parse_shen-dot-<log10>) (* (shen-dot-expt 10 (shen-dot-hdtl Parse_shen-dot-<log10>)) (shen-dot-pre (reverse (shen-dot-hdtl Parse_shen-dot-<digits>)) 0))) (fail))) (fail))) (fail)))] (if (= YaccParse (fail)) (clojure.core/let [YaccParse (clojure.core/let [Parse_shen-dot-<predigits> (shen-dot-<predigits> V2519)] (if (not (= (fail) Parse_shen-dot-<predigits>)) (clojure.core/let [Parse_shen-dot-<stop> (shen-dot-<stop> Parse_shen-dot-<predigits>)] (if (not (= (fail) Parse_shen-dot-<stop>)) (clojure.core/let [Parse_shen-dot-<postdigits> (shen-dot-<postdigits> Parse_shen-dot-<stop>)] (if (not (= (fail) Parse_shen-dot-<postdigits>)) (shen-dot-pair (hd Parse_shen-dot-<postdigits>) (+ (shen-dot-pre (reverse (shen-dot-hdtl Parse_shen-dot-<predigits>)) 0) (shen-dot-post (shen-dot-hdtl Parse_shen-dot-<postdigits>) 1))) (fail))) (fail))) (fail)))] (if (= YaccParse (fail)) (clojure.core/let [Parse_shen-dot-<digits> (shen-dot-<digits> V2519)] (if (not (= (fail) Parse_shen-dot-<digits>)) (shen-dot-pair (hd Parse_shen-dot-<digits>) (shen-dot-pre (reverse (shen-dot-hdtl Parse_shen-dot-<digits>)) 0)) (fail))) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? hd = shen-dot-pair tl shen-dot-hdtl fail) (clojure.core/defn shen-dot-<E> [V2521] (if (clojure.core/and (cons? (hd V2521)) (= 101 (hd (hd V2521)))) (shen-dot-pair (hd (shen-dot-pair (tl (hd V2521)) (shen-dot-hdtl V2521))) (quote shen-dot-skip)) (fail)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-<minus> not = fail shen-dot-<digits> shen-dot-pair hd - shen-dot-pre reverse shen-dot-hdtl) (clojure.core/defn shen-dot-<log10> [V2523] (clojure.core/let [YaccParse (clojure.core/let [Parse_shen-dot-<minus> (shen-dot-<minus> V2523)] (if (not (= (fail) Parse_shen-dot-<minus>)) (clojure.core/let [Parse_shen-dot-<digits> (shen-dot-<digits> Parse_shen-dot-<minus>)] (if (not (= (fail) Parse_shen-dot-<digits>)) (shen-dot-pair (hd Parse_shen-dot-<digits>) (- 0 (shen-dot-pre (reverse (shen-dot-hdtl Parse_shen-dot-<digits>)) 0))) (fail))) (fail)))] (if (= YaccParse (fail)) (clojure.core/let [Parse_shen-dot-<digits> (shen-dot-<digits> V2523)] (if (not (= (fail) Parse_shen-dot-<digits>)) (shen-dot-pair (hd Parse_shen-dot-<digits>) (shen-dot-pre (reverse (shen-dot-hdtl Parse_shen-dot-<digits>)) 0)) (fail))) YaccParse)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? hd = shen-dot-pair tl shen-dot-hdtl fail) (clojure.core/defn shen-dot-<plus> [V2525] (if (cons? (hd V2525)) (clojure.core/let [Parse_Char (hd (hd V2525))] (if (= Parse_Char 43) (shen-dot-pair (hd (shen-dot-pair (tl (hd V2525)) (shen-dot-hdtl V2525))) Parse_Char) (fail))) (fail)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? hd = shen-dot-pair tl shen-dot-hdtl fail) (clojure.core/defn shen-dot-<stop> [V2527] (if (cons? (hd V2527)) (clojure.core/let [Parse_Char (hd (hd V2527))] (if (= Parse_Char 46) (shen-dot-pair (hd (shen-dot-pair (tl (hd V2527)) (shen-dot-hdtl V2527))) Parse_Char) (fail))) (fail)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-<digits> not = fail shen-dot-pair hd shen-dot-hdtl <e>) (clojure.core/defn shen-dot-<predigits> [V2529] (clojure.core/let [YaccParse (clojure.core/let [Parse_shen-dot-<digits> (shen-dot-<digits> V2529)] (if (not (= (fail) Parse_shen-dot-<digits>)) (shen-dot-pair (hd Parse_shen-dot-<digits>) (shen-dot-hdtl Parse_shen-dot-<digits>)) (fail)))] (if (= YaccParse (fail)) (clojure.core/let [Parse_<e> (<e> V2529)] (if (not (= (fail) Parse_<e>)) (shen-dot-pair (hd Parse_<e>) ()) (fail))) YaccParse)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-<digits> not = fail shen-dot-pair hd shen-dot-hdtl) (clojure.core/defn shen-dot-<postdigits> [V2531] (clojure.core/let [Parse_shen-dot-<digits> (shen-dot-<digits> V2531)] (if (not (= (fail) Parse_shen-dot-<digits>)) (shen-dot-pair (hd Parse_shen-dot-<digits>) (shen-dot-hdtl Parse_shen-dot-<digits>)) (fail))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-<digit> not = fail shen-dot-<digits> shen-dot-pair hd cons shen-dot-hdtl) (clojure.core/defn shen-dot-<digits> [V2533] (clojure.core/let [YaccParse (clojure.core/let [Parse_shen-dot-<digit> (shen-dot-<digit> V2533)] (if (not (= (fail) Parse_shen-dot-<digit>)) (clojure.core/let [Parse_shen-dot-<digits> (shen-dot-<digits> Parse_shen-dot-<digit>)] (if (not (= (fail) Parse_shen-dot-<digits>)) (shen-dot-pair (hd Parse_shen-dot-<digits>) (cons (shen-dot-hdtl Parse_shen-dot-<digit>) (shen-dot-hdtl Parse_shen-dot-<digits>))) (fail))) (fail)))] (if (= YaccParse (fail)) (clojure.core/let [Parse_shen-dot-<digit> (shen-dot-<digit> V2533)] (if (not (= (fail) Parse_shen-dot-<digit>)) (shen-dot-pair (hd Parse_shen-dot-<digit>) (cons (shen-dot-hdtl Parse_shen-dot-<digit>) ())) (fail))) YaccParse)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? hd shen-dot-numbyte? shen-dot-pair tl shen-dot-hdtl shen-dot-byte->digit fail) (clojure.core/defn shen-dot-<digit> [V2535] (if (cons? (hd V2535)) (clojure.core/let [Parse_X (hd (hd V2535))] (if (shen-dot-numbyte? Parse_X) (shen-dot-pair (hd (shen-dot-pair (tl (hd V2535)) (shen-dot-hdtl V2535))) (shen-dot-byte->digit Parse_X)) (fail))) (fail)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare = shen-dot-f_error) (clojure.core/defn shen-dot-byte->digit [V2537] (clojure.core/cond (= 48 V2537) 0 (= 49 V2537) 1 (= 50 V2537) 2 (= 51 V2537) 3 (= 52 V2537) 4 (= 53 V2537) 5 (= 54 V2537) 6 (= 55 V2537) 7 (= 56 V2537) 8 (= 57 V2537) 9 true (shen-dot-f_error (quote shen-dot-byte->digit)) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-pre [V2542 V2543] (clojure.core/cond (= () V2542) 0 (cons? V2542) (+ (* (shen-dot-expt 10 V2543) (hd V2542)) (shen-dot-pre (tl V2542) (+ V2543 1))) true (shen-dot-f_error (quote shen-dot-pre)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-post [V2548 V2549] (clojure.core/cond (= () V2548) 0 (cons? V2548) (+ (* (shen-dot-expt 10 (- 0 V2549)) (hd V2548)) (shen-dot-post (tl V2548) (+ V2549 1))) true (shen-dot-f_error (quote shen-dot-post)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-expt [V2554 V2555] (clojure.core/cond (= 0 V2555) 1 (> V2555 0) (* V2554 (shen-dot-expt V2554 (- V2555 1))) true (* 1 (/ (shen-dot-expt V2554 (+ V2555 1)) V2554)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-<st_input> not = fail shen-dot-pair hd shen-dot-hdtl) (clojure.core/defn shen-dot-<st_input1> [V2557] (clojure.core/let [Parse_shen-dot-<st_input> (shen-dot-<st_input> V2557)] (if (not (= (fail) Parse_shen-dot-<st_input>)) (shen-dot-pair (hd Parse_shen-dot-<st_input>) (shen-dot-hdtl Parse_shen-dot-<st_input>)) (fail))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-<st_input> not = fail shen-dot-pair hd shen-dot-hdtl) (clojure.core/defn shen-dot-<st_input2> [V2559] (clojure.core/let [Parse_shen-dot-<st_input> (shen-dot-<st_input> V2559)] (if (not (= (fail) Parse_shen-dot-<st_input>)) (shen-dot-pair (hd Parse_shen-dot-<st_input>) (shen-dot-hdtl Parse_shen-dot-<st_input>)) (fail))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-<singleline> not = fail shen-dot-pair hd shen-dot-<multiline>) (clojure.core/defn shen-dot-<comment> [V2561] (clojure.core/let [YaccParse (clojure.core/let [Parse_shen-dot-<singleline> (shen-dot-<singleline> V2561)] (if (not (= (fail) Parse_shen-dot-<singleline>)) (shen-dot-pair (hd Parse_shen-dot-<singleline>) (quote shen-dot-skip)) (fail)))] (if (= YaccParse (fail)) (clojure.core/let [Parse_shen-dot-<multiline> (shen-dot-<multiline> V2561)] (if (not (= (fail) Parse_shen-dot-<multiline>)) (shen-dot-pair (hd Parse_shen-dot-<multiline>) (quote shen-dot-skip)) (fail))) YaccParse)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-<backslash> not = fail shen-dot-<anysingle> shen-dot-<return> shen-dot-pair hd) (clojure.core/defn shen-dot-<singleline> [V2563] (clojure.core/let [Parse_shen-dot-<backslash> (shen-dot-<backslash> V2563)] (if (not (= (fail) Parse_shen-dot-<backslash>)) (clojure.core/let [Parse_shen-dot-<backslash> (shen-dot-<backslash> Parse_shen-dot-<backslash>)] (if (not (= (fail) Parse_shen-dot-<backslash>)) (clojure.core/let [Parse_shen-dot-<anysingle> (shen-dot-<anysingle> Parse_shen-dot-<backslash>)] (if (not (= (fail) Parse_shen-dot-<anysingle>)) (clojure.core/let [Parse_shen-dot-<return> (shen-dot-<return> Parse_shen-dot-<anysingle>)] (if (not (= (fail) Parse_shen-dot-<return>)) (shen-dot-pair (hd Parse_shen-dot-<return>) (quote shen-dot-skip)) (fail))) (fail))) (fail))) (fail))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? hd = shen-dot-pair tl shen-dot-hdtl fail) (clojure.core/defn shen-dot-<backslash> [V2565] (if (clojure.core/and (cons? (hd V2565)) (= 92 (hd (hd V2565)))) (shen-dot-pair (hd (shen-dot-pair (tl (hd V2565)) (shen-dot-hdtl V2565))) (quote shen-dot-skip)) (fail)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-<non-return> not = fail shen-dot-<anysingle> shen-dot-pair hd <e>) (clojure.core/defn shen-dot-<anysingle> [V2567] (clojure.core/let [YaccParse (clojure.core/let [Parse_shen-dot-<non-return> (shen-dot-<non-return> V2567)] (if (not (= (fail) Parse_shen-dot-<non-return>)) (clojure.core/let [Parse_shen-dot-<anysingle> (shen-dot-<anysingle> Parse_shen-dot-<non-return>)] (if (not (= (fail) Parse_shen-dot-<anysingle>)) (shen-dot-pair (hd Parse_shen-dot-<anysingle>) (quote shen-dot-skip)) (fail))) (fail)))] (if (= YaccParse (fail)) (clojure.core/let [Parse_<e> (<e> V2567)] (if (not (= (fail) Parse_<e>)) (shen-dot-pair (hd Parse_<e>) (quote shen-dot-skip)) (fail))) YaccParse)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? hd not element? cons shen-dot-pair tl shen-dot-hdtl fail) (clojure.core/defn shen-dot-<non-return> [V2569] (if (cons? (hd V2569)) (clojure.core/let [Parse_X (hd (hd V2569))] (if (not (element? Parse_X (cons 10 (cons 13 ())))) (shen-dot-pair (hd (shen-dot-pair (tl (hd V2569)) (shen-dot-hdtl V2569))) (quote shen-dot-skip)) (fail))) (fail)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? hd element? cons shen-dot-pair tl shen-dot-hdtl fail) (clojure.core/defn shen-dot-<return> [V2571] (if (cons? (hd V2571)) (clojure.core/let [Parse_X (hd (hd V2571))] (if (element? Parse_X (cons 10 (cons 13 ()))) (shen-dot-pair (hd (shen-dot-pair (tl (hd V2571)) (shen-dot-hdtl V2571))) (quote shen-dot-skip)) (fail))) (fail)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-<backslash> not = fail shen-dot-<times> shen-dot-<anymulti> shen-dot-pair hd) (clojure.core/defn shen-dot-<multiline> [V2573] (clojure.core/let [Parse_shen-dot-<backslash> (shen-dot-<backslash> V2573)] (if (not (= (fail) Parse_shen-dot-<backslash>)) (clojure.core/let [Parse_shen-dot-<times> (shen-dot-<times> Parse_shen-dot-<backslash>)] (if (not (= (fail) Parse_shen-dot-<times>)) (clojure.core/let [Parse_shen-dot-<anymulti> (shen-dot-<anymulti> Parse_shen-dot-<times>)] (if (not (= (fail) Parse_shen-dot-<anymulti>)) (shen-dot-pair (hd Parse_shen-dot-<anymulti>) (quote shen-dot-skip)) (fail))) (fail))) (fail))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? hd = shen-dot-pair tl shen-dot-hdtl fail) (clojure.core/defn shen-dot-<times> [V2575] (if (clojure.core/and (cons? (hd V2575)) (= 42 (hd (hd V2575)))) (shen-dot-pair (hd (shen-dot-pair (tl (hd V2575)) (shen-dot-hdtl V2575))) (quote shen-dot-skip)) (fail)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-<comment> not = fail shen-dot-<anymulti> shen-dot-pair hd shen-dot-<times> shen-dot-<backslash> cons? tl shen-dot-hdtl) (clojure.core/defn shen-dot-<anymulti> [V2577] (clojure.core/let [YaccParse (clojure.core/let [Parse_shen-dot-<comment> (shen-dot-<comment> V2577)] (if (not (= (fail) Parse_shen-dot-<comment>)) (clojure.core/let [Parse_shen-dot-<anymulti> (shen-dot-<anymulti> Parse_shen-dot-<comment>)] (if (not (= (fail) Parse_shen-dot-<anymulti>)) (shen-dot-pair (hd Parse_shen-dot-<anymulti>) (quote shen-dot-skip)) (fail))) (fail)))] (if (= YaccParse (fail)) (clojure.core/let [YaccParse (clojure.core/let [Parse_shen-dot-<times> (shen-dot-<times> V2577)] (if (not (= (fail) Parse_shen-dot-<times>)) (clojure.core/let [Parse_shen-dot-<backslash> (shen-dot-<backslash> Parse_shen-dot-<times>)] (if (not (= (fail) Parse_shen-dot-<backslash>)) (shen-dot-pair (hd Parse_shen-dot-<backslash>) (quote shen-dot-skip)) (fail))) (fail)))] (if (= YaccParse (fail)) (if (cons? (hd V2577)) (clojure.core/let [Parse_X (hd (hd V2577))] (clojure.core/let [Parse_shen-dot-<anymulti> (shen-dot-<anymulti> (shen-dot-pair (tl (hd V2577)) (shen-dot-hdtl V2577)))] (if (not (= (fail) Parse_shen-dot-<anymulti>)) (shen-dot-pair (hd Parse_shen-dot-<anymulti>) (quote shen-dot-skip)) (fail)))) (fail)) YaccParse)) YaccParse)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-<whitespace> not = fail shen-dot-<whitespaces> shen-dot-pair hd) (clojure.core/defn shen-dot-<whitespaces> [V2579] (clojure.core/let [YaccParse (clojure.core/let [Parse_shen-dot-<whitespace> (shen-dot-<whitespace> V2579)] (if (not (= (fail) Parse_shen-dot-<whitespace>)) (clojure.core/let [Parse_shen-dot-<whitespaces> (shen-dot-<whitespaces> Parse_shen-dot-<whitespace>)] (if (not (= (fail) Parse_shen-dot-<whitespaces>)) (shen-dot-pair (hd Parse_shen-dot-<whitespaces>) (quote shen-dot-skip)) (fail))) (fail)))] (if (= YaccParse (fail)) (clojure.core/let [Parse_shen-dot-<whitespace> (shen-dot-<whitespace> V2579)] (if (not (= (fail) Parse_shen-dot-<whitespace>)) (shen-dot-pair (hd Parse_shen-dot-<whitespace>) (quote shen-dot-skip)) (fail))) YaccParse)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? hd = shen-dot-pair tl shen-dot-hdtl fail) (clojure.core/defn shen-dot-<whitespace> [V2581] (if (cons? (hd V2581)) (clojure.core/let [Parse_X (hd (hd V2581))] (if (clojure.core/let [Parse_Case Parse_X] (clojure.core/or (= Parse_Case 32) (clojure.core/or (= Parse_Case 13) (clojure.core/or (= Parse_Case 10) (= Parse_Case 9))))) (shen-dot-pair (hd (shen-dot-pair (tl (hd V2581)) (shen-dot-hdtl V2581))) (quote shen-dot-skip)) (fail))) (fail)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare = cons? tl hd cons shen-dot-cons_form shen-dot-f_error) (clojure.core/defn shen-dot-cons_form [V2583] (clojure.core/cond (= () V2583) () (clojure.core/and (cons? V2583) (clojure.core/and (cons? (tl V2583)) (clojure.core/and (cons? (tl (tl V2583))) (clojure.core/and (= () (tl (tl (tl V2583)))) (= (hd (tl V2583)) (quote bar!)))))) (cons (quote cons) (cons (hd V2583) (tl (tl V2583)))) (cons? V2583) (cons (quote cons) (cons (hd V2583) (cons (shen-dot-cons_form (tl V2583)) ()))) true (shen-dot-f_error (quote shen-dot-cons_form)) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-package-macro [V2588 V2589] (clojure.core/cond (clojure.core/and (cons? V2588) (clojure.core/and (= (quote $) (hd V2588)) (clojure.core/and (cons? (tl V2588)) (= () (tl (tl V2588)))))) (append (explode (hd (tl V2588))) V2589) (clojure.core/and (cons? V2588) (clojure.core/and (= (quote package) (hd V2588)) (clojure.core/and (cons? (tl V2588)) (clojure.core/and (= (quote null) (hd (tl V2588))) (cons? (tl (tl V2588))))))) (append (tl (tl (tl V2588))) V2589) (clojure.core/and (cons? V2588) (clojure.core/and (= (quote package) (hd V2588)) (clojure.core/and (cons? (tl V2588)) (cons? (tl (tl V2588)))))) (clojure.core/let [ListofExceptions (shen-dot-eval-without-macros (hd (tl (tl V2588))))] (clojure.core/let [External (shen-dot-record-exceptions ListofExceptions (hd (tl V2588)))] (clojure.core/let [PackageNameDot (intern (cn (str (hd (tl V2588))) "."))] (clojure.core/let [ExpPackageNameDot (explode PackageNameDot)] (clojure.core/let [Packaged (shen-dot-packageh PackageNameDot ListofExceptions (tl (tl (tl V2588))) ExpPackageNameDot)] (clojure.core/let [Internal (shen-dot-record-internal (hd (tl V2588)) (shen-dot-internal-symbols ExpPackageNameDot Packaged))] (append Packaged V2589))))))) true (cons V2588 V2589) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-record-exceptions [V2592 V2593] (clojure.core/let [CurrExceptions (try (get V2593 (quote shen-dot-external-symbols) (value (quote *property-vector*))) (catch Exception e7801 ((clojure.core/fn [E] ()) e7801)))] (clojure.core/let [AllExceptions (union V2592 CurrExceptions)] (put V2593 (quote shen-dot-external-symbols) AllExceptions (value (quote *property-vector*)))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-record-internal [V2596 V2597] (put V2596 (quote shen-dot-internal-symbols) (union V2597 (try (get V2596 (quote shen-dot-internal-symbols) (value (quote *property-vector*))) (catch Exception e7803 ((clojure.core/fn [E] ()) e7803)))) (value (quote *property-vector*)))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-internal-symbols [V2608 V2609] (clojure.core/cond (clojure.core/and (symbol? V2609) (shen-dot-prefix? V2608 (explode V2609))) (cons V2609 ()) (cons? V2609) (union (shen-dot-internal-symbols V2608 (hd V2609)) (shen-dot-internal-symbols V2608 (tl V2609))) true () :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-packageh [V2626 V2627 V2628 V2629] (clojure.core/cond (cons? V2628) (cons (shen-dot-packageh V2626 V2627 (hd V2628) V2629) (shen-dot-packageh V2626 V2627 (tl V2628) V2629)) (clojure.core/or (shen-dot-sysfunc? V2628) (clojure.core/or (variable? V2628) (clojure.core/or (element? V2628 V2627) (clojure.core/or (shen-dot-doubleunderline? V2628) (shen-dot-singleunderline? V2628))))) V2628 (clojure.core/and (symbol? V2628) (clojure.core/let [ExplodeX (explode V2628)] (clojure.core/and (not (shen-dot-prefix? (cons "s" (cons "h" (cons "e" (cons "n" (cons "." ()))))) ExplodeX)) (not (shen-dot-prefix? V2629 ExplodeX))))) (concat V2626 V2628) true V2628 :else (throw (Exception. "No matching cond clause")))))
(clojure.core/comment prolog.kl)
(clojure.core/comment "Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.")
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-insert-predicate shen-dot-hdtl Parse_shen-dot-<predicate*> shen-dot-<predicate*> not = fail shen-dot-<clauses*> shen-dot-pair hd shen-dot-prolog->shen map) (clojure.core/defn shen-dot-<defprolog> [V1809] (clojure.core/let [Parse_shen-dot-<predicate*> (shen-dot-<predicate*> V1809)] (if (not (= (fail) Parse_shen-dot-<predicate*>)) (clojure.core/let [Parse_shen-dot-<clauses*> (shen-dot-<clauses*> Parse_shen-dot-<predicate*>)] (if (not (= (fail) Parse_shen-dot-<clauses*>)) (shen-dot-pair (hd Parse_shen-dot-<clauses*>) (hd (shen-dot-prolog->shen (map (do (clojure.core/declare shen-dot-insert-predicate shen-dot-hdtl) (clojure.core/fn [Parse_X] (shen-dot-insert-predicate (shen-dot-hdtl Parse_shen-dot-<predicate*>) Parse_X))) (shen-dot-hdtl Parse_shen-dot-<clauses*>))))) (fail))) (fail))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-prolog-error [V1818 V1819] (clojure.core/cond (clojure.core/and (cons? V1819) (clojure.core/and (cons? (tl V1819)) (= () (tl (tl V1819))))) (simple-error (cn "prolog syntax error in " (shen-dot-app V1818 (cn " here:\n\n " (shen-dot-app (shen-dot-next-50 50 (hd V1819)) "\n" (quote shen-dot-a))) (quote shen-dot-a)))) true (simple-error (cn "prolog syntax error in " (shen-dot-app V1818 "\n" (quote shen-dot-a)))) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-next-50 [V1826 V1827] (clojure.core/cond (= () V1827) "" (= 0 V1826) "" (cons? V1827) (cn (shen-dot-decons-string (hd V1827)) (shen-dot-next-50 (- V1826 1) (tl V1827))) true (shen-dot-f_error (quote shen-dot-next-50)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? = hd tl shen-dot-app shen-dot-eval-cons) (clojure.core/defn shen-dot-decons-string [V1829] (clojure.core/cond (clojure.core/and (cons? V1829) (clojure.core/and (= (quote cons) (hd V1829)) (clojure.core/and (cons? (tl V1829)) (clojure.core/and (cons? (tl (tl V1829))) (= () (tl (tl (tl V1829)))))))) (shen-dot-app (shen-dot-eval-cons V1829) " " (quote shen-dot-s)) true (shen-dot-app V1829 " " (quote shen-dot-r)) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-insert-predicate [V1832 V1833] (clojure.core/cond (clojure.core/and (cons? V1833) (clojure.core/and (cons? (tl V1833)) (= () (tl (tl V1833))))) (cons (cons V1832 (hd V1833)) (cons (quote -colon--) (tl V1833))) true (shen-dot-f_error (quote shen-dot-insert-predicate)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? hd shen-dot-pair tl shen-dot-hdtl fail) (clojure.core/defn shen-dot-<predicate*> [V1835] (if (cons? (hd V1835)) (clojure.core/let [Parse_X (hd (hd V1835))] (shen-dot-pair (hd (shen-dot-pair (tl (hd V1835)) (shen-dot-hdtl V1835))) Parse_X)) (fail)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-<clause*> not = fail shen-dot-<clauses*> shen-dot-pair hd cons shen-dot-hdtl <e>) (clojure.core/defn shen-dot-<clauses*> [V1837] (clojure.core/let [YaccParse (clojure.core/let [Parse_shen-dot-<clause*> (shen-dot-<clause*> V1837)] (if (not (= (fail) Parse_shen-dot-<clause*>)) (clojure.core/let [Parse_shen-dot-<clauses*> (shen-dot-<clauses*> Parse_shen-dot-<clause*>)] (if (not (= (fail) Parse_shen-dot-<clauses*>)) (shen-dot-pair (hd Parse_shen-dot-<clauses*>) (cons (shen-dot-hdtl Parse_shen-dot-<clause*>) (shen-dot-hdtl Parse_shen-dot-<clauses*>))) (fail))) (fail)))] (if (= YaccParse (fail)) (clojure.core/let [Parse_<e> (<e> V1837)] (if (not (= (fail) Parse_<e>)) (shen-dot-pair (hd Parse_<e>) ()) (fail))) YaccParse)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-<head*> not = fail cons? hd shen-dot-<body*> shen-dot-pair tl shen-dot-hdtl shen-dot-<end*> cons) (clojure.core/defn shen-dot-<clause*> [V1839] (clojure.core/let [Parse_shen-dot-<head*> (shen-dot-<head*> V1839)] (if (not (= (fail) Parse_shen-dot-<head*>)) (if (clojure.core/and (cons? (hd Parse_shen-dot-<head*>)) (= (quote <--) (hd (hd Parse_shen-dot-<head*>)))) (clojure.core/let [Parse_shen-dot-<body*> (shen-dot-<body*> (shen-dot-pair (tl (hd Parse_shen-dot-<head*>)) (shen-dot-hdtl Parse_shen-dot-<head*>)))] (if (not (= (fail) Parse_shen-dot-<body*>)) (clojure.core/let [Parse_shen-dot-<end*> (shen-dot-<end*> Parse_shen-dot-<body*>)] (if (not (= (fail) Parse_shen-dot-<end*>)) (shen-dot-pair (hd Parse_shen-dot-<end*>) (cons (shen-dot-hdtl Parse_shen-dot-<head*>) (cons (shen-dot-hdtl Parse_shen-dot-<body*>) ()))) (fail))) (fail))) (fail)) (fail))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-<term*> not = fail shen-dot-<head*> shen-dot-pair hd cons shen-dot-hdtl <e>) (clojure.core/defn shen-dot-<head*> [V1841] (clojure.core/let [YaccParse (clojure.core/let [Parse_shen-dot-<term*> (shen-dot-<term*> V1841)] (if (not (= (fail) Parse_shen-dot-<term*>)) (clojure.core/let [Parse_shen-dot-<head*> (shen-dot-<head*> Parse_shen-dot-<term*>)] (if (not (= (fail) Parse_shen-dot-<head*>)) (shen-dot-pair (hd Parse_shen-dot-<head*>) (cons (shen-dot-hdtl Parse_shen-dot-<term*>) (shen-dot-hdtl Parse_shen-dot-<head*>))) (fail))) (fail)))] (if (= YaccParse (fail)) (clojure.core/let [Parse_<e> (<e> V1841)] (if (not (= (fail) Parse_<e>)) (shen-dot-pair (hd Parse_<e>) ()) (fail))) YaccParse)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? hd not = shen-dot-legitimate-term? shen-dot-pair tl shen-dot-hdtl shen-dot-eval-cons fail) (clojure.core/defn shen-dot-<term*> [V1843] (if (cons? (hd V1843)) (clojure.core/let [Parse_X (hd (hd V1843))] (if (clojure.core/and (not (= (quote <--) Parse_X)) (shen-dot-legitimate-term? Parse_X)) (shen-dot-pair (hd (shen-dot-pair (tl (hd V1843)) (shen-dot-hdtl V1843))) (shen-dot-eval-cons Parse_X)) (fail))) (fail)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? = hd tl shen-dot-legitimate-term?) (clojure.core/defn shen-dot-legitimate-term? [V1849] (clojure.core/cond (clojure.core/and (cons? V1849) (clojure.core/and (= (quote cons) (hd V1849)) (clojure.core/and (cons? (tl V1849)) (clojure.core/and (cons? (tl (tl V1849))) (= () (tl (tl (tl V1849)))))))) (clojure.core/and (shen-dot-legitimate-term? (hd (tl V1849))) (shen-dot-legitimate-term? (hd (tl (tl V1849))))) (clojure.core/and (cons? V1849) (clojure.core/and (= (quote mode) (hd V1849)) (clojure.core/and (cons? (tl V1849)) (clojure.core/and (cons? (tl (tl V1849))) (clojure.core/and (= (quote +) (hd (tl (tl V1849)))) (= () (tl (tl (tl V1849))))))))) (shen-dot-legitimate-term? (hd (tl V1849))) (clojure.core/and (cons? V1849) (clojure.core/and (= (quote mode) (hd V1849)) (clojure.core/and (cons? (tl V1849)) (clojure.core/and (cons? (tl (tl V1849))) (clojure.core/and (= (quote -) (hd (tl (tl V1849)))) (= () (tl (tl (tl V1849))))))))) (shen-dot-legitimate-term? (hd (tl V1849))) (cons? V1849) false true true :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? = hd tl cons shen-dot-eval-cons) (clojure.core/defn shen-dot-eval-cons [V1851] (clojure.core/cond (clojure.core/and (cons? V1851) (clojure.core/and (= (quote cons) (hd V1851)) (clojure.core/and (cons? (tl V1851)) (clojure.core/and (cons? (tl (tl V1851))) (= () (tl (tl (tl V1851)))))))) (cons (shen-dot-eval-cons (hd (tl V1851))) (shen-dot-eval-cons (hd (tl (tl V1851))))) (clojure.core/and (cons? V1851) (clojure.core/and (= (quote mode) (hd V1851)) (clojure.core/and (cons? (tl V1851)) (clojure.core/and (cons? (tl (tl V1851))) (= () (tl (tl (tl V1851)))))))) (cons (quote mode) (cons (shen-dot-eval-cons (hd (tl V1851))) (tl (tl V1851)))) true V1851 :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-<literal*> not = fail shen-dot-<body*> shen-dot-pair hd cons shen-dot-hdtl <e>) (clojure.core/defn shen-dot-<body*> [V1853] (clojure.core/let [YaccParse (clojure.core/let [Parse_shen-dot-<literal*> (shen-dot-<literal*> V1853)] (if (not (= (fail) Parse_shen-dot-<literal*>)) (clojure.core/let [Parse_shen-dot-<body*> (shen-dot-<body*> Parse_shen-dot-<literal*>)] (if (not (= (fail) Parse_shen-dot-<body*>)) (shen-dot-pair (hd Parse_shen-dot-<body*>) (cons (shen-dot-hdtl Parse_shen-dot-<literal*>) (shen-dot-hdtl Parse_shen-dot-<body*>))) (fail))) (fail)))] (if (= YaccParse (fail)) (clojure.core/let [Parse_<e> (<e> V1853)] (if (not (= (fail) Parse_<e>)) (shen-dot-pair (hd Parse_<e>) ()) (fail))) YaccParse)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? hd = shen-dot-pair tl shen-dot-hdtl cons intern fail) (clojure.core/defn shen-dot-<literal*> [V1855] (clojure.core/let [YaccParse (if (clojure.core/and (cons? (hd V1855)) (= (quote !) (hd (hd V1855)))) (shen-dot-pair (hd (shen-dot-pair (tl (hd V1855)) (shen-dot-hdtl V1855))) (cons (quote cut) (cons (intern "Throwcontrol") ()))) (fail))] (if (= YaccParse (fail)) (if (cons? (hd V1855)) (clojure.core/let [Parse_X (hd (hd V1855))] (if (cons? Parse_X) (shen-dot-pair (hd (shen-dot-pair (tl (hd V1855)) (shen-dot-hdtl V1855))) Parse_X) (fail))) (fail)) YaccParse)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? hd = shen-dot-pair tl shen-dot-hdtl fail) (clojure.core/defn shen-dot-<end*> [V1857] (if (cons? (hd V1857)) (clojure.core/let [Parse_X (hd (hd V1857))] (if (= Parse_X (quote -semicol-)) (shen-dot-pair (hd (shen-dot-pair (tl (hd V1857)) (shen-dot-hdtl V1857))) Parse_X) (fail))) (fail)))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried cut [V1861 V1862 V1863] (clojure.core/let [Result (thaw V1863)] (if (= Result false) V1861 Result))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? = hd tl cons shen-dot-insert_modes) (clojure.core/defn shen-dot-insert_modes [V1865] (clojure.core/cond (clojure.core/and (cons? V1865) (clojure.core/and (= (quote mode) (hd V1865)) (clojure.core/and (cons? (tl V1865)) (clojure.core/and (cons? (tl (tl V1865))) (= () (tl (tl (tl V1865)))))))) V1865 (= () V1865) () (cons? V1865) (cons (cons (quote mode) (cons (hd V1865) (cons (quote +) ()))) (cons (quote mode) (cons (shen-dot-insert_modes (tl V1865)) (cons (quote -) ())))) true V1865 :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare eval map shen-dot-prolog->shen) (clojure.core/defn shen-dot-s-prolog [V1867] (map (do (clojure.core/declare eval) (clojure.core/fn [X] (eval X))) (shen-dot-prolog->shen V1867)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-head_abstraction map shen-dot-compile_prolog_procedure shen-dot-group_clauses shen-dot-s-prolog_clause mapcan) (clojure.core/defn shen-dot-prolog->shen [V1869] (map (do (clojure.core/declare shen-dot-compile_prolog_procedure) (clojure.core/fn [X] (shen-dot-compile_prolog_procedure X))) (shen-dot-group_clauses (map (do (clojure.core/declare shen-dot-s-prolog_clause) (clojure.core/fn [X] (shen-dot-s-prolog_clause X))) (mapcan (do (clojure.core/declare shen-dot-head_abstraction) (clojure.core/fn [X] (shen-dot-head_abstraction X))) V1869)))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-s-prolog_literal cons? tl = hd cons map shen-dot-f_error) (clojure.core/defn shen-dot-s-prolog_clause [V1871] (clojure.core/cond (clojure.core/and (cons? V1871) (clojure.core/and (cons? (tl V1871)) (clojure.core/and (= (quote -colon--) (hd (tl V1871))) (clojure.core/and (cons? (tl (tl V1871))) (= () (tl (tl (tl V1871)))))))) (cons (hd V1871) (cons (quote -colon--) (cons (map (do (clojure.core/declare shen-dot-s-prolog_literal) (clojure.core/fn [X] (shen-dot-s-prolog_literal X))) (hd (tl (tl V1871)))) ()))) true (shen-dot-f_error (quote shen-dot-s-prolog_clause)) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare gensym cons? tl = hd < shen-dot-complexity_head value cons map shen-dot-rcons_form shen-dot-remove_modes shen-dot-cons_form shen-dot-f_error) (clojure.core/defn shen-dot-head_abstraction [V1873] (clojure.core/cond (clojure.core/and (cons? V1873) (clojure.core/and (cons? (tl V1873)) (clojure.core/and (= (quote -colon--) (hd (tl V1873))) (clojure.core/and (cons? (tl (tl V1873))) (clojure.core/and (= () (tl (tl (tl V1873)))) (try (< (shen-dot-complexity_head (hd V1873)) (value (quote shen-dot-*maxcomplexity*))) (catch Exception e7833 ((clojure.core/fn [_] false) e7833)))))))) (cons V1873 ()) (clojure.core/and (cons? V1873) (clojure.core/and (cons? (hd V1873)) (clojure.core/and (cons? (tl V1873)) (clojure.core/and (= (quote -colon--) (hd (tl V1873))) (clojure.core/and (cons? (tl (tl V1873))) (= () (tl (tl (tl V1873))))))))) (clojure.core/let [Terms (map (do (clojure.core/declare gensym) (clojure.core/fn [Y] (gensym (quote V)))) (tl (hd V1873)))] (clojure.core/let [XTerms (shen-dot-rcons_form (shen-dot-remove_modes (tl (hd V1873))))] (clojure.core/let [Literal (cons (quote unify) (cons (shen-dot-cons_form Terms) (cons XTerms ())))] (clojure.core/let [Clause (cons (cons (hd (hd V1873)) Terms) (cons (quote -colon--) (cons (cons Literal (hd (tl (tl V1873)))) ())))] (cons Clause ()))))) true (shen-dot-f_error (quote shen-dot-head_abstraction)) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-complexity cons? shen-dot-safe-product map tl shen-dot-f_error) (clojure.core/defn shen-dot-complexity_head [V1879] (clojure.core/cond (cons? V1879) (shen-dot-safe-product (map (do (clojure.core/declare shen-dot-complexity) (clojure.core/fn [X] (shen-dot-complexity X))) (tl V1879))) true (shen-dot-f_error (quote shen-dot-complexity_head)) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-safe-multiply [V1882 V1883] (* V1882 V1883)))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? = hd tl shen-dot-complexity shen-dot-safe-multiply cons variable?) (clojure.core/defn shen-dot-complexity [V1892] (clojure.core/cond (clojure.core/and (cons? V1892) (clojure.core/and (= (quote mode) (hd V1892)) (clojure.core/and (cons? (tl V1892)) (clojure.core/and (cons? (hd (tl V1892))) (clojure.core/and (= (quote mode) (hd (hd (tl V1892)))) (clojure.core/and (cons? (tl (hd (tl V1892)))) (clojure.core/and (cons? (tl (tl (hd (tl V1892))))) (clojure.core/and (= () (tl (tl (tl (hd (tl V1892)))))) (clojure.core/and (cons? (tl (tl V1892))) (= () (tl (tl (tl V1892))))))))))))) (shen-dot-complexity (hd (tl V1892))) (clojure.core/and (cons? V1892) (clojure.core/and (= (quote mode) (hd V1892)) (clojure.core/and (cons? (tl V1892)) (clojure.core/and (cons? (hd (tl V1892))) (clojure.core/and (cons? (tl (tl V1892))) (clojure.core/and (= (quote +) (hd (tl (tl V1892)))) (= () (tl (tl (tl V1892)))))))))) (shen-dot-safe-multiply 2 (shen-dot-safe-multiply (shen-dot-complexity (cons (quote mode) (cons (hd (hd (tl V1892))) (tl (tl V1892))))) (shen-dot-complexity (cons (quote mode) (cons (tl (hd (tl V1892))) (tl (tl V1892))))))) (clojure.core/and (cons? V1892) (clojure.core/and (= (quote mode) (hd V1892)) (clojure.core/and (cons? (tl V1892)) (clojure.core/and (cons? (hd (tl V1892))) (clojure.core/and (cons? (tl (tl V1892))) (clojure.core/and (= (quote -) (hd (tl (tl V1892)))) (= () (tl (tl (tl V1892)))))))))) (shen-dot-safe-multiply (shen-dot-complexity (cons (quote mode) (cons (hd (hd (tl V1892))) (tl (tl V1892))))) (shen-dot-complexity (cons (quote mode) (cons (tl (hd (tl V1892))) (tl (tl V1892)))))) (clojure.core/and (cons? V1892) (clojure.core/and (= (quote mode) (hd V1892)) (clojure.core/and (cons? (tl V1892)) (clojure.core/and (cons? (tl (tl V1892))) (clojure.core/and (= () (tl (tl (tl V1892)))) (variable? (hd (tl V1892)))))))) 1 (clojure.core/and (cons? V1892) (clojure.core/and (= (quote mode) (hd V1892)) (clojure.core/and (cons? (tl V1892)) (clojure.core/and (cons? (tl (tl V1892))) (clojure.core/and (= (quote +) (hd (tl (tl V1892)))) (= () (tl (tl (tl V1892))))))))) 2 (clojure.core/and (cons? V1892) (clojure.core/and (= (quote mode) (hd V1892)) (clojure.core/and (cons? (tl V1892)) (clojure.core/and (cons? (tl (tl V1892))) (clojure.core/and (= (quote -) (hd (tl (tl V1892)))) (= () (tl (tl (tl V1892))))))))) 1 true (shen-dot-complexity (cons (quote mode) (cons V1892 (cons (quote +) ())))) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare = cons? shen-dot-safe-multiply hd shen-dot-safe-product tl shen-dot-f_error) (clojure.core/defn shen-dot-safe-product [V1894] (clojure.core/cond (= () V1894) 1 (cons? V1894) (shen-dot-safe-multiply (hd V1894) (shen-dot-safe-product (tl V1894))) true (shen-dot-f_error (quote shen-dot-safe-product)) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? = hd tl cons shen-dot-insert_deref shen-dot-insert_lazyderef shen-dot-f_error) (clojure.core/defn shen-dot-s-prolog_literal [V1896] (clojure.core/cond (clojure.core/and (cons? V1896) (clojure.core/and (= (quote is) (hd V1896)) (clojure.core/and (cons? (tl V1896)) (clojure.core/and (cons? (tl (tl V1896))) (= () (tl (tl (tl V1896)))))))) (cons (quote bind) (cons (hd (tl V1896)) (cons (shen-dot-insert_deref (hd (tl (tl V1896)))) ()))) (clojure.core/and (cons? V1896) (clojure.core/and (= (quote when) (hd V1896)) (clojure.core/and (cons? (tl V1896)) (= () (tl (tl V1896)))))) (cons (quote fwhen) (cons (shen-dot-insert_deref (hd (tl V1896))) ())) (clojure.core/and (cons? V1896) (clojure.core/and (= (quote bind) (hd V1896)) (clojure.core/and (cons? (tl V1896)) (clojure.core/and (cons? (tl (tl V1896))) (= () (tl (tl (tl V1896)))))))) (cons (quote bind) (cons (hd (tl V1896)) (cons (shen-dot-insert_lazyderef (hd (tl (tl V1896)))) ()))) (clojure.core/and (cons? V1896) (clojure.core/and (= (quote fwhen) (hd V1896)) (clojure.core/and (cons? (tl V1896)) (= () (tl (tl V1896)))))) (cons (quote fwhen) (cons (shen-dot-insert_lazyderef (hd (tl V1896))) ())) (cons? V1896) V1896 true (shen-dot-f_error (quote shen-dot-s-prolog_literal)) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare variable? cons cons? shen-dot-insert_deref hd tl) (clojure.core/defn shen-dot-insert_deref [V1898] (clojure.core/cond (variable? V1898) (cons (quote shen-dot-deref) (cons V1898 (cons (quote ProcessN) ()))) (cons? V1898) (cons (shen-dot-insert_deref (hd V1898)) (shen-dot-insert_deref (tl V1898))) true V1898 :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare variable? cons cons? shen-dot-insert_lazyderef hd tl) (clojure.core/defn shen-dot-insert_lazyderef [V1900] (clojure.core/cond (variable? V1900) (cons (quote shen-dot-lazyderef) (cons V1900 (cons (quote ProcessN) ()))) (cons? V1900) (cons (shen-dot-insert_lazyderef (hd V1900)) (shen-dot-insert_lazyderef (tl V1900))) true V1900 :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-same_predicate? hd V1902 = cons? shen-dot-collect difference cons shen-dot-group_clauses shen-dot-f_error) (clojure.core/defn shen-dot-group_clauses [V1902] (clojure.core/cond (= () V1902) () (cons? V1902) (clojure.core/let [Group (shen-dot-collect (do (clojure.core/declare shen-dot-same_predicate? hd) (clojure.core/fn [X] (shen-dot-same_predicate? (hd V1902) X))) V1902)] (clojure.core/let [Rest (difference V1902 Group)] (cons Group (shen-dot-group_clauses Rest)))) true (shen-dot-f_error (quote shen-dot-group_clauses)) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-collect [V1907 V1908] (clojure.core/cond (= () V1908) () (cons? V1908) (if ((shen.primitives/resolve-fn V1907) (hd V1908)) (cons (hd V1908) (shen-dot-collect V1907 (tl V1908))) (shen-dot-collect V1907 (tl V1908))) true (shen-dot-f_error (quote shen-dot-collect)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-same_predicate? [V1927 V1928] (clojure.core/cond (clojure.core/and (cons? V1927) (clojure.core/and (cons? (hd V1927)) (clojure.core/and (cons? V1928) (cons? (hd V1928))))) (= (hd (hd V1927)) (hd (hd V1928))) true (shen-dot-f_error (quote shen-dot-same_predicate?)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-procedure_name shen-dot-clauses-to-shen) (clojure.core/defn shen-dot-compile_prolog_procedure [V1930] (clojure.core/let [F (shen-dot-procedure_name V1930)] (clojure.core/let [Shen (shen-dot-clauses-to-shen F V1930)] Shen)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? hd shen-dot-f_error) (clojure.core/defn shen-dot-procedure_name [V1944] (clojure.core/cond (clojure.core/and (cons? V1944) (clojure.core/and (cons? (hd V1944)) (cons? (hd (hd V1944))))) (hd (hd (hd V1944))) true (shen-dot-f_error (quote shen-dot-procedure_name)) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-clauses-to-shen [V1947 V1948] (clojure.core/let [Linear (map (do (clojure.core/declare shen-dot-linearise-clause) (clojure.core/fn [X] (shen-dot-linearise-clause X))) V1948)] (clojure.core/let [Arity (shen-dot-prolog-aritycheck V1947 (map (do (clojure.core/declare head) (clojure.core/fn [X] (head X))) V1948))] (clojure.core/let [Parameters (shen-dot-parameters Arity)] (clojure.core/let [AUM_instructions (map (do (clojure.core/declare shen-dot-aum) (clojure.core/fn [X] (shen-dot-aum X Parameters))) Linear)] (clojure.core/let [Code (shen-dot-catch-cut (shen-dot-nest-disjunct (map (do (clojure.core/declare shen-dot-aum_to_shen) (clojure.core/fn [X] (shen-dot-aum_to_shen X))) AUM_instructions)))] (clojure.core/let [ShenDef (cons (quote define) (cons V1947 (append Parameters (append (cons (quote ProcessN) (cons (quote Continuation) ())) (cons (quote ->) (cons Code ()))))))] ShenDef))))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare not shen-dot-occurs? cons) (clojure.core/defn shen-dot-catch-cut [V1950] (clojure.core/cond (not (shen-dot-occurs? (quote cut) V1950)) V1950 true (cons (quote let) (cons (quote Throwcontrol) (cons (cons (quote shen-dot-catchpoint) ()) (cons (cons (quote shen-dot-cutpoint) (cons (quote Throwcontrol) (cons V1950 ()))) ())))) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare set + value) (clojure.core/defn shen-dot-catchpoint [] (set (quote shen-dot-*catch*) (+ 1 (value (quote shen-dot-*catch*)))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-cutpoint [V1958 V1959] (clojure.core/cond (= V1959 V1958) false true V1959 :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? = tl hd shen-dot-lisp-or shen-dot-nest-disjunct shen-dot-f_error) (clojure.core/defn shen-dot-nest-disjunct [V1961] (clojure.core/cond (clojure.core/and (cons? V1961) (= () (tl V1961))) (hd V1961) (cons? V1961) (shen-dot-lisp-or (hd V1961) (shen-dot-nest-disjunct (tl V1961))) true (shen-dot-f_error (quote shen-dot-nest-disjunct)) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-lisp-or [V1964 V1965] (cons (quote let) (cons (quote Case) (cons V1964 (cons (cons (quote if) (cons (cons (quote =) (cons (quote Case) (cons false ()))) (cons V1965 (cons (quote Case) ())))) ()))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-prolog-aritycheck [V1970 V1971] (clojure.core/cond (clojure.core/and (cons? V1971) (= () (tl V1971))) (- (length (hd V1971)) 1) (clojure.core/and (cons? V1971) (cons? (tl V1971))) (if (= (length (hd V1971)) (length (hd (tl V1971)))) (shen-dot-prolog-aritycheck V1970 (tl V1971)) (simple-error (cn "arity error in prolog procedure " (shen-dot-app (cons V1970 ()) "\n" (quote shen-dot-a))))) true (shen-dot-f_error (quote shen-dot-prolog-aritycheck)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? tl = hd shen-dot-linearise cons shen-dot-clause_form shen-dot-f_error) (clojure.core/defn shen-dot-linearise-clause [V1973] (clojure.core/cond (clojure.core/and (cons? V1973) (clojure.core/and (cons? (tl V1973)) (clojure.core/and (= (quote -colon--) (hd (tl V1973))) (clojure.core/and (cons? (tl (tl V1973))) (= () (tl (tl (tl V1973)))))))) (clojure.core/let [Linear (shen-dot-linearise (cons (hd V1973) (tl (tl V1973))))] (shen-dot-clause_form Linear)) true (shen-dot-f_error (quote shen-dot-linearise-clause)) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? tl = cons shen-dot-explicit_modes hd shen-dot-cf_help shen-dot-f_error) (clojure.core/defn shen-dot-clause_form [V1975] (clojure.core/cond (clojure.core/and (cons? V1975) (clojure.core/and (cons? (tl V1975)) (= () (tl (tl V1975))))) (cons (shen-dot-explicit_modes (hd V1975)) (cons (quote -colon--) (cons (shen-dot-cf_help (hd (tl V1975))) ()))) true (shen-dot-f_error (quote shen-dot-clause_form)) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-em_help cons? cons hd map tl shen-dot-f_error) (clojure.core/defn shen-dot-explicit_modes [V1977] (clojure.core/cond (cons? V1977) (cons (hd V1977) (map (do (clojure.core/declare shen-dot-em_help) (clojure.core/fn [X] (shen-dot-em_help X))) (tl V1977))) true (shen-dot-f_error (quote shen-dot-explicit_modes)) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? = hd tl cons) (clojure.core/defn shen-dot-em_help [V1979] (clojure.core/cond (clojure.core/and (cons? V1979) (clojure.core/and (= (quote mode) (hd V1979)) (clojure.core/and (cons? (tl V1979)) (clojure.core/and (cons? (tl (tl V1979))) (= () (tl (tl (tl V1979)))))))) V1979 true (cons (quote mode) (cons V1979 (cons (quote +) ()))) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? = hd tl cons value shen-dot-cf_help) (clojure.core/defn shen-dot-cf_help [V1981] (clojure.core/cond (clojure.core/and (cons? V1981) (clojure.core/and (= (quote where) (hd V1981)) (clojure.core/and (cons? (tl V1981)) (clojure.core/and (cons? (hd (tl V1981))) (clojure.core/and (= (quote =) (hd (hd (tl V1981)))) (clojure.core/and (cons? (tl (hd (tl V1981)))) (clojure.core/and (cons? (tl (tl (hd (tl V1981))))) (clojure.core/and (= () (tl (tl (tl (hd (tl V1981)))))) (clojure.core/and (cons? (tl (tl V1981))) (= () (tl (tl (tl V1981))))))))))))) (cons (cons (if (value (quote shen-dot-*occurs*)) (quote unify!) (quote unify)) (tl (hd (tl V1981)))) (shen-dot-cf_help (hd (tl (tl V1981))))) true V1981 :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare = set simple-error) (clojure.core/defn occurs-check [V1987] (clojure.core/cond (= (quote +) V1987) (set (quote shen-dot-*occurs*) true) (= (quote -) V1987) (set (quote shen-dot-*occurs*) false) true (simple-error "occurs-check expects + or -\n") :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-aum [V1990 V1991] (clojure.core/cond (clojure.core/and (cons? V1990) (clojure.core/and (cons? (hd V1990)) (clojure.core/and (cons? (tl V1990)) (clojure.core/and (= (quote -colon--) (hd (tl V1990))) (clojure.core/and (cons? (tl (tl V1990))) (= () (tl (tl (tl V1990))))))))) (clojure.core/let [MuApplication (shen-dot-make_mu_application (cons (quote shen-dot-mu) (cons (tl (hd V1990)) (cons (shen-dot-continuation_call (tl (hd V1990)) (hd (tl (tl V1990)))) ()))) V1991)] (shen-dot-mu_reduction MuApplication (quote +))) true (shen-dot-f_error (quote shen-dot-aum)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-continuation_call [V1994 V1995] (clojure.core/let [VTerms (cons (quote ProcessN) (shen-dot-extract_vars V1994))] (clojure.core/let [VBody (shen-dot-extract_vars V1995)] (clojure.core/let [Free (remove (quote Throwcontrol) (difference VBody VTerms))] (shen-dot-cc_help Free V1995))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried remove [V1998 V1999] (shen-dot-remove-h V1998 V1999 ())))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-remove-h [V2006 V2007 V2008] (clojure.core/cond (= () V2007) (reverse V2008) (clojure.core/and (cons? V2007) (= (hd V2007) V2006)) (shen-dot-remove-h (hd V2007) (tl V2007) V2008) (cons? V2007) (shen-dot-remove-h V2006 (tl V2007) (cons (hd V2007) V2008)) true (shen-dot-f_error (quote shen-dot-remove-h)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-cc_help [V2011 V2012] (clojure.core/cond (clojure.core/and (= () V2011) (= () V2012)) (cons (quote shen-dot-pop) (cons (quote shen-dot-the) (cons (quote shen-dot-stack) ()))) (= () V2012) (cons (quote shen-dot-rename) (cons (quote shen-dot-the) (cons (quote shen-dot-variables) (cons (quote in) (cons V2011 (cons (quote and) (cons (quote shen-dot-then) (cons (cons (quote shen-dot-pop) (cons (quote shen-dot-the) (cons (quote shen-dot-stack) ()))) ())))))))) (= () V2011) (cons (quote call) (cons (quote shen-dot-the) (cons (quote shen-dot-continuation) (cons V2012 ())))) true (cons (quote shen-dot-rename) (cons (quote shen-dot-the) (cons (quote shen-dot-variables) (cons (quote in) (cons V2011 (cons (quote and) (cons (quote shen-dot-then) (cons (cons (quote call) (cons (quote shen-dot-the) (cons (quote shen-dot-continuation) (cons V2012 ())))) ())))))))) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-make_mu_application [V2015 V2016] (clojure.core/cond (clojure.core/and (cons? V2015) (clojure.core/and (= (quote shen-dot-mu) (hd V2015)) (clojure.core/and (cons? (tl V2015)) (clojure.core/and (= () (hd (tl V2015))) (clojure.core/and (cons? (tl (tl V2015))) (clojure.core/and (= () (tl (tl (tl V2015)))) (= () V2016))))))) (hd (tl (tl V2015))) (clojure.core/and (cons? V2015) (clojure.core/and (= (quote shen-dot-mu) (hd V2015)) (clojure.core/and (cons? (tl V2015)) (clojure.core/and (cons? (hd (tl V2015))) (clojure.core/and (cons? (tl (tl V2015))) (clojure.core/and (= () (tl (tl (tl V2015)))) (cons? V2016))))))) (cons (cons (quote shen-dot-mu) (cons (hd (hd (tl V2015))) (cons (shen-dot-make_mu_application (cons (quote shen-dot-mu) (cons (tl (hd (tl V2015))) (tl (tl V2015)))) (tl V2016)) ()))) (cons (hd V2016) ())) true (shen-dot-f_error (quote shen-dot-make_mu_application)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-mu_reduction [V2025 V2026] (clojure.core/cond (clojure.core/and (cons? V2025) (clojure.core/and (cons? (hd V2025)) (clojure.core/and (= (quote shen-dot-mu) (hd (hd V2025))) (clojure.core/and (cons? (tl (hd V2025))) (clojure.core/and (cons? (hd (tl (hd V2025)))) (clojure.core/and (= (quote mode) (hd (hd (tl (hd V2025))))) (clojure.core/and (cons? (tl (hd (tl (hd V2025))))) (clojure.core/and (cons? (tl (tl (hd (tl (hd V2025)))))) (clojure.core/and (= () (tl (tl (tl (hd (tl (hd V2025))))))) (clojure.core/and (cons? (tl (tl (hd V2025)))) (clojure.core/and (= () (tl (tl (tl (hd V2025))))) (clojure.core/and (cons? (tl V2025)) (= () (tl (tl V2025))))))))))))))) (shen-dot-mu_reduction (cons (cons (quote shen-dot-mu) (cons (hd (tl (hd (tl (hd V2025))))) (tl (tl (hd V2025))))) (tl V2025)) (hd (tl (tl (hd (tl (hd V2025))))))) (clojure.core/and (cons? V2025) (clojure.core/and (cons? (hd V2025)) (clojure.core/and (= (quote shen-dot-mu) (hd (hd V2025))) (clojure.core/and (cons? (tl (hd V2025))) (clojure.core/and (cons? (tl (tl (hd V2025)))) (clojure.core/and (= () (tl (tl (tl (hd V2025))))) (clojure.core/and (cons? (tl V2025)) (clojure.core/and (= () (tl (tl V2025))) (= (quote _) (hd (tl (hd V2025)))))))))))) (shen-dot-mu_reduction (hd (tl (tl (hd V2025)))) V2026) (clojure.core/and (cons? V2025) (clojure.core/and (cons? (hd V2025)) (clojure.core/and (= (quote shen-dot-mu) (hd (hd V2025))) (clojure.core/and (cons? (tl (hd V2025))) (clojure.core/and (cons? (tl (tl (hd V2025)))) (clojure.core/and (= () (tl (tl (tl (hd V2025))))) (clojure.core/and (cons? (tl V2025)) (clojure.core/and (= () (tl (tl V2025))) (shen-dot-ephemeral_variable? (hd (tl (hd V2025))) (hd (tl V2025))))))))))) (subst (hd (tl V2025)) (hd (tl (hd V2025))) (shen-dot-mu_reduction (hd (tl (tl (hd V2025)))) V2026)) (clojure.core/and (cons? V2025) (clojure.core/and (cons? (hd V2025)) (clojure.core/and (= (quote shen-dot-mu) (hd (hd V2025))) (clojure.core/and (cons? (tl (hd V2025))) (clojure.core/and (cons? (tl (tl (hd V2025)))) (clojure.core/and (= () (tl (tl (tl (hd V2025))))) (clojure.core/and (cons? (tl V2025)) (clojure.core/and (= () (tl (tl V2025))) (variable? (hd (tl (hd V2025)))))))))))) (cons (quote let) (cons (hd (tl (hd V2025))) (cons (quote shen-dot-be) (cons (hd (tl V2025)) (cons (quote in) (cons (shen-dot-mu_reduction (hd (tl (tl (hd V2025)))) V2026) ())))))) (clojure.core/and (cons? V2025) (clojure.core/and (cons? (hd V2025)) (clojure.core/and (= (quote shen-dot-mu) (hd (hd V2025))) (clojure.core/and (cons? (tl (hd V2025))) (clojure.core/and (cons? (tl (tl (hd V2025)))) (clojure.core/and (= () (tl (tl (tl (hd V2025))))) (clojure.core/and (cons? (tl V2025)) (clojure.core/and (= () (tl (tl V2025))) (clojure.core/and (= (quote -) V2026) (shen-dot-prolog_constant? (hd (tl (hd V2025))))))))))))) (clojure.core/let [Z (gensym (quote V))] (cons (quote let) (cons Z (cons (quote shen-dot-be) (cons (cons (quote shen-dot-the) (cons (quote shen-dot-result) (cons (quote shen-dot-of) (cons (quote shen-dot-dereferencing) (tl V2025))))) (cons (quote in) (cons (cons (quote if) (cons (cons Z (cons (quote is) (cons (quote identical) (cons (quote shen-dot-to) (cons (hd (tl (hd V2025))) ()))))) (cons (quote shen-dot-then) (cons (shen-dot-mu_reduction (hd (tl (tl (hd V2025)))) (quote -)) (cons (quote shen-dot-else) (cons (quote shen-dot-failed!) ())))))) ()))))))) (clojure.core/and (cons? V2025) (clojure.core/and (cons? (hd V2025)) (clojure.core/and (= (quote shen-dot-mu) (hd (hd V2025))) (clojure.core/and (cons? (tl (hd V2025))) (clojure.core/and (cons? (tl (tl (hd V2025)))) (clojure.core/and (= () (tl (tl (tl (hd V2025))))) (clojure.core/and (cons? (tl V2025)) (clojure.core/and (= () (tl (tl V2025))) (clojure.core/and (= (quote +) V2026) (shen-dot-prolog_constant? (hd (tl (hd V2025))))))))))))) (clojure.core/let [Z (gensym (quote V))] (cons (quote let) (cons Z (cons (quote shen-dot-be) (cons (cons (quote shen-dot-the) (cons (quote shen-dot-result) (cons (quote shen-dot-of) (cons (quote shen-dot-dereferencing) (tl V2025))))) (cons (quote in) (cons (cons (quote if) (cons (cons Z (cons (quote is) (cons (quote identical) (cons (quote shen-dot-to) (cons (hd (tl (hd V2025))) ()))))) (cons (quote shen-dot-then) (cons (shen-dot-mu_reduction (hd (tl (tl (hd V2025)))) (quote +)) (cons (quote shen-dot-else) (cons (cons (quote if) (cons (cons Z (cons (quote is) (cons (quote shen-dot-a) (cons (quote shen-dot-variable) ())))) (cons (quote shen-dot-then) (cons (cons (quote bind) (cons Z (cons (quote shen-dot-to) (cons (hd (tl (hd V2025))) (cons (quote in) (cons (shen-dot-mu_reduction (hd (tl (tl (hd V2025)))) (quote +)) ())))))) (cons (quote shen-dot-else) (cons (quote shen-dot-failed!) ())))))) ())))))) ()))))))) (clojure.core/and (cons? V2025) (clojure.core/and (cons? (hd V2025)) (clojure.core/and (= (quote shen-dot-mu) (hd (hd V2025))) (clojure.core/and (cons? (tl (hd V2025))) (clojure.core/and (cons? (hd (tl (hd V2025)))) (clojure.core/and (cons? (tl (tl (hd V2025)))) (clojure.core/and (= () (tl (tl (tl (hd V2025))))) (clojure.core/and (cons? (tl V2025)) (clojure.core/and (= () (tl (tl V2025))) (= (quote -) V2026)))))))))) (clojure.core/let [Z (gensym (quote V))] (cons (quote let) (cons Z (cons (quote shen-dot-be) (cons (cons (quote shen-dot-the) (cons (quote shen-dot-result) (cons (quote shen-dot-of) (cons (quote shen-dot-dereferencing) (tl V2025))))) (cons (quote in) (cons (cons (quote if) (cons (cons Z (cons (quote is) (cons (quote shen-dot-a) (cons (quote shen-dot-non-empty) (cons (quote list) ()))))) (cons (quote shen-dot-then) (cons (shen-dot-mu_reduction (cons (cons (quote shen-dot-mu) (cons (hd (hd (tl (hd V2025)))) (cons (cons (cons (quote shen-dot-mu) (cons (tl (hd (tl (hd V2025)))) (tl (tl (hd V2025))))) (cons (cons (quote shen-dot-the) (cons (quote tail) (cons (quote shen-dot-of) (cons Z ())))) ())) ()))) (cons (cons (quote shen-dot-the) (cons (quote head) (cons (quote shen-dot-of) (cons Z ())))) ())) (quote -)) (cons (quote shen-dot-else) (cons (quote shen-dot-failed!) ())))))) ()))))))) (clojure.core/and (cons? V2025) (clojure.core/and (cons? (hd V2025)) (clojure.core/and (= (quote shen-dot-mu) (hd (hd V2025))) (clojure.core/and (cons? (tl (hd V2025))) (clojure.core/and (cons? (hd (tl (hd V2025)))) (clojure.core/and (cons? (tl (tl (hd V2025)))) (clojure.core/and (= () (tl (tl (tl (hd V2025))))) (clojure.core/and (cons? (tl V2025)) (clojure.core/and (= () (tl (tl V2025))) (= (quote +) V2026)))))))))) (clojure.core/let [Z (gensym (quote V))] (cons (quote let) (cons Z (cons (quote shen-dot-be) (cons (cons (quote shen-dot-the) (cons (quote shen-dot-result) (cons (quote shen-dot-of) (cons (quote shen-dot-dereferencing) (tl V2025))))) (cons (quote in) (cons (cons (quote if) (cons (cons Z (cons (quote is) (cons (quote shen-dot-a) (cons (quote shen-dot-non-empty) (cons (quote list) ()))))) (cons (quote shen-dot-then) (cons (shen-dot-mu_reduction (cons (cons (quote shen-dot-mu) (cons (hd (hd (tl (hd V2025)))) (cons (cons (cons (quote shen-dot-mu) (cons (tl (hd (tl (hd V2025)))) (tl (tl (hd V2025))))) (cons (cons (quote shen-dot-the) (cons (quote tail) (cons (quote shen-dot-of) (cons Z ())))) ())) ()))) (cons (cons (quote shen-dot-the) (cons (quote head) (cons (quote shen-dot-of) (cons Z ())))) ())) (quote +)) (cons (quote shen-dot-else) (cons (cons (quote if) (cons (cons Z (cons (quote is) (cons (quote shen-dot-a) (cons (quote shen-dot-variable) ())))) (cons (quote shen-dot-then) (cons (cons (quote shen-dot-rename) (cons (quote shen-dot-the) (cons (quote shen-dot-variables) (cons (quote in) (cons (shen-dot-extract_vars (hd (tl (hd V2025)))) (cons (quote and) (cons (quote shen-dot-then) (cons (cons (quote bind) (cons Z (cons (quote shen-dot-to) (cons (shen-dot-rcons_form (shen-dot-remove_modes (hd (tl (hd V2025))))) (cons (quote in) (cons (shen-dot-mu_reduction (hd (tl (tl (hd V2025)))) (quote +)) ())))))) ())))))))) (cons (quote shen-dot-else) (cons (quote shen-dot-failed!) ())))))) ())))))) ()))))))) true V2025 :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? cons shen-dot-rcons_form hd tl) (clojure.core/defn shen-dot-rcons_form [V2028] (clojure.core/cond (cons? V2028) (cons (quote cons) (cons (shen-dot-rcons_form (hd V2028)) (cons (shen-dot-rcons_form (tl V2028)) ()))) true V2028 :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? = hd tl shen-dot-remove_modes cons) (clojure.core/defn shen-dot-remove_modes [V2030] (clojure.core/cond (clojure.core/and (cons? V2030) (clojure.core/and (= (quote mode) (hd V2030)) (clojure.core/and (cons? (tl V2030)) (clojure.core/and (cons? (tl (tl V2030))) (clojure.core/and (= (quote +) (hd (tl (tl V2030)))) (= () (tl (tl (tl V2030))))))))) (shen-dot-remove_modes (hd (tl V2030))) (clojure.core/and (cons? V2030) (clojure.core/and (= (quote mode) (hd V2030)) (clojure.core/and (cons? (tl V2030)) (clojure.core/and (cons? (tl (tl V2030))) (clojure.core/and (= (quote -) (hd (tl (tl V2030)))) (= () (tl (tl (tl V2030))))))))) (shen-dot-remove_modes (hd (tl V2030))) (cons? V2030) (cons (shen-dot-remove_modes (hd V2030)) (shen-dot-remove_modes (tl V2030))) true V2030 :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-ephemeral_variable? [V2033 V2034] (clojure.core/and (variable? V2033) (variable? V2034))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons?) (clojure.core/defn shen-dot-prolog_constant? [V2044] (clojure.core/cond (cons? V2044) false true true :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? = hd tl cons shen-dot-aum_to_shen) (clojure.core/defn shen-dot-aum_to_shen-fist-cond [V2040] ((shen.primitives/resolve-fn (clojure.core/and (cons? V2040) (clojure.core/and (= (quote let) (hd V2040)) (clojure.core/and (cons? (tl V2040)) (clojure.core/and (cons? (tl (tl V2040))) (clojure.core/and (= (quote shen-dot-be) (hd (tl (tl V2040)))) (clojure.core/and (cons? (tl (tl (tl V2040)))) (clojure.core/and (cons? (tl (tl (tl (tl V2040))))) (clojure.core/and (= (quote in) (hd (tl (tl (tl (tl V2040)))))) (clojure.core/and (cons? (tl (tl (tl (tl (tl V2040)))))) (= () (tl (tl (tl (tl (tl (tl V2040))))))))))))))))) (cons (quote let) (cons (hd (tl V2040)) (cons (shen-dot-aum_to_shen (hd (tl (tl (tl V2040))))) (cons (shen-dot-aum_to_shen (hd (tl (tl (tl (tl (tl V2040))))))) ()))))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? = hd tl cons shen-dot-aum_to_shen shen-dot-chwild shen-dot-call_the_continuation) (clojure.core/defn shen-dot-aum_to_shen [V2046] (clojure.core/cond (quote shen-dot-aum_to_shen-first-cond) 2040 (clojure.core/and (cons? V2046) (clojure.core/and (= (quote shen-dot-the) (hd V2046)) (clojure.core/and (cons? (tl V2046)) (clojure.core/and (= (quote shen-dot-result) (hd (tl V2046))) (clojure.core/and (cons? (tl (tl V2046))) (clojure.core/and (= (quote shen-dot-of) (hd (tl (tl V2046)))) (clojure.core/and (cons? (tl (tl (tl V2046)))) (clojure.core/and (= (quote shen-dot-dereferencing) (hd (tl (tl (tl V2046))))) (clojure.core/and (cons? (tl (tl (tl (tl V2046))))) (= () (tl (tl (tl (tl (tl V2046))))))))))))))) (cons (quote shen-dot-lazyderef) (cons (shen-dot-aum_to_shen (hd (tl (tl (tl (tl V2046)))))) (cons (quote ProcessN) ()))) (clojure.core/and (cons? V2046) (clojure.core/and (= (quote if) (hd V2046)) (clojure.core/and (cons? (tl V2046)) (clojure.core/and (cons? (tl (tl V2046))) (clojure.core/and (= (quote shen-dot-then) (hd (tl (tl V2046)))) (clojure.core/and (cons? (tl (tl (tl V2046)))) (clojure.core/and (cons? (tl (tl (tl (tl V2046))))) (clojure.core/and (= (quote shen-dot-else) (hd (tl (tl (tl (tl V2046)))))) (clojure.core/and (cons? (tl (tl (tl (tl (tl V2046)))))) (= () (tl (tl (tl (tl (tl (tl V2046)))))))))))))))) (cons (quote if) (cons (shen-dot-aum_to_shen (hd (tl V2046))) (cons (shen-dot-aum_to_shen (hd (tl (tl (tl V2046))))) (cons (shen-dot-aum_to_shen (hd (tl (tl (tl (tl (tl V2046))))))) ())))) (clojure.core/and (cons? V2046) (clojure.core/and (cons? (tl V2046)) (clojure.core/and (= (quote is) (hd (tl V2046))) (clojure.core/and (cons? (tl (tl V2046))) (clojure.core/and (= (quote shen-dot-a) (hd (tl (tl V2046)))) (clojure.core/and (cons? (tl (tl (tl V2046)))) (clojure.core/and (= (quote shen-dot-variable) (hd (tl (tl (tl V2046))))) (= () (tl (tl (tl (tl V2046)))))))))))) (cons (quote shen-dot-pvar?) (cons (hd V2046) ())) (clojure.core/and (cons? V2046) (clojure.core/and (cons? (tl V2046)) (clojure.core/and (= (quote is) (hd (tl V2046))) (clojure.core/and (cons? (tl (tl V2046))) (clojure.core/and (= (quote shen-dot-a) (hd (tl (tl V2046)))) (clojure.core/and (cons? (tl (tl (tl V2046)))) (clojure.core/and (= (quote shen-dot-non-empty) (hd (tl (tl (tl V2046))))) (clojure.core/and (cons? (tl (tl (tl (tl V2046))))) (clojure.core/and (= (quote list) (hd (tl (tl (tl (tl V2046)))))) (= () (tl (tl (tl (tl (tl V2046))))))))))))))) (cons (quote cons?) (cons (hd V2046) ())) (clojure.core/and (cons? V2046) (clojure.core/and (= (quote shen-dot-rename) (hd V2046)) (clojure.core/and (cons? (tl V2046)) (clojure.core/and (= (quote shen-dot-the) (hd (tl V2046))) (clojure.core/and (cons? (tl (tl V2046))) (clojure.core/and (= (quote shen-dot-variables) (hd (tl (tl V2046)))) (clojure.core/and (cons? (tl (tl (tl V2046)))) (clojure.core/and (= (quote in) (hd (tl (tl (tl V2046))))) (clojure.core/and (cons? (tl (tl (tl (tl V2046))))) (clojure.core/and (= () (hd (tl (tl (tl (tl V2046)))))) (clojure.core/and (cons? (tl (tl (tl (tl (tl V2046)))))) (clojure.core/and (= (quote and) (hd (tl (tl (tl (tl (tl V2046))))))) (clojure.core/and (cons? (tl (tl (tl (tl (tl (tl V2046))))))) (clojure.core/and (= (quote shen-dot-then) (hd (tl (tl (tl (tl (tl (tl V2046)))))))) (clojure.core/and (cons? (tl (tl (tl (tl (tl (tl (tl V2046)))))))) (= () (tl (tl (tl (tl (tl (tl (tl (tl V2046)))))))))))))))))))))))) (shen-dot-aum_to_shen (hd (tl (tl (tl (tl (tl (tl (tl V2046))))))))) (clojure.core/and (cons? V2046) (clojure.core/and (= (quote shen-dot-rename) (hd V2046)) (clojure.core/and (cons? (tl V2046)) (clojure.core/and (= (quote shen-dot-the) (hd (tl V2046))) (clojure.core/and (cons? (tl (tl V2046))) (clojure.core/and (= (quote shen-dot-variables) (hd (tl (tl V2046)))) (clojure.core/and (cons? (tl (tl (tl V2046)))) (clojure.core/and (= (quote in) (hd (tl (tl (tl V2046))))) (clojure.core/and (cons? (tl (tl (tl (tl V2046))))) (clojure.core/and (cons? (hd (tl (tl (tl (tl V2046)))))) (clojure.core/and (cons? (tl (tl (tl (tl (tl V2046)))))) (clojure.core/and (= (quote and) (hd (tl (tl (tl (tl (tl V2046))))))) (clojure.core/and (cons? (tl (tl (tl (tl (tl (tl V2046))))))) (clojure.core/and (= (quote shen-dot-then) (hd (tl (tl (tl (tl (tl (tl V2046)))))))) (clojure.core/and (cons? (tl (tl (tl (tl (tl (tl (tl V2046)))))))) (= () (tl (tl (tl (tl (tl (tl (tl (tl V2046)))))))))))))))))))))))) (cons (quote let) (cons (hd (hd (tl (tl (tl (tl V2046)))))) (cons (cons (quote shen-dot-newpv) (cons (quote ProcessN) ())) (cons (shen-dot-aum_to_shen (cons (quote shen-dot-rename) (cons (quote shen-dot-the) (cons (quote shen-dot-variables) (cons (quote in) (cons (tl (hd (tl (tl (tl (tl V2046)))))) (tl (tl (tl (tl (tl V2046))))))))))) ())))) (clojure.core/and (cons? V2046) (clojure.core/and (= (quote bind) (hd V2046)) (clojure.core/and (cons? (tl V2046)) (clojure.core/and (cons? (tl (tl V2046))) (clojure.core/and (= (quote shen-dot-to) (hd (tl (tl V2046)))) (clojure.core/and (cons? (tl (tl (tl V2046)))) (clojure.core/and (cons? (tl (tl (tl (tl V2046))))) (clojure.core/and (= (quote in) (hd (tl (tl (tl (tl V2046)))))) (clojure.core/and (cons? (tl (tl (tl (tl (tl V2046)))))) (= () (tl (tl (tl (tl (tl (tl V2046)))))))))))))))) (cons (quote do) (cons (cons (quote shen-dot-bindv) (cons (hd (tl V2046)) (cons (shen-dot-chwild (hd (tl (tl (tl V2046))))) (cons (quote ProcessN) ())))) (cons (cons (quote let) (cons (quote Result) (cons (shen-dot-aum_to_shen (hd (tl (tl (tl (tl (tl V2046))))))) (cons (cons (quote do) (cons (cons (quote shen-dot-unbindv) (cons (hd (tl V2046)) (cons (quote ProcessN) ()))) (cons (quote Result) ()))) ())))) ()))) (clojure.core/and (cons? V2046) (clojure.core/and (cons? (tl V2046)) (clojure.core/and (= (quote is) (hd (tl V2046))) (clojure.core/and (cons? (tl (tl V2046))) (clojure.core/and (= (quote identical) (hd (tl (tl V2046)))) (clojure.core/and (cons? (tl (tl (tl V2046)))) (clojure.core/and (= (quote shen-dot-to) (hd (tl (tl (tl V2046))))) (clojure.core/and (cons? (tl (tl (tl (tl V2046))))) (= () (tl (tl (tl (tl (tl V2046)))))))))))))) (cons (quote =) (cons (hd (tl (tl (tl (tl V2046))))) (cons (hd V2046) ()))) (= (quote shen-dot-failed!) V2046) false (clojure.core/and (cons? V2046) (clojure.core/and (= (quote shen-dot-the) (hd V2046)) (clojure.core/and (cons? (tl V2046)) (clojure.core/and (= (quote head) (hd (tl V2046))) (clojure.core/and (cons? (tl (tl V2046))) (clojure.core/and (= (quote shen-dot-of) (hd (tl (tl V2046)))) (clojure.core/and (cons? (tl (tl (tl V2046)))) (= () (tl (tl (tl (tl V2046)))))))))))) (cons (quote hd) (tl (tl (tl V2046)))) (clojure.core/and (cons? V2046) (clojure.core/and (= (quote shen-dot-the) (hd V2046)) (clojure.core/and (cons? (tl V2046)) (clojure.core/and (= (quote tail) (hd (tl V2046))) (clojure.core/and (cons? (tl (tl V2046))) (clojure.core/and (= (quote shen-dot-of) (hd (tl (tl V2046)))) (clojure.core/and (cons? (tl (tl (tl V2046)))) (= () (tl (tl (tl (tl V2046)))))))))))) (cons (quote tl) (tl (tl (tl V2046)))) (clojure.core/and (cons? V2046) (clojure.core/and (= (quote shen-dot-pop) (hd V2046)) (clojure.core/and (cons? (tl V2046)) (clojure.core/and (= (quote shen-dot-the) (hd (tl V2046))) (clojure.core/and (cons? (tl (tl V2046))) (clojure.core/and (= (quote shen-dot-stack) (hd (tl (tl V2046)))) (= () (tl (tl (tl V2046)))))))))) (cons (quote do) (cons (cons (quote shen-dot-incinfs) ()) (cons (cons (quote thaw) (cons (quote Continuation) ())) ()))) (clojure.core/and (cons? V2046) (clojure.core/and (= (quote call) (hd V2046)) (clojure.core/and (cons? (tl V2046)) (clojure.core/and (= (quote shen-dot-the) (hd (tl V2046))) (clojure.core/and (cons? (tl (tl V2046))) (clojure.core/and (= (quote shen-dot-continuation) (hd (tl (tl V2046)))) (clojure.core/and (cons? (tl (tl (tl V2046)))) (= () (tl (tl (tl (tl V2046)))))))))))) (cons (quote do) (cons (cons (quote shen-dot-incinfs) ()) (cons (shen-dot-call_the_continuation (shen-dot-chwild (hd (tl (tl (tl V2046))))) (quote ProcessN) (quote Continuation)) ()))) true V2046 :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-chwild = cons cons? map) (clojure.core/defn shen-dot-chwild [V2048] (clojure.core/cond (= V2048 (quote _)) (cons (quote shen-dot-newpv) (cons (quote ProcessN) ())) (cons? V2048) (map (do (clojure.core/declare shen-dot-chwild) (clojure.core/fn [Z] (shen-dot-chwild Z))) V2048) true V2048 :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare + <-address value address-> = limit shen-dot-resizeprocessvector shen-dot-mk-pvar) (clojure.core/defn shen-dot-newpv [V2050] (clojure.core/let [Count+1 (+ (<-address (value (quote shen-dot-*varcounter*)) V2050) 1)] (clojure.core/let [IncVar (address-> (value (quote shen-dot-*varcounter*)) V2050 Count+1)] (clojure.core/let [Vector (<-address (value (quote shen-dot-*prologvectors*)) V2050)] (clojure.core/let [ResizeVectorIfNeeded (if (= Count+1 (limit Vector)) (shen-dot-resizeprocessvector V2050 Count+1) (quote shen-dot-skip))] (shen-dot-mk-pvar Count+1))))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-resizeprocessvector [V2053 V2054] (clojure.core/let [Vector (<-address (value (quote shen-dot-*prologvectors*)) V2053)] (clojure.core/let [BigVector (shen-dot-resize-vector Vector (+ V2054 V2054) (quote shen-dot--null-))] (address-> (value (quote shen-dot-*prologvectors*)) V2053 BigVector)))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-resize-vector [V2058 V2059 V2060] (clojure.core/let [BigVector (address-> (absvector (+ 1 V2059)) 0 V2059)] (shen-dot-copy-vector V2058 BigVector (limit V2058) V2059 V2060))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-copy-vector [V2066 V2067 V2068 V2069 V2070] (shen-dot-copy-vector-stage-2 (+ 1 V2068) (+ V2069 1) V2070 (shen-dot-copy-vector-stage-1 1 V2066 V2067 (+ 1 V2068)))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-copy-vector-stage-1 [V2078 V2079 V2080 V2081] (clojure.core/cond (= V2081 V2078) V2080 true (shen-dot-copy-vector-stage-1 (+ 1 V2078) V2079 (address-> V2080 V2078 (<-address V2079 V2078)) V2081) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-copy-vector-stage-2 [V2089 V2090 V2091 V2092] (clojure.core/cond (= V2090 V2089) V2092 true (shen-dot-copy-vector-stage-2 (+ V2089 1) V2090 V2091 (address-> V2092 V2089 V2091)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare address-> absvector) (clojure.core/defn shen-dot-mk-pvar [V2094] (address-> (address-> (absvector 2) 0 (quote shen-dot-pvar)) 1 V2094))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare absvector? = <-address) (clojure.core/defn shen-dot-pvar? [V2096] (clojure.core/and (absvector? V2096) (= (try (<-address V2096 0) (catch Exception e7878 ((clojure.core/fn [E] (quote shen-dot-not-pvar)) e7878))) (quote shen-dot-pvar))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-bindv [V2100 V2101 V2102] (clojure.core/let [Vector (<-address (value (quote shen-dot-*prologvectors*)) V2102)] (address-> Vector (<-address V2100 1) V2101))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-unbindv [V2105 V2106] (clojure.core/let [Vector (<-address (value (quote shen-dot-*prologvectors*)) V2106)] (address-> Vector (<-address V2105 1) (quote shen-dot--null-)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare set + value) (clojure.core/defn shen-dot-incinfs [] (set (quote shen-dot-*infs*) (+ 1 (value (quote shen-dot-*infs*)))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-call_the_continuation [V2110 V2111 V2112] (clojure.core/cond (clojure.core/and (cons? V2110) (clojure.core/and (cons? (hd V2110)) (= () (tl V2110)))) (cons (hd (hd V2110)) (append (tl (hd V2110)) (cons V2111 (cons V2112 ())))) (clojure.core/and (cons? V2110) (cons? (hd V2110))) (clojure.core/let [NewContinuation (shen-dot-newcontinuation (tl V2110) V2111 V2112)] (cons (hd (hd V2110)) (append (tl (hd V2110)) (cons V2111 (cons NewContinuation ()))))) true (shen-dot-f_error (quote shen-dot-call_the_continuation)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-newcontinuation [V2116 V2117 V2118] (clojure.core/cond (= () V2116) V2118 (clojure.core/and (cons? V2116) (cons? (hd V2116))) (cons (quote freeze) (cons (cons (hd (hd V2116)) (append (tl (hd V2116)) (cons V2117 (cons (shen-dot-newcontinuation (tl V2116) V2117 V2118) ())))) ())) true (shen-dot-f_error (quote shen-dot-newcontinuation)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried return [V2126 V2127 V2128] (shen-dot-deref V2126 V2127)))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-measure&return [V2136 V2137 V2138] (do (shen-dot-prhush (shen-dot-app (value (quote shen-dot-*infs*)) " inferences\n" (quote shen-dot-a)) (stoutput)) (shen-dot-deref V2136 V2137))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried unify [V2143 V2144 V2145 V2146] (shen-dot-lzy= (shen-dot-lazyderef V2143 V2145) (shen-dot-lazyderef V2144 V2145) V2145 V2146)))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-lzy= [V2168 V2169 V2170 V2171] (clojure.core/cond (= V2169 V2168) (thaw V2171) (shen-dot-pvar? V2168) (bind V2168 V2169 V2170 V2171) (shen-dot-pvar? V2169) (bind V2169 V2168 V2170 V2171) (clojure.core/and (cons? V2168) (cons? V2169)) (shen-dot-lzy= (shen-dot-lazyderef (hd V2168) V2170) (shen-dot-lazyderef (hd V2169) V2170) V2170 (clojure.core/fn [] (shen-dot-lzy= (shen-dot-lazyderef (tl V2168) V2170) (shen-dot-lazyderef (tl V2169) V2170) V2170 V2171))) true false :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-deref [V2174 V2175] (clojure.core/cond (cons? V2174) (cons (shen-dot-deref (hd V2174) V2175) (shen-dot-deref (tl V2174) V2175)) true (if (shen-dot-pvar? V2174) (clojure.core/let [Value (shen-dot-valvector V2174 V2175)] (if (= Value (quote shen-dot--null-)) V2174 (shen-dot-deref Value V2175))) V2174) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-lazyderef [V2178 V2179] (if (shen-dot-pvar? V2178) (clojure.core/let [Value (shen-dot-valvector V2178 V2179)] (if (= Value (quote shen-dot--null-)) V2178 (shen-dot-lazyderef Value V2179))) V2178)))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-valvector [V2182 V2183] (<-address (<-address (value (quote shen-dot-*prologvectors*)) V2183) (<-address V2182 1))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried unify! [V2188 V2189 V2190 V2191] (shen-dot-lzy=! (shen-dot-lazyderef V2188 V2190) (shen-dot-lazyderef V2189 V2190) V2190 V2191)))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-lzy=! [V2213 V2214 V2215 V2216] (clojure.core/cond (= V2214 V2213) (thaw V2216) (clojure.core/and (shen-dot-pvar? V2213) (not (shen-dot-occurs? V2213 (shen-dot-deref V2214 V2215)))) (bind V2213 V2214 V2215 V2216) (clojure.core/and (shen-dot-pvar? V2214) (not (shen-dot-occurs? V2214 (shen-dot-deref V2213 V2215)))) (bind V2214 V2213 V2215 V2216) (clojure.core/and (cons? V2213) (cons? V2214)) (shen-dot-lzy=! (shen-dot-lazyderef (hd V2213) V2215) (shen-dot-lazyderef (hd V2214) V2215) V2215 (clojure.core/fn [] (shen-dot-lzy=! (shen-dot-lazyderef (tl V2213) V2215) (shen-dot-lazyderef (tl V2214) V2215) V2215 V2216))) true false :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-occurs? [V2228 V2229] (clojure.core/cond (= V2229 V2228) true (cons? V2229) (clojure.core/or (shen-dot-occurs? V2228 (hd V2229)) (shen-dot-occurs? V2228 (tl V2229))) true false :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried identical [V2234 V2235 V2236 V2237] (shen-dot-lzy== (shen-dot-lazyderef V2234 V2236) (shen-dot-lazyderef V2235 V2236) V2236 V2237)))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-lzy== [V2259 V2260 V2261 V2262] (clojure.core/cond (= V2260 V2259) (thaw V2262) (clojure.core/and (cons? V2259) (cons? V2260)) (shen-dot-lzy== (shen-dot-lazyderef (hd V2259) V2261) (shen-dot-lazyderef (hd V2260) V2261) V2261 (clojure.core/fn [] (shen-dot-lzy== (tl V2259) (tl V2260) V2261 V2262))) true false :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cn shen-dot-app <-address) (clojure.core/defn shen-dot-pvar [V2264] (cn "Var" (shen-dot-app (<-address V2264 1) "" (quote shen-dot-a))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried bind [V2269 V2270 V2271 V2272] (do (shen-dot-bindv V2269 V2270 V2271) (clojure.core/let [Result (thaw V2272)] (do (shen-dot-unbindv V2269 V2271) Result)))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried fwhen [V2290 V2291 V2292] (clojure.core/cond (= true V2290) (thaw V2292) (= false V2290) false true (simple-error (cn "fwhen expects a boolean: not " (shen-dot-app V2290 "%" (quote shen-dot-s)))) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried call [V2308 V2309 V2310] (clojure.core/cond (cons? V2308) (shen-dot-call-help (function (shen-dot-lazyderef (hd V2308) V2309)) (tl V2308) V2309 V2310) true false :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-call-help [V2315 V2316 V2317 V2318] (clojure.core/cond (= () V2316) ((shen.primitives/resolve-fn V2315) V2317 V2318) (cons? V2316) (shen-dot-call-help ((shen.primitives/resolve-fn V2315) (hd V2316)) (tl V2316) V2317 V2318) true (shen-dot-f_error (quote shen-dot-call-help)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? hd shen-dot-start-new-prolog-process shen-dot-intprolog-help shen-dot-insert-prolog-variables cons tl shen-dot-f_error) (clojure.core/defn shen-dot-intprolog [V2320] (clojure.core/cond (clojure.core/and (cons? V2320) (cons? (hd V2320))) (clojure.core/let [ProcessN (shen-dot-start-new-prolog-process)] (shen-dot-intprolog-help (hd (hd V2320)) (shen-dot-insert-prolog-variables (cons (tl (hd V2320)) (cons (tl V2320) ())) ProcessN) ProcessN)) true (shen-dot-f_error (quote shen-dot-intprolog)) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-intprolog-help [V2324 V2325 V2326] (clojure.core/cond (clojure.core/and (cons? V2325) (clojure.core/and (cons? (tl V2325)) (= () (tl (tl V2325))))) (shen-dot-intprolog-help-help V2324 (hd V2325) (hd (tl V2325)) V2326) true (shen-dot-f_error (quote shen-dot-intprolog-help)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-intprolog-help-help [V2331 V2332 V2333 V2334] (clojure.core/cond (= () V2332) ((shen.primitives/resolve-fn V2331) V2334 (clojure.core/fn [] (shen-dot-call-rest V2333 V2334))) (cons? V2332) (shen-dot-intprolog-help-help ((shen.primitives/resolve-fn V2331) (hd V2332)) (tl V2332) V2333 V2334) true (shen-dot-f_error (quote shen-dot-intprolog-help-help)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-call-rest [V2339 V2340] (clojure.core/cond (= () V2339) true (clojure.core/and (cons? V2339) (clojure.core/and (cons? (hd V2339)) (cons? (tl (hd V2339))))) (shen-dot-call-rest (cons (cons ((shen.primitives/resolve-fn (hd (hd V2339))) (hd (tl (hd V2339)))) (tl (tl (hd V2339)))) (tl V2339)) V2340) (clojure.core/and (cons? V2339) (clojure.core/and (cons? (hd V2339)) (= () (tl (hd V2339))))) ((shen.primitives/resolve-fn (hd (hd V2339))) V2340 (clojure.core/fn [] (shen-dot-call-rest (tl V2339) V2340))) true (shen-dot-f_error (quote shen-dot-call-rest)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare set + value shen-dot-initialise-prolog) (clojure.core/defn shen-dot-start-new-prolog-process [] (clojure.core/let [IncrementProcessCounter (set (quote shen-dot-*process-counter*) (+ 1 (value (quote shen-dot-*process-counter*))))] (shen-dot-initialise-prolog IncrementProcessCounter)))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-insert-prolog-variables [V2343 V2344] (shen-dot-insert-prolog-variables-help V2343 (shen-dot-flatten V2343) V2344)))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-insert-prolog-variables-help [V2352 V2353 V2354] (clojure.core/cond (= () V2353) V2352 (clojure.core/and (cons? V2353) (variable? (hd V2353))) (clojure.core/let [V (shen-dot-newpv V2354)] (clojure.core/let [XV-slash-Y (subst V (hd V2353) V2352)] (clojure.core/let [Z-Y (remove (hd V2353) (tl V2353))] (shen-dot-insert-prolog-variables-help XV-slash-Y Z-Y V2354)))) (cons? V2353) (shen-dot-insert-prolog-variables-help V2352 (tl V2353) V2354) true (shen-dot-f_error (quote shen-dot-insert-prolog-variables-help)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare address-> value shen-dot-fillvector vector) (clojure.core/defn shen-dot-initialise-prolog [V2356] (clojure.core/let [Vector (address-> (value (quote shen-dot-*prologvectors*)) V2356 (shen-dot-fillvector (vector 10) 1 10 (quote shen-dot--null-)))] (clojure.core/let [Counter (address-> (value (quote shen-dot-*varcounter*)) V2356 1)] V2356)))))
(clojure.core/comment track.kl)
(clojure.core/comment "Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.")
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-prhush cn shen-dot-app stoutput not shen-dot-tracked? y-or-n? shen-dot-track-function ps simple-error) (clojure.core/defn shen-dot-f_error [V4048] (do (shen-dot-prhush (cn "partial function " (shen-dot-app V4048 ";\n" (quote shen-dot-a))) (stoutput)) (do (if (clojure.core/and (not (shen-dot-tracked? V4048)) (y-or-n? (cn "track " (shen-dot-app V4048 "? " (quote shen-dot-a))))) (shen-dot-track-function (ps V4048)) (quote shen-dot-ok)) (simple-error "aborted"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare element? value) (clojure.core/defn shen-dot-tracked? [V4050] (element? V4050 (value (quote shen-dot-*tracking*))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare ps shen-dot-track-function) (clojure.core/defn track [V4052] (clojure.core/let [Source (ps V4052)] (shen-dot-track-function Source)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? = hd tl cons shen-dot-insert-tracking-code eval-kl set value shen-dot-f_error) (clojure.core/defn shen-dot-track-function [V4054] (clojure.core/cond (clojure.core/and (cons? V4054) (clojure.core/and (= (quote defun) (hd V4054)) (clojure.core/and (cons? (tl V4054)) (clojure.core/and (cons? (tl (tl V4054))) (clojure.core/and (cons? (tl (tl (tl V4054)))) (= () (tl (tl (tl (tl V4054)))))))))) (clojure.core/let [KL (cons (quote defun) (cons (hd (tl V4054)) (cons (hd (tl (tl V4054))) (cons (shen-dot-insert-tracking-code (hd (tl V4054)) (hd (tl (tl V4054))) (hd (tl (tl (tl V4054))))) ()))))] (clojure.core/let [Ob (eval-kl KL)] (clojure.core/let [Tr (set (quote shen-dot-*tracking*) (cons Ob (value (quote shen-dot-*tracking*))))] Ob))) true (shen-dot-f_error (quote shen-dot-track-function)) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-insert-tracking-code [V4058 V4059 V4060] (cons (quote do) (cons (cons (quote set) (cons (quote shen-dot-*call*) (cons (cons (quote +) (cons (cons (quote value) (cons (quote shen-dot-*call*) ())) (cons 1 ()))) ()))) (cons (cons (quote do) (cons (cons (quote shen-dot-input-track) (cons (cons (quote value) (cons (quote shen-dot-*call*) ())) (cons V4058 (cons (shen-dot-cons_form V4059) ())))) (cons (cons (quote do) (cons (cons (quote shen-dot-terpri-or-read-char) ()) (cons (cons (quote let) (cons (quote Result) (cons V4060 (cons (cons (quote do) (cons (cons (quote shen-dot-output-track) (cons (cons (quote value) (cons (quote shen-dot-*call*) ())) (cons V4058 (cons (quote Result) ())))) (cons (cons (quote do) (cons (cons (quote set) (cons (quote shen-dot-*call*) (cons (cons (quote -) (cons (cons (quote value) (cons (quote shen-dot-*call*) ())) (cons 1 ()))) ()))) (cons (cons (quote do) (cons (cons (quote shen-dot-terpri-or-read-char) ()) (cons (quote Result) ()))) ()))) ()))) ())))) ()))) ()))) ())))))
(set (quote shen-dot-*step*) false)
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare = set simple-error) (clojure.core/defn step [V4066] (clojure.core/cond (= (quote +) V4066) (set (quote shen-dot-*step*) true) (= (quote -) V4066) (set (quote shen-dot-*step*) false) true (simple-error "step expects a + or a -.\n") :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare = set simple-error) (clojure.core/defn spy [V4072] (clojure.core/cond (= (quote +) V4072) (set (quote shen-dot-*spy*) true) (= (quote -) V4072) (set (quote shen-dot-*spy*) false) true (simple-error "spy expects a + or a -.\n") :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare value shen-dot-check-byte read-byte nl) (clojure.core/defn shen-dot-terpri-or-read-char [] (if (value (quote shen-dot-*step*)) (shen-dot-check-byte (read-byte (value (quote *stinput*)))) (nl 1)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare = shen-dot-hat simple-error) (clojure.core/defn shen-dot-check-byte [V4078] (clojure.core/cond (= V4078 (shen-dot-hat)) (simple-error "aborted") true true :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-input-track [V4082 V4083 V4084] (do (shen-dot-prhush (cn "\n" (shen-dot-app (shen-dot-spaces V4082) (cn "<" (shen-dot-app V4082 (cn "> Inputs to " (shen-dot-app V4083 (cn " \n" (shen-dot-app (shen-dot-spaces V4082) "" (quote shen-dot-a))) (quote shen-dot-a))) (quote shen-dot-a))) (quote shen-dot-a))) (stoutput)) (shen-dot-recursively-print V4084))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare = shen-dot-prhush stoutput cons? print hd shen-dot-recursively-print tl shen-dot-f_error) (clojure.core/defn shen-dot-recursively-print [V4086] (clojure.core/cond (= () V4086) (shen-dot-prhush " ==>" (stoutput)) (cons? V4086) (do (print (hd V4086)) (do (shen-dot-prhush ", " (stoutput)) (shen-dot-recursively-print (tl V4086)))) true (shen-dot-f_error (quote shen-dot-recursively-print)) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare = cn shen-dot-spaces -) (clojure.core/defn shen-dot-spaces [V4088] (clojure.core/cond (= 0 V4088) "" true (cn " " (shen-dot-spaces (- V4088 1))) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-output-track [V4092 V4093 V4094] (shen-dot-prhush (cn "\n" (shen-dot-app (shen-dot-spaces V4092) (cn "<" (shen-dot-app V4092 (cn "> Output from " (shen-dot-app V4093 (cn " \n" (shen-dot-app (shen-dot-spaces V4092) (cn "==> " (shen-dot-app V4094 "" (quote shen-dot-s))) (quote shen-dot-a))) (quote shen-dot-a))) (quote shen-dot-a))) (quote shen-dot-a))) (stoutput))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare value set remove eval ps) (clojure.core/defn untrack [V4096] (clojure.core/let [Tracking (value (quote shen-dot-*tracking*))] (clojure.core/let [Tracking (set (quote shen-dot-*tracking*) (remove V4096 Tracking))] (eval (ps V4096)))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-profile-help ps) (clojure.core/defn profile [V4098] (shen-dot-profile-help (ps V4098)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? = hd tl gensym cons shen-dot-profile-func subst shen-dot-eval-without-macros simple-error) (clojure.core/defn shen-dot-profile-help [V4104] (clojure.core/cond (clojure.core/and (cons? V4104) (clojure.core/and (= (quote defun) (hd V4104)) (clojure.core/and (cons? (tl V4104)) (clojure.core/and (cons? (tl (tl V4104))) (clojure.core/and (cons? (tl (tl (tl V4104)))) (= () (tl (tl (tl (tl V4104)))))))))) (clojure.core/let [G (gensym (quote shen-dot-f))] (clojure.core/let [Profile (cons (quote defun) (cons (hd (tl V4104)) (cons (hd (tl (tl V4104))) (cons (shen-dot-profile-func (hd (tl V4104)) (hd (tl (tl V4104))) (cons G (hd (tl (tl V4104))))) ()))))] (clojure.core/let [Def (cons (quote defun) (cons G (cons (hd (tl (tl V4104))) (cons (subst G (hd (tl V4104)) (hd (tl (tl (tl V4104))))) ()))))] (clojure.core/let [CompileProfile (shen-dot-eval-without-macros Profile)] (clojure.core/let [CompileG (shen-dot-eval-without-macros Def)] (hd (tl V4104))))))) true (simple-error "Cannot profile.\n") :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare untrack) (clojure.core/defn unprofile [V4106] (untrack V4106))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-profile-func [V4110 V4111 V4112] (cons (quote let) (cons (quote Start) (cons (cons (quote get-time) (cons (quote run) ())) (cons (cons (quote let) (cons (quote Result) (cons V4112 (cons (cons (quote let) (cons (quote Finish) (cons (cons (quote -) (cons (cons (quote get-time) (cons (quote run) ())) (cons (quote Start) ()))) (cons (cons (quote let) (cons (quote Record) (cons (cons (quote shen-dot-put-profile) (cons V4110 (cons (cons (quote +) (cons (cons (quote shen-dot-get-profile) (cons V4110 ())) (cons (quote Finish) ()))) ()))) (cons (quote Result) ())))) ())))) ())))) ()))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-get-profile shen-dot-put-profile -at-p) (clojure.core/defn profile-results [V4114] (clojure.core/let [Results (shen-dot-get-profile V4114)] (clojure.core/let [Initialise (shen-dot-put-profile V4114 0)] (-at-p V4114 Results))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare get value) (clojure.core/defn shen-dot-get-profile [V4116] (try (get V4116 (quote profile) (value (quote *property-vector*))) (catch Exception e7901 ((clojure.core/fn [E] 0) e7901))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-put-profile [V4119 V4120] (put V4119 (quote profile) V4120 (value (quote *property-vector*)))))
(clojure.core/comment load.kl)
(clojure.core/comment "Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.")
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare get-time shen-dot-load-help value read-file - shen-dot-prhush cn str stoutput shen-dot-app inferences) (clojure.core/defn load [V1673] (clojure.core/let [Load (clojure.core/let [Start (get-time (quote run))] (clojure.core/let [Result (shen-dot-load-help (value (quote shen-dot-*tc*)) (read-file V1673))] (clojure.core/let [Finish (get-time (quote run))] (clojure.core/let [Time (- Finish Start)] (clojure.core/let [Message (shen-dot-prhush (cn "\nrun time: " (cn (str Time) " secs\n")) (stoutput))] Result)))))] (clojure.core/let [Infs (if (value (quote shen-dot-*tc*)) (shen-dot-prhush (cn "\ntypechecked in " (shen-dot-app (inferences) " inferences\n" (quote shen-dot-a))) (stoutput)) (quote shen-dot-skip))] (quote loaded))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-load-help [V1680 V1681] (clojure.core/cond (= false V1680) (shen-dot-for-each (do (clojure.core/declare shen-dot-prhush shen-dot-app shen-dot-eval-without-macros stoutput) (clojure.core/fn [X] (shen-dot-prhush (shen-dot-app (shen-dot-eval-without-macros X) "\n" (quote shen-dot-s)) (stoutput)))) V1681) true (clojure.core/let [RemoveSynonyms (mapcan (do (clojure.core/declare shen-dot-remove-synonyms) (clojure.core/fn [X] (shen-dot-remove-synonyms X))) V1681)] (clojure.core/let [Table (mapcan (do (clojure.core/declare shen-dot-typetable) (clojure.core/fn [X] (shen-dot-typetable X))) RemoveSynonyms)] (clojure.core/let [Assume (shen-dot-for-each (do (clojure.core/declare shen-dot-assumetype) (clojure.core/fn [X] (shen-dot-assumetype X))) Table)] (try (shen-dot-for-each (do (clojure.core/declare shen-dot-typecheck-and-load) (clojure.core/fn [X] (shen-dot-typecheck-and-load X))) RemoveSynonyms) (catch Exception e7906 ((do (clojure.core/declare shen-dot-unwind-types) (clojure.core/fn [E] (shen-dot-unwind-types E Table))) e7906)))))) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? = hd eval cons) (clojure.core/defn shen-dot-remove-synonyms [V1683] (clojure.core/cond (clojure.core/and (cons? V1683) (= (quote shen-dot-synonyms-help) (hd V1683))) (do (eval V1683) ()) true (cons V1683 ()) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare nl shen-dot-typecheck-and-evaluate gensym) (clojure.core/defn shen-dot-typecheck-and-load [V1685] (do (nl 1) (shen-dot-typecheck-and-evaluate V1685 (gensym (quote A)))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare simple-error shen-dot-app hd tl V1691 cons? = compile shen-dot-<sig+rest> cons) (clojure.core/defn shen-dot-typetable [V1691] (clojure.core/cond (clojure.core/and (cons? V1691) (clojure.core/and (= (quote define) (hd V1691)) (cons? (tl V1691)))) (clojure.core/let [Sig (compile (do (clojure.core/declare shen-dot-<sig+rest>) (clojure.core/fn [Y] (shen-dot-<sig+rest> Y))) (tl (tl V1691)) (do (clojure.core/declare simple-error shen-dot-app hd tl) (clojure.core/fn [E] (simple-error (shen-dot-app (hd (tl V1691)) " lacks a proper signature.\n" (quote shen-dot-a))))))] (cons (cons (hd (tl V1691)) Sig) ())) true () :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? declare hd tl shen-dot-f_error) (clojure.core/defn shen-dot-assumetype [V1693] (clojure.core/cond (cons? V1693) (declare (hd V1693) (tl V1693)) true (shen-dot-f_error (quote shen-dot-assumetype)) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-unwind-types [V1700 V1701] (clojure.core/cond (= () V1701) (simple-error (error-to-string V1700)) (clojure.core/and (cons? V1701) (cons? (hd V1701))) (do (shen-dot-remtype (hd (hd V1701))) (shen-dot-unwind-types V1700 (tl V1701))) true (shen-dot-f_error (quote shen-dot-unwind-types)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare set shen-dot-removetype value) (clojure.core/defn shen-dot-remtype [V1703] (set (quote shen-dot-*signedfuncs*) (shen-dot-removetype V1703 (value (quote shen-dot-*signedfuncs*)))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-removetype [V1711 V1712] (clojure.core/cond (= () V1712) () (clojure.core/and (cons? V1712) (clojure.core/and (cons? (hd V1712)) (= (hd (hd V1712)) V1711))) (shen-dot-removetype (hd (hd V1712)) (tl V1712)) (cons? V1712) (cons (hd V1712) (shen-dot-removetype V1711 (tl V1712))) true (shen-dot-f_error (quote shen-dot-removetype)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-<signature> not = fail <!> shen-dot-pair hd shen-dot-hdtl) (clojure.core/defn shen-dot-<sig+rest> [V1714] (clojure.core/let [Parse_shen-dot-<signature> (shen-dot-<signature> V1714)] (if (not (= (fail) Parse_shen-dot-<signature>)) (clojure.core/let [Parse_<!> (<!> Parse_shen-dot-<signature>)] (if (not (= (fail) Parse_<!>)) (shen-dot-pair (hd Parse_<!>) (shen-dot-hdtl Parse_shen-dot-<signature>)) (fail))) (fail))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried write-to-file [V1717 V1718] (clojure.core/let [Stream (open V1717 (quote out))] (clojure.core/let [String (if (string? V1718) (shen-dot-app V1718 "\n\n" (quote shen-dot-a)) (shen-dot-app V1718 "\n\n" (quote shen-dot-s)))] (clojure.core/let [Write (pr String Stream)] (clojure.core/let [Close (close Stream)] V1718))))))
(clojure.core/comment writer.kl)
(clojure.core/comment "Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.")
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried pr [V4147 V4148] (try (shen-dot-prh V4147 V4148 0) (catch Exception e7923 ((clojure.core/fn [E] V4147) e7923)))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-prh [V4152 V4153 V4154] (shen-dot-prh V4152 V4153 (shen-dot-write-char-and-inc V4152 V4153 V4154))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-write-char-and-inc [V4158 V4159 V4160] (do (write-byte (string->n (pos V4158 V4160)) V4159) (+ V4160 1))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-insert shen-dot-prhush stoutput) (clojure.core/defn print [V4162] (clojure.core/let [String (shen-dot-insert V4162 "~S")] (clojure.core/let [Print (shen-dot-prhush String (stoutput))] V4162)))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-prhush [V4165 V4166] (if (value (quote *hush*)) V4165 (pr V4165 V4166))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-mkstr [V4169 V4170] (clojure.core/cond (string? V4169) (shen-dot-mkstr-l (shen-dot-proc-nl V4169) V4170) true (shen-dot-mkstr-r (cons (quote shen-dot-proc-nl) (cons V4169 ())) V4170) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-mkstr-l [V4173 V4174] (clojure.core/cond (= () V4174) V4173 (cons? V4174) (shen-dot-mkstr-l (shen-dot-insert-l (hd V4174) V4173) (tl V4174)) true (shen-dot-f_error (quote shen-dot-mkstr-l)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-insert-l [V4179 V4180] (clojure.core/cond (= "" V4180) "" (clojure.core/and (shen-dot-+string? V4180) (clojure.core/and (= "~" (pos V4180 0)) (clojure.core/and (shen-dot-+string? (tlstr V4180)) (= "A" (pos (tlstr V4180) 0))))) (cons (quote shen-dot-app) (cons V4179 (cons (tlstr (tlstr V4180)) (cons (quote shen-dot-a) ())))) (clojure.core/and (shen-dot-+string? V4180) (clojure.core/and (= "~" (pos V4180 0)) (clojure.core/and (shen-dot-+string? (tlstr V4180)) (= "R" (pos (tlstr V4180) 0))))) (cons (quote shen-dot-app) (cons V4179 (cons (tlstr (tlstr V4180)) (cons (quote shen-dot-r) ())))) (clojure.core/and (shen-dot-+string? V4180) (clojure.core/and (= "~" (pos V4180 0)) (clojure.core/and (shen-dot-+string? (tlstr V4180)) (= "S" (pos (tlstr V4180) 0))))) (cons (quote shen-dot-app) (cons V4179 (cons (tlstr (tlstr V4180)) (cons (quote shen-dot-s) ())))) (shen-dot-+string? V4180) (shen-dot-factor-cn (cons (quote cn) (cons (pos V4180 0) (cons (shen-dot-insert-l V4179 (tlstr V4180)) ())))) (clojure.core/and (cons? V4180) (clojure.core/and (= (quote cn) (hd V4180)) (clojure.core/and (cons? (tl V4180)) (clojure.core/and (cons? (tl (tl V4180))) (= () (tl (tl (tl V4180)))))))) (cons (quote cn) (cons (hd (tl V4180)) (cons (shen-dot-insert-l V4179 (hd (tl (tl V4180)))) ()))) (clojure.core/and (cons? V4180) (clojure.core/and (= (quote shen-dot-app) (hd V4180)) (clojure.core/and (cons? (tl V4180)) (clojure.core/and (cons? (tl (tl V4180))) (clojure.core/and (cons? (tl (tl (tl V4180)))) (= () (tl (tl (tl (tl V4180)))))))))) (cons (quote shen-dot-app) (cons (hd (tl V4180)) (cons (shen-dot-insert-l V4179 (hd (tl (tl V4180)))) (tl (tl (tl V4180)))))) true (shen-dot-f_error (quote shen-dot-insert-l)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? = hd tl string? cons cn) (clojure.core/defn shen-dot-factor-cn [V4182] (clojure.core/cond (clojure.core/and (cons? V4182) (clojure.core/and (= (quote cn) (hd V4182)) (clojure.core/and (cons? (tl V4182)) (clojure.core/and (cons? (tl (tl V4182))) (clojure.core/and (cons? (hd (tl (tl V4182)))) (clojure.core/and (= (quote cn) (hd (hd (tl (tl V4182))))) (clojure.core/and (cons? (tl (hd (tl (tl V4182))))) (clojure.core/and (cons? (tl (tl (hd (tl (tl V4182)))))) (clojure.core/and (= () (tl (tl (tl (hd (tl (tl V4182))))))) (clojure.core/and (= () (tl (tl (tl V4182)))) (clojure.core/and (string? (hd (tl V4182))) (string? (hd (tl (hd (tl (tl V4182))))))))))))))))) (cons (quote cn) (cons (cn (hd (tl V4182)) (hd (tl (hd (tl (tl V4182)))))) (tl (tl (hd (tl (tl V4182))))))) true V4182 :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare = shen-dot-+string? pos tlstr cn n->string shen-dot-proc-nl shen-dot-f_error) (clojure.core/defn shen-dot-proc-nl [V4184] (clojure.core/cond (= "" V4184) "" (clojure.core/and (shen-dot-+string? V4184) (clojure.core/and (= "~" (pos V4184 0)) (clojure.core/and (shen-dot-+string? (tlstr V4184)) (= "%" (pos (tlstr V4184) 0))))) (cn (n->string 10) (shen-dot-proc-nl (tlstr (tlstr V4184)))) (shen-dot-+string? V4184) (cn (pos V4184 0) (shen-dot-proc-nl (tlstr V4184))) true (shen-dot-f_error (quote shen-dot-proc-nl)) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-mkstr-r [V4187 V4188] (clojure.core/cond (= () V4188) V4187 (cons? V4188) (shen-dot-mkstr-r (cons (quote shen-dot-insert) (cons (hd V4188) (cons V4187 ()))) (tl V4188)) true (shen-dot-f_error (quote shen-dot-mkstr-r)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-insert [V4191 V4192] (shen-dot-insert-h V4191 V4192 "")))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-insert-h [V4198 V4199 V4200] (clojure.core/cond (= "" V4199) V4200 (clojure.core/and (shen-dot-+string? V4199) (clojure.core/and (= "~" (pos V4199 0)) (clojure.core/and (shen-dot-+string? (tlstr V4199)) (= "A" (pos (tlstr V4199) 0))))) (cn V4200 (shen-dot-app V4198 (tlstr (tlstr V4199)) (quote shen-dot-a))) (clojure.core/and (shen-dot-+string? V4199) (clojure.core/and (= "~" (pos V4199 0)) (clojure.core/and (shen-dot-+string? (tlstr V4199)) (= "R" (pos (tlstr V4199) 0))))) (cn V4200 (shen-dot-app V4198 (tlstr (tlstr V4199)) (quote shen-dot-r))) (clojure.core/and (shen-dot-+string? V4199) (clojure.core/and (= "~" (pos V4199 0)) (clojure.core/and (shen-dot-+string? (tlstr V4199)) (= "S" (pos (tlstr V4199) 0))))) (cn V4200 (shen-dot-app V4198 (tlstr (tlstr V4199)) (quote shen-dot-s))) (shen-dot-+string? V4199) (shen-dot-insert-h V4198 (tlstr V4199) (cn V4200 (pos V4199 0))) true (shen-dot-f_error (quote shen-dot-insert-h)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-app [V4204 V4205 V4206] (cn (shen-dot-arg->str V4204 V4206) V4205)))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-arg->str [V4214 V4215] (clojure.core/cond (= V4214 (fail)) "..." (shen-dot-list? V4214) (shen-dot-list->str V4214 V4215) (string? V4214) (shen-dot-str->str V4214 V4215) (absvector? V4214) (shen-dot-vector->str V4214 V4215) true (shen-dot-atom->str V4214) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-list->str [V4218 V4219] (clojure.core/cond (= (quote shen-dot-r) V4219) (-at-s "(" (-at-s (shen-dot-iter-list V4218 (quote shen-dot-r) (shen-dot-maxseq)) ")")) true (-at-s "[" (-at-s (shen-dot-iter-list V4218 V4219 (shen-dot-maxseq)) "]")) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare value) (clojure.core/defn shen-dot-maxseq [] (value (quote *maximum-print-sequence-size*)))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-iter-list [V4233 V4234 V4235] (clojure.core/cond (= () V4233) "" (= 0 V4235) "... etc" (clojure.core/and (cons? V4233) (= () (tl V4233))) (shen-dot-arg->str (hd V4233) V4234) (cons? V4233) (-at-s (shen-dot-arg->str (hd V4233) V4234) (-at-s " " (shen-dot-iter-list (tl V4233) V4234 (- V4235 1)))) true (-at-s "|" (-at-s " " (shen-dot-arg->str V4233 V4234))) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-str->str [V4242 V4243] (clojure.core/cond (= (quote shen-dot-a) V4243) V4242 true (-at-s (n->string 34) (-at-s V4242 (n->string 34))) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-vector->str [V4246 V4247] (if (shen-dot-print-vector? V4246) ((shen.primitives/resolve-fn (function (<-address V4246 0))) V4246) (if (vector? V4246) (-at-s "<" (-at-s (shen-dot-iter-vector V4246 1 V4247 (shen-dot-maxseq)) ">")) (-at-s "<" (-at-s "<" (-at-s (shen-dot-iter-vector V4246 0 V4247 (shen-dot-maxseq)) ">>")))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare <-address = not number? shen-dot-fbound?) (clojure.core/defn shen-dot-print-vector? [V4249] (clojure.core/let [Zero (<-address V4249 0)] (if (= Zero (quote shen-dot-tuple)) true (if (= Zero (quote shen-dot-pvar)) true (if (= Zero (quote shen-dot-dictionary)) true (if (not (number? Zero)) (shen-dot-fbound? Zero) false))))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-lookup-func) (clojure.core/defn shen-dot-fbound? [V4251] (try (do (shen-dot-lookup-func V4251) true) (catch Exception e7930 ((clojure.core/fn [E] false) e7930))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cn shen-dot-app <-address) (clojure.core/defn shen-dot-tuple [V4253] (cn "(@p " (shen-dot-app (<-address V4253 1) (cn " " (shen-dot-app (<-address V4253 2) ")" (quote shen-dot-s))) (quote shen-dot-s))))))
(shen-port.primitives/with-ns (quote shen.functions) (clojure.core/defn shen-dot-dictionary [V4255] "(dict ...)"))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-iter-vector [V4266 V4267 V4268 V4269] (clojure.core/cond (= 0 V4269) "... etc" true (clojure.core/let [Item (try (<-address V4266 V4267) (catch Exception e7936 ((clojure.core/fn [E] (quote shen-dot-out-of-bounds)) e7936)))] (clojure.core/let [Next (try (<-address V4266 (+ V4267 1)) (catch Exception e7938 ((clojure.core/fn [E] (quote shen-dot-out-of-bounds)) e7938)))] (if (= Item (quote shen-dot-out-of-bounds)) "" (if (= Next (quote shen-dot-out-of-bounds)) (shen-dot-arg->str Item V4268) (-at-s (shen-dot-arg->str Item V4268) (-at-s " " (shen-dot-iter-vector V4266 (+ V4267 1) V4268 (- V4269 1)))))))) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare str shen-dot-funexstring) (clojure.core/defn shen-dot-atom->str [V4271] (try (str V4271) (catch Exception e7940 ((do (clojure.core/declare shen-dot-funexstring) (clojure.core/fn [E] (shen-dot-funexstring))) e7940))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare -at-s shen-dot-arg->str gensym intern) (clojure.core/defn shen-dot-funexstring [] (-at-s "" (-at-s "f" (-at-s "u" (-at-s "n" (-at-s "e" (-at-s (shen-dot-arg->str (gensym (intern "x")) (quote shen-dot-a)) "")))))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare empty? cons?) (clojure.core/defn shen-dot-list? [V4273] (clojure.core/or (empty? V4273) (cons? V4273)))))
(clojure.core/comment macros.kl)
(clojure.core/comment "Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.")
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare macroexpand shen-dot-compose value = shen-dot-walk) (clojure.core/defn macroexpand [V1720] (clojure.core/let [Y (shen-dot-compose (value (quote *macros*)) V1720)] (if (= V1720 Y) V1720 (shen-dot-walk (do (clojure.core/declare macroexpand) (clojure.core/fn [Z] (macroexpand Z))) Y))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? = hd tl cons shen-dot-mkstr) (clojure.core/defn shen-dot-error-macro [V1722] (clojure.core/cond (clojure.core/and (cons? V1722) (clojure.core/and (= (quote error) (hd V1722)) (cons? (tl V1722)))) (cons (quote simple-error) (cons (shen-dot-mkstr (hd (tl V1722)) (tl (tl V1722))) ())) true V1722 :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? = hd tl cons shen-dot-mkstr) (clojure.core/defn shen-dot-output-macro [V1724] (clojure.core/cond (clojure.core/and (cons? V1724) (clojure.core/and (= (quote output) (hd V1724)) (cons? (tl V1724)))) (cons (quote shen-dot-prhush) (cons (shen-dot-mkstr (hd (tl V1724)) (tl (tl V1724))) (cons (cons (quote stoutput) ()) ()))) (clojure.core/and (cons? V1724) (clojure.core/and (= (quote pr) (hd V1724)) (clojure.core/and (cons? (tl V1724)) (= () (tl (tl V1724)))))) (cons (quote pr) (cons (hd (tl V1724)) (cons (cons (quote stoutput) ()) ()))) true V1724 :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? = hd tl shen-dot-mkstr) (clojure.core/defn shen-dot-make-string-macro [V1726] (clojure.core/cond (clojure.core/and (cons? V1726) (clojure.core/and (= (quote make-string) (hd V1726)) (cons? (tl V1726)))) (shen-dot-mkstr (hd (tl V1726)) (tl (tl V1726))) true V1726 :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? = hd tl cons) (clojure.core/defn shen-dot-input-macro [V1728] (clojure.core/cond (clojure.core/and (cons? V1728) (clojure.core/and (= (quote lineread) (hd V1728)) (= () (tl V1728)))) (cons (quote lineread) (cons (cons (quote stinput) ()) ())) (clojure.core/and (cons? V1728) (clojure.core/and (= (quote input) (hd V1728)) (= () (tl V1728)))) (cons (quote input) (cons (cons (quote stinput) ()) ())) (clojure.core/and (cons? V1728) (clojure.core/and (= (quote read) (hd V1728)) (= () (tl V1728)))) (cons (quote read) (cons (cons (quote stinput) ()) ())) (clojure.core/and (cons? V1728) (clojure.core/and (= (quote input+) (hd V1728)) (clojure.core/and (cons? (tl V1728)) (= () (tl (tl V1728)))))) (cons (quote input+) (cons (hd (tl V1728)) (cons (cons (quote stinput) ()) ()))) (clojure.core/and (cons? V1728) (clojure.core/and (= (quote read-byte) (hd V1728)) (= () (tl V1728)))) (cons (quote read-byte) (cons (cons (quote stinput) ()) ())) true V1728 :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-compose [V1731 V1732] (clojure.core/cond (= () V1731) V1732 (cons? V1731) (shen-dot-compose (tl V1731) ((shen.primitives/resolve-fn (hd V1731)) V1732)) true (shen-dot-f_error (quote shen-dot-compose)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? = hd tl cons) (clojure.core/defn shen-dot-compile-macro [V1734] (clojure.core/cond (clojure.core/and (cons? V1734) (clojure.core/and (= (quote compile) (hd V1734)) (clojure.core/and (cons? (tl V1734)) (clojure.core/and (cons? (tl (tl V1734))) (= () (tl (tl (tl V1734)))))))) (cons (quote compile) (cons (hd (tl V1734)) (cons (hd (tl (tl V1734))) (cons (cons (quote lambda) (cons (quote E) (cons (cons (quote if) (cons (cons (quote cons?) (cons (quote E) ())) (cons (cons (quote error) (cons "parse error here: ~S~%" (cons (quote E) ()))) (cons (cons (quote error) (cons "parse error~%" ())) ())))) ()))) ())))) true V1734 :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? = hd gensym shen-dot-receive-terms tl eval append cons shen-dot-pass-literals) (clojure.core/defn shen-dot-prolog-macro [V1736] (clojure.core/cond (clojure.core/and (cons? V1736) (= (quote prolog?) (hd V1736))) (clojure.core/let [F (gensym (quote shen-dot-f))] (clojure.core/let [Receive (shen-dot-receive-terms (tl V1736))] (clojure.core/let [PrologDef (eval (append (cons (quote defprolog) (cons F ())) (append Receive (append (cons (quote <--) ()) (append (shen-dot-pass-literals (tl V1736)) (cons (quote -semicol-) ()))))))] (clojure.core/let [Query (cons F (append Receive (cons (cons (quote shen-dot-start-new-prolog-process) ()) (cons (cons (quote freeze) (cons true ())) ()))))] Query)))) true V1736 :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare = cons? hd tl cons shen-dot-receive-terms shen-dot-f_error) (clojure.core/defn shen-dot-receive-terms [V1742] (clojure.core/cond (= () V1742) () (clojure.core/and (cons? V1742) (clojure.core/and (cons? (hd V1742)) (clojure.core/and (= (quote receive) (hd (hd V1742))) (clojure.core/and (cons? (tl (hd V1742))) (= () (tl (tl (hd V1742)))))))) (cons (hd (tl (hd V1742))) (shen-dot-receive-terms (tl V1742))) (cons? V1742) (shen-dot-receive-terms (tl V1742)) true (shen-dot-f_error (quote shen-dot-receive-terms)) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare = cons? hd tl shen-dot-pass-literals cons shen-dot-f_error) (clojure.core/defn shen-dot-pass-literals [V1746] (clojure.core/cond (= () V1746) () (clojure.core/and (cons? V1746) (clojure.core/and (cons? (hd V1746)) (clojure.core/and (= (quote receive) (hd (hd V1746))) (clojure.core/and (cons? (tl (hd V1746))) (= () (tl (tl (hd V1746)))))))) (shen-dot-pass-literals (tl V1746)) (cons? V1746) (cons (hd V1746) (shen-dot-pass-literals (tl V1746))) true (shen-dot-f_error (quote shen-dot-pass-literals)) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-prolog-error hd tl V1748 cons? = compile shen-dot-<defprolog>) (clojure.core/defn shen-dot-defprolog-macro [V1748] (clojure.core/cond (clojure.core/and (cons? V1748) (clojure.core/and (= (quote defprolog) (hd V1748)) (cons? (tl V1748)))) (compile (do (clojure.core/declare shen-dot-<defprolog>) (clojure.core/fn [Y] (shen-dot-<defprolog> Y))) (tl V1748) (do (clojure.core/declare shen-dot-prolog-error hd tl) (clojure.core/fn [Y] (shen-dot-prolog-error (hd (tl V1748)) Y)))) true V1748 :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? = hd tl cons shen-dot-intern-type shen-dot-rcons_form) (clojure.core/defn shen-dot-datatype-macro [V1750] (clojure.core/cond (clojure.core/and (cons? V1750) (clojure.core/and (= (quote datatype) (hd V1750)) (cons? (tl V1750)))) (cons (quote shen-dot-process-datatype) (cons (shen-dot-intern-type (hd (tl V1750))) (cons (cons (quote compile) (cons (cons (quote lambda) (cons (quote X) (cons (cons (quote shen-dot-<datatype-rules>) (cons (quote X) ())) ()))) (cons (shen-dot-rcons_form (tl (tl V1750))) (cons (cons (quote function) (cons (quote shen-dot-datatype-error) ())) ())))) ()))) true V1750 :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare intern cn str) (clojure.core/defn shen-dot-intern-type [V1752] (intern (cn "type#" (str V1752))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? = hd tl cons shen-dot--at-s-macro string? explode > length append) (clojure.core/defn shen-dot--at-s-macro [V1754] (clojure.core/cond (clojure.core/and (cons? V1754) (clojure.core/and (= (quote -at-s) (hd V1754)) (clojure.core/and (cons? (tl V1754)) (clojure.core/and (cons? (tl (tl V1754))) (cons? (tl (tl (tl V1754)))))))) (cons (quote -at-s) (cons (hd (tl V1754)) (cons (shen-dot--at-s-macro (cons (quote -at-s) (tl (tl V1754)))) ()))) (clojure.core/and (cons? V1754) (clojure.core/and (= (quote -at-s) (hd V1754)) (clojure.core/and (cons? (tl V1754)) (clojure.core/and (cons? (tl (tl V1754))) (clojure.core/and (= () (tl (tl (tl V1754)))) (string? (hd (tl V1754)))))))) (clojure.core/let [E (explode (hd (tl V1754)))] (if (> (length E) 1) (shen-dot--at-s-macro (cons (quote -at-s) (append E (tl (tl V1754))))) V1754)) true V1754 :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? = hd cons shen-dot-rcons_form shen-dot-curry-synonyms tl) (clojure.core/defn shen-dot-synonyms-macro [V1756] (clojure.core/cond (clojure.core/and (cons? V1756) (= (quote synonyms) (hd V1756))) (cons (quote shen-dot-synonyms-help) (cons (shen-dot-rcons_form (shen-dot-curry-synonyms (tl V1756))) ())) true V1756 :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-curry-type map) (clojure.core/defn shen-dot-curry-synonyms [V1758] (map (do (clojure.core/declare shen-dot-curry-type) (clojure.core/fn [X] (shen-dot-curry-type X))) V1758))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? = hd tl cons) (clojure.core/defn shen-dot-nl-macro [V1760] (clojure.core/cond (clojure.core/and (cons? V1760) (clojure.core/and (= (quote nl) (hd V1760)) (= () (tl V1760)))) (cons (quote nl) (cons 1 ())) true V1760 :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? tl element? hd cons shen-dot-assoc-macro) (clojure.core/defn shen-dot-assoc-macro [V1762] (clojure.core/cond (clojure.core/and (cons? V1762) (clojure.core/and (cons? (tl V1762)) (clojure.core/and (cons? (tl (tl V1762))) (clojure.core/and (cons? (tl (tl (tl V1762)))) (element? (hd V1762) (cons (quote -at-p) (cons (quote -at-v) (cons (quote append) (cons (quote and) (cons (quote or) (cons (quote +) (cons (quote *) (cons (quote do) ()))))))))))))) (cons (hd V1762) (cons (hd (tl V1762)) (cons (shen-dot-assoc-macro (cons (hd V1762) (tl (tl V1762)))) ()))) true V1762 :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? = hd tl cons shen-dot-let-macro) (clojure.core/defn shen-dot-let-macro [V1764] (clojure.core/cond (clojure.core/and (cons? V1764) (clojure.core/and (= (quote let) (hd V1764)) (clojure.core/and (cons? (tl V1764)) (clojure.core/and (cons? (tl (tl V1764))) (clojure.core/and (cons? (tl (tl (tl V1764)))) (cons? (tl (tl (tl (tl V1764)))))))))) (cons (quote let) (cons (hd (tl V1764)) (cons (hd (tl (tl V1764))) (cons (shen-dot-let-macro (cons (quote let) (tl (tl (tl V1764))))) ())))) true V1764 :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? = hd tl cons shen-dot-abs-macro) (clojure.core/defn shen-dot-abs-macro [V1766] (clojure.core/cond (clojure.core/and (cons? V1766) (clojure.core/and (= (quote -slash--dot-) (hd V1766)) (clojure.core/and (cons? (tl V1766)) (clojure.core/and (cons? (tl (tl V1766))) (cons? (tl (tl (tl V1766)))))))) (cons (quote lambda) (cons (hd (tl V1766)) (cons (shen-dot-abs-macro (cons (quote -slash--dot-) (tl (tl V1766)))) ()))) (clojure.core/and (cons? V1766) (clojure.core/and (= (quote -slash--dot-) (hd V1766)) (clojure.core/and (cons? (tl V1766)) (clojure.core/and (cons? (tl (tl V1766))) (= () (tl (tl (tl V1766)))))))) (cons (quote lambda) (tl V1766)) true V1766 :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? = hd tl cons shen-dot-cases-macro simple-error) (clojure.core/defn shen-dot-cases-macro [V1770] (clojure.core/cond (clojure.core/and (cons? V1770) (clojure.core/and (= (quote cases) (hd V1770)) (clojure.core/and (cons? (tl V1770)) (clojure.core/and (= true (hd (tl V1770))) (cons? (tl (tl V1770))))))) (hd (tl (tl V1770))) (clojure.core/and (cons? V1770) (clojure.core/and (= (quote cases) (hd V1770)) (clojure.core/and (cons? (tl V1770)) (clojure.core/and (cons? (tl (tl V1770))) (= () (tl (tl (tl V1770)))))))) (cons (quote if) (cons (hd (tl V1770)) (cons (hd (tl (tl V1770))) (cons (cons (quote simple-error) (cons "error: cases exhausted" ())) ())))) (clojure.core/and (cons? V1770) (clojure.core/and (= (quote cases) (hd V1770)) (clojure.core/and (cons? (tl V1770)) (cons? (tl (tl V1770)))))) (cons (quote if) (cons (hd (tl V1770)) (cons (hd (tl (tl V1770))) (cons (shen-dot-cases-macro (cons (quote cases) (tl (tl (tl V1770))))) ())))) (clojure.core/and (cons? V1770) (clojure.core/and (= (quote cases) (hd V1770)) (clojure.core/and (cons? (tl V1770)) (= () (tl (tl V1770)))))) (simple-error "error: odd number of case elements\n") true V1770 :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? = hd tl shen-dot-let-macro cons) (clojure.core/defn shen-dot-timer-macro [V1772] (clojure.core/cond (clojure.core/and (cons? V1772) (clojure.core/and (= (quote time) (hd V1772)) (clojure.core/and (cons? (tl V1772)) (= () (tl (tl V1772)))))) (shen-dot-let-macro (cons (quote let) (cons (quote Start) (cons (cons (quote get-time) (cons (quote run) ())) (cons (quote Result) (cons (hd (tl V1772)) (cons (quote Finish) (cons (cons (quote get-time) (cons (quote run) ())) (cons (quote Time) (cons (cons (quote -) (cons (quote Finish) (cons (quote Start) ()))) (cons (quote Message) (cons (cons (quote shen-dot-prhush) (cons (cons (quote cn) (cons "\nrun time: " (cons (cons (quote cn) (cons (cons (quote str) (cons (quote Time) ())) (cons " secs\n" ()))) ()))) (cons (cons (quote stoutput) ()) ()))) (cons (quote Result) ()))))))))))))) true V1772 :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? cons hd shen-dot-tuple-up tl) (clojure.core/defn shen-dot-tuple-up [V1774] (clojure.core/cond (cons? V1774) (cons (quote -at-p) (cons (hd V1774) (cons (shen-dot-tuple-up (tl V1774)) ()))) true V1774 :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? = hd tl cons) (clojure.core/defn shen-dot-put-slash-get-macro [V1776] (clojure.core/cond (clojure.core/and (cons? V1776) (clojure.core/and (= (quote put) (hd V1776)) (clojure.core/and (cons? (tl V1776)) (clojure.core/and (cons? (tl (tl V1776))) (clojure.core/and (cons? (tl (tl (tl V1776)))) (= () (tl (tl (tl (tl V1776)))))))))) (cons (quote put) (cons (hd (tl V1776)) (cons (hd (tl (tl V1776))) (cons (hd (tl (tl (tl V1776)))) (cons (cons (quote value) (cons (quote *property-vector*) ())) ()))))) (clojure.core/and (cons? V1776) (clojure.core/and (= (quote get) (hd V1776)) (clojure.core/and (cons? (tl V1776)) (clojure.core/and (cons? (tl (tl V1776))) (= () (tl (tl (tl V1776)))))))) (cons (quote get) (cons (hd (tl V1776)) (cons (hd (tl (tl V1776))) (cons (cons (quote value) (cons (quote *property-vector*) ())) ())))) (clojure.core/and (cons? V1776) (clojure.core/and (= (quote unput) (hd V1776)) (clojure.core/and (cons? (tl V1776)) (clojure.core/and (cons? (tl (tl V1776))) (= () (tl (tl (tl V1776)))))))) (cons (quote unput) (cons (hd (tl V1776)) (cons (hd (tl (tl V1776))) (cons (cons (quote value) (cons (quote *property-vector*) ())) ())))) true V1776 :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? = hd tl shen-dot-function-abstraction arity) (clojure.core/defn shen-dot-function-macro [V1778] (clojure.core/cond (clojure.core/and (cons? V1778) (clojure.core/and (= (quote function) (hd V1778)) (clojure.core/and (cons? (tl V1778)) (= () (tl (tl V1778)))))) (shen-dot-function-abstraction (hd (tl V1778)) (arity (hd (tl V1778)))) true V1778 :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-function-abstraction [V1781 V1782] (clojure.core/cond (= 0 V1782) (simple-error (shen-dot-app V1781 " has no lambda form\n" (quote shen-dot-a))) (= -1 V1782) (cons (quote function) (cons V1781 ())) true (shen-dot-function-abstraction-help V1781 V1782 ()) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-function-abstraction-help [V1786 V1787 V1788] (clojure.core/cond (= 0 V1787) (cons V1786 V1788) true (clojure.core/let [X (gensym (quote V))] (cons (quote -slash--dot-) (cons X (cons (shen-dot-function-abstraction-help V1786 (- V1787 1) (append V1788 (cons X ()))) ())))) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare value shen-dot-findpos set remove shen-dot-remove-nth) (clojure.core/defn undefmacro [V1790] (clojure.core/let [MacroReg (value (quote shen-dot-*macroreg*))] (clojure.core/let [Pos (shen-dot-findpos V1790 MacroReg)] (clojure.core/let [Remove1 (set (quote shen-dot-*macroreg*) (remove V1790 MacroReg))] (clojure.core/let [Remove2 (set (quote *macros*) (shen-dot-remove-nth Pos (value (quote *macros*))))] V1790)))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-findpos [V1800 V1801] (clojure.core/cond (= () V1801) (simple-error (shen-dot-app V1800 " is not a macro\n" (quote shen-dot-a))) (clojure.core/and (cons? V1801) (= (hd V1801) V1800)) 1 (cons? V1801) (+ 1 (shen-dot-findpos V1800 (tl V1801))) true (shen-dot-f_error (quote shen-dot-findpos)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-remove-nth [V1806 V1807] (clojure.core/cond (clojure.core/and (= 1 V1806) (cons? V1807)) (tl V1807) (cons? V1807) (cons (hd V1807) (shen-dot-remove-nth (- V1806 1) (tl V1807))) true (shen-dot-f_error (quote shen-dot-remove-nth)) :else (throw (Exception. "No matching cond clause")))))
(clojure.core/comment declarations.kl)
(clojure.core/comment "Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.")
(set (quote shen-dot-*installing-kl*) false)
(set (quote shen-dot-*history*) ())
(set (quote shen-dot-*tc*) false)
(set (quote *property-vector*) (shen-dot-dict 20000))
(set (quote shen-dot-*process-counter*) 0)
(set (quote shen-dot-*varcounter*) (vector 10000))
(set (quote shen-dot-*prologvectors*) (vector 10000))
(set (quote shen-dot-*demodulation-function*) (clojure.core/fn [X] X))
(set (quote shen-dot-*macroreg*) (cons (quote shen-dot-timer-macro) (cons (quote shen-dot-cases-macro) (cons (quote shen-dot-abs-macro) (cons (quote shen-dot-put-slash-get-macro) (cons (quote shen-dot-compile-macro) (cons (quote shen-dot-datatype-macro) (cons (quote shen-dot-let-macro) (cons (quote shen-dot-assoc-macro) (cons (quote shen-dot-make-string-macro) (cons (quote shen-dot-output-macro) (cons (quote shen-dot-input-macro) (cons (quote shen-dot-error-macro) (cons (quote shen-dot-prolog-macro) (cons (quote shen-dot-synonyms-macro) (cons (quote shen-dot-nl-macro) (cons (quote shen-dot--at-s-macro) (cons (quote shen-dot-defprolog-macro) (cons (quote shen-dot-function-macro) ())))))))))))))))))))
(set (quote *macros*) (cons (do (clojure.core/declare shen-dot-timer-macro) (clojure.core/fn [X] (shen-dot-timer-macro X))) (cons (do (clojure.core/declare shen-dot-cases-macro) (clojure.core/fn [X] (shen-dot-cases-macro X))) (cons (do (clojure.core/declare shen-dot-abs-macro) (clojure.core/fn [X] (shen-dot-abs-macro X))) (cons (do (clojure.core/declare shen-dot-put-slash-get-macro) (clojure.core/fn [X] (shen-dot-put-slash-get-macro X))) (cons (do (clojure.core/declare shen-dot-compile-macro) (clojure.core/fn [X] (shen-dot-compile-macro X))) (cons (do (clojure.core/declare shen-dot-datatype-macro) (clojure.core/fn [X] (shen-dot-datatype-macro X))) (cons (do (clojure.core/declare shen-dot-let-macro) (clojure.core/fn [X] (shen-dot-let-macro X))) (cons (do (clojure.core/declare shen-dot-assoc-macro) (clojure.core/fn [X] (shen-dot-assoc-macro X))) (cons (do (clojure.core/declare shen-dot-make-string-macro) (clojure.core/fn [X] (shen-dot-make-string-macro X))) (cons (do (clojure.core/declare shen-dot-output-macro) (clojure.core/fn [X] (shen-dot-output-macro X))) (cons (do (clojure.core/declare shen-dot-input-macro) (clojure.core/fn [X] (shen-dot-input-macro X))) (cons (do (clojure.core/declare shen-dot-error-macro) (clojure.core/fn [X] (shen-dot-error-macro X))) (cons (do (clojure.core/declare shen-dot-prolog-macro) (clojure.core/fn [X] (shen-dot-prolog-macro X))) (cons (do (clojure.core/declare shen-dot-synonyms-macro) (clojure.core/fn [X] (shen-dot-synonyms-macro X))) (cons (do (clojure.core/declare shen-dot-nl-macro) (clojure.core/fn [X] (shen-dot-nl-macro X))) (cons (do (clojure.core/declare shen-dot--at-s-macro) (clojure.core/fn [X] (shen-dot--at-s-macro X))) (cons (do (clojure.core/declare shen-dot-defprolog-macro) (clojure.core/fn [X] (shen-dot-defprolog-macro X))) (cons (do (clojure.core/declare shen-dot-function-macro) (clojure.core/fn [X] (shen-dot-function-macro X))) ())))))))))))))))))))
(set (quote shen-dot-*gensym*) 0)
(set (quote shen-dot-*tracking*) ())
(set (quote shen-dot-*alphabet*) (cons (quote A) (cons (quote B) (cons (quote C) (cons (quote D) (cons (quote E) (cons (quote F) (cons (quote G) (cons (quote H) (cons (quote I) (cons (quote J) (cons (quote K) (cons (quote L) (cons (quote M) (cons (quote N) (cons (quote O) (cons (quote P) (cons (quote Q) (cons (quote R) (cons (quote S) (cons (quote T) (cons (quote U) (cons (quote V) (cons (quote W) (cons (quote X) (cons (quote Y) (cons (quote Z) ())))))))))))))))))))))))))))
(set (quote shen-dot-*special*) (cons (quote -at-p) (cons (quote -at-s) (cons (quote -at-v) (cons (quote cons) (cons (quote lambda) (cons (quote let) (cons (quote where) (cons (quote set) (cons (quote open) ()))))))))))
(set (quote shen-dot-*extraspecial*) (cons (quote define) (cons (quote shen-dot-process-datatype) (cons (quote input+) (cons (quote defcc) (cons (quote shen-dot-read+) (cons (quote defmacro) ())))))))
(set (quote shen-dot-*spy*) false)
(set (quote shen-dot-*datatypes*) ())
(set (quote shen-dot-*alldatatypes*) ())
(set (quote shen-dot-*shen-type-theory-enabled?*) true)
(set (quote shen-dot-*synonyms*) ())
(set (quote shen-dot-*system*) ())
(set (quote shen-dot-*signedfuncs*) ())
(set (quote shen-dot-*maxcomplexity*) 128)
(set (quote shen-dot-*occurs*) true)
(set (quote shen-dot-*maxinferences*) 1000000)
(set (quote *maximum-print-sequence-size*) 20)
(set (quote shen-dot-*catch*) 0)
(set (quote shen-dot-*call*) 0)
(set (quote shen-dot-*infs*) 0)
(set (quote *hush*) false)
(set (quote shen-dot-*optimise*) false)
(set (quote *version*) "Shen 21")
(if (not (bound? (quote *home-directory*))) (set (quote *home-directory*) "") (quote shen-dot-skip))
(if (not (bound? (quote *sterror*))) (set (quote *sterror*) (value (quote *stoutput*))) (quote shen-dot-skip))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare = cons? tl put hd value shen-dot-initialise_arity_table shen-dot-f_error) (clojure.core/defn shen-dot-initialise_arity_table [V1647] (clojure.core/cond (= () V1647) () (clojure.core/and (cons? V1647) (cons? (tl V1647))) (clojure.core/let [DecArity (put (hd V1647) (quote arity) (hd (tl V1647)) (value (quote *property-vector*)))] (shen-dot-initialise_arity_table (tl (tl V1647)))) true (shen-dot-f_error (quote shen-dot-initialise_arity_table)) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare get value) (clojure.core/defn arity [V1649] (try (get V1649 (quote arity) (value (quote *property-vector*))) (catch Exception e7999 ((clojure.core/fn [E] -1) e7999))))))
(shen-dot-initialise_arity_table (cons (quote abort) (cons 0 (cons (quote absvector?) (cons 1 (cons (quote absvector) (cons 1 (cons (quote adjoin) (cons 2 (cons (quote and) (cons 2 (cons (quote append) (cons 2 (cons (quote arity) (cons 1 (cons (quote assoc) (cons 2 (cons (quote boolean?) (cons 1 (cons (quote bound?) (cons 1 (cons (quote cd) (cons 1 (cons (quote close) (cons 1 (cons (quote compile) (cons 3 (cons (quote concat) (cons 2 (cons (quote cons) (cons 2 (cons (quote cons?) (cons 1 (cons (quote cn) (cons 2 (cons (quote declare) (cons 2 (cons (quote destroy) (cons 1 (cons (quote difference) (cons 2 (cons (quote do) (cons 2 (cons (quote element?) (cons 2 (cons (quote empty?) (cons 1 (cons (quote enable-type-theory) (cons 1 (cons (quote error-to-string) (cons 1 (cons (quote shen-dot-interror) (cons 2 (cons (quote eval) (cons 1 (cons (quote eval-kl) (cons 1 (cons (quote explode) (cons 1 (cons (quote external) (cons 1 (cons (quote fail-if) (cons 2 (cons (quote fail) (cons 0 (cons (quote fix) (cons 2 (cons (quote findall) (cons 5 (cons (quote freeze) (cons 1 (cons (quote fst) (cons 1 (cons (quote gensym) (cons 1 (cons (quote get) (cons 3 (cons (quote get-time) (cons 1 (cons (quote address->) (cons 3 (cons (quote <-address) (cons 2 (cons (quote <-vector) (cons 2 (cons (quote >) (cons 2 (cons (quote >=) (cons 2 (cons (quote =) (cons 2 (cons (quote hash) (cons 2 (cons (quote hd) (cons 1 (cons (quote hdv) (cons 1 (cons (quote hdstr) (cons 1 (cons (quote head) (cons 1 (cons (quote if) (cons 3 (cons (quote integer?) (cons 1 (cons (quote intern) (cons 1 (cons (quote identical) (cons 4 (cons (quote inferences) (cons 0 (cons (quote input) (cons 1 (cons (quote input+) (cons 2 (cons (quote implementation) (cons 0 (cons (quote intersection) (cons 2 (cons (quote internal) (cons 1 (cons (quote it) (cons 0 (cons (quote kill) (cons 0 (cons (quote language) (cons 0 (cons (quote length) (cons 1 (cons (quote limit) (cons 1 (cons (quote lineread) (cons 1 (cons (quote load) (cons 1 (cons (quote <) (cons 2 (cons (quote <=) (cons 2 (cons (quote vector) (cons 1 (cons (quote macroexpand) (cons 1 (cons (quote map) (cons 2 (cons (quote mapcan) (cons 2 (cons (quote maxinferences) (cons 1 (cons (quote nl) (cons 1 (cons (quote not) (cons 1 (cons (quote nth) (cons 2 (cons (quote n->string) (cons 1 (cons (quote number?) (cons 1 (cons (quote occurs-check) (cons 1 (cons (quote occurrences) (cons 2 (cons (quote occurs-check) (cons 1 (cons (quote open) (cons 2 (cons (quote optimise) (cons 1 (cons (quote or) (cons 2 (cons (quote os) (cons 0 (cons (quote package) (cons 3 (cons (quote package?) (cons 1 (cons (quote port) (cons 0 (cons (quote porters) (cons 0 (cons (quote pos) (cons 2 (cons (quote print) (cons 1 (cons (quote profile) (cons 1 (cons (quote profile-results) (cons 1 (cons (quote pr) (cons 2 (cons (quote ps) (cons 1 (cons (quote preclude) (cons 1 (cons (quote preclude-all-but) (cons 1 (cons (quote protect) (cons 1 (cons (quote address->) (cons 3 (cons (quote put) (cons 4 (cons (quote shen-dot-reassemble) (cons 2 (cons (quote read-file-as-string) (cons 1 (cons (quote read-file) (cons 1 (cons (quote read-file-as-bytelist) (cons 1 (cons (quote read) (cons 1 (cons (quote read-byte) (cons 1 (cons (quote read-from-string) (cons 1 (cons (quote receive) (cons 1 (cons (quote release) (cons 0 (cons (quote remove) (cons 2 (cons (quote shen-dot-require) (cons 3 (cons (quote reverse) (cons 1 (cons (quote set) (cons 2 (cons (quote simple-error) (cons 1 (cons (quote snd) (cons 1 (cons (quote specialise) (cons 1 (cons (quote spy) (cons 1 (cons (quote step) (cons 1 (cons (quote stinput) (cons 0 (cons (quote stoutput) (cons 0 (cons (quote sterror) (cons 0 (cons (quote string->n) (cons 1 (cons (quote string->symbol) (cons 1 (cons (quote string?) (cons 1 (cons (quote str) (cons 1 (cons (quote subst) (cons 3 (cons (quote sum) (cons 1 (cons (quote symbol?) (cons 1 (cons (quote systemf) (cons 1 (cons (quote tail) (cons 1 (cons (quote tl) (cons 1 (cons (quote tc) (cons 1 (cons (quote tc?) (cons 0 (cons (quote thaw) (cons 1 (cons (quote tlstr) (cons 1 (cons (quote track) (cons 1 (cons (quote trap-error) (cons 2 (cons (quote tuple?) (cons 1 (cons (quote type) (cons 2 (cons (quote return) (cons 3 (cons (quote undefmacro) (cons 1 (cons (quote unput) (cons 3 (cons (quote unprofile) (cons 1 (cons (quote unify) (cons 4 (cons (quote unify!) (cons 4 (cons (quote union) (cons 2 (cons (quote untrack) (cons 1 (cons (quote unspecialise) (cons 1 (cons (quote undefmacro) (cons 1 (cons (quote vector) (cons 1 (cons (quote vector?) (cons 1 (cons (quote vector->) (cons 3 (cons (quote value) (cons 1 (cons (quote variable?) (cons 1 (cons (quote version) (cons 0 (cons (quote write-byte) (cons 2 (cons (quote write-to-file) (cons 2 (cons (quote y-or-n?) (cons 1 (cons (quote +) (cons 2 (cons (quote *) (cons 2 (cons (quote /) (cons 2 (cons (quote -) (cons 2 (cons (quote ==) (cons 2 (cons (quote <e>) (cons 1 (cons (quote <!>) (cons 1 (cons (quote -at-p) (cons 2 (cons (quote -at-v) (cons 2 (cons (quote -at-s) (cons 2 (cons (quote preclude) (cons 1 (cons (quote include) (cons 1 (cons (quote preclude-all-but) (cons 1 (cons (quote include-all-but) (cons 1 ())))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare intern get value put adjoin) (clojure.core/defn systemf [V1651] (clojure.core/let [Shen (intern "shen")] (clojure.core/let [External (get Shen (quote shen-dot-external-symbols) (value (quote *property-vector*)))] (clojure.core/let [Place (put Shen (quote shen-dot-external-symbols) (adjoin V1651 External) (value (quote *property-vector*)))] V1651))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried adjoin [V1654 V1655] (if (element? V1654 V1655) V1655 (cons V1654 V1655))))
(put (intern "shen") (quote shen-dot-external-symbols) (cons (quote !) (cons (quote -rcurlybrac-) (cons (quote -lcurlybrac-) (cons (quote -->) (cons (quote <--) (cons (quote &&) (cons (quote -colon-) (cons (quote -semicol-) (cons (quote -colon--) (cons (quote -colon-=) (cons (quote _) (cons (quote -comma-) (cons (quote *language*) (cons (quote *implementation*) (cons (quote *stinput*) (cons (quote *stoutput*) (cons (quote *sterror*) (cons (quote *home-directory*) (cons (quote *version*) (cons (quote *maximum-print-sequence-size*) (cons (quote *macros*) (cons (quote *os*) (cons (quote *release*) (cons (quote *property-vector*) (cons (quote *port*) (cons (quote *porters*) (cons (quote *hush*) (cons (quote -at-v) (cons (quote -at-p) (cons (quote -at-s) (cons (quote <-) (cons (quote ->) (cons (quote <e>) (cons (quote <!>) (cons (quote ==) (cons (quote =) (cons (quote >=) (cons (quote >) (cons (quote -slash--dot-) (cons (quote =!) (cons (quote $) (cons (quote -) (cons (quote /) (cons (quote *) (cons (quote +) (cons (quote <=) (cons (quote <) (cons (quote >>) (cons (vector 0) (cons (quote y-or-n?) (cons (quote write-to-file) (cons (quote write-byte) (cons (quote where) (cons (quote when) (cons (quote warn) (cons (quote version) (cons (quote verified) (cons (quote variable?) (cons (quote value) (cons (quote vector->) (cons (quote <-vector) (cons (quote vector) (cons (quote vector?) (cons (quote unspecialise) (cons (quote untrack) (cons (quote unit) (cons (quote shen-dot-unix) (cons (quote union) (cons (quote unify) (cons (quote unify!) (cons (quote unput) (cons (quote unprofile) (cons (quote undefmacro) (cons (quote return) (cons (quote type) (cons (quote tuple?) (cons true (cons (quote trap-error) (cons (quote track) (cons (quote time) (cons (quote thaw) (cons (quote tc?) (cons (quote tc) (cons (quote tl) (cons (quote tlstr) (cons (quote tlv) (cons (quote tail) (cons (quote systemf) (cons (quote synonyms) (cons (quote symbol) (cons (quote symbol?) (cons (quote string->symbol) (cons (quote sum) (cons (quote subst) (cons (quote string?) (cons (quote string->n) (cons (quote stream) (cons (quote string) (cons (quote stinput) (cons (quote sterror) (cons (quote stoutput) (cons (quote step) (cons (quote spy) (cons (quote specialise) (cons (quote snd) (cons (quote simple-error) (cons (quote set) (cons (quote save) (cons (quote str) (cons (quote run) (cons (quote reverse) (cons (quote remove) (cons (quote release) (cons (quote read) (cons (quote receive) (cons (quote read-file) (cons (quote read-file-as-bytelist) (cons (quote read-file-as-string) (cons (quote read-byte) (cons (quote read-from-string) (cons (quote package?) (cons (quote put) (cons (quote preclude) (cons (quote preclude-all-but) (cons (quote ps) (cons (quote prolog?) (cons (quote protect) (cons (quote profile-results) (cons (quote profile) (cons (quote print) (cons (quote pr) (cons (quote pos) (cons (quote porters) (cons (quote port) (cons (quote package) (cons (quote output) (cons (quote out) (cons (quote os) (cons (quote or) (cons (quote optimise) (cons (quote open) (cons (quote occurrences) (cons (quote occurs-check) (cons (quote n->string) (cons (quote number?) (cons (quote number) (cons (quote null) (cons (quote nth) (cons (quote not) (cons (quote nl) (cons (quote mode) (cons (quote macroexpand) (cons (quote maxinferences) (cons (quote mapcan) (cons (quote map) (cons (quote make-string) (cons (quote load) (cons (quote loaded) (cons (quote list) (cons (quote lineread) (cons (quote limit) (cons (quote length) (cons (quote let) (cons (quote lazy) (cons (quote lambda) (cons (quote language) (cons (quote kill) (cons (quote is) (cons (quote intersection) (cons (quote inferences) (cons (quote intern) (cons (quote integer?) (cons (quote input) (cons (quote input+) (cons (quote include) (cons (quote include-all-but) (cons (quote it) (cons (quote in) (cons (quote internal) (cons (quote implementation) (cons (quote if) (cons (quote identical) (cons (quote head) (cons (quote hd) (cons (quote hdv) (cons (quote hdstr) (cons (quote hash) (cons (quote get) (cons (quote get-time) (cons (quote gensym) (cons (quote function) (cons (quote fst) (cons (quote freeze) (cons (quote fix) (cons (quote file) (cons (quote fail) (cons (quote fail-if) (cons (quote fwhen) (cons (quote findall) (cons false (cons (quote enable-type-theory) (cons (quote explode) (cons (quote external) (cons (quote exception) (cons (quote eval-kl) (cons (quote eval) (cons (quote error-to-string) (cons (quote error) (cons (quote empty?) (cons (quote element?) (cons (quote do) (cons (quote difference) (cons (quote destroy) (cons (quote defun) (cons (quote define) (cons (quote defmacro) (cons (quote defcc) (cons (quote defprolog) (cons (quote declare) (cons (quote datatype) (cons (quote cut) (cons (quote cn) (cons (quote cons?) (cons (quote cons) (cons (quote cond) (cons (quote concat) (cons (quote compile) (cons (quote cd) (cons (quote cases) (cons (quote call) (cons (quote close) (cons (quote bind) (cons (quote bound?) (cons (quote boolean?) (cons (quote boolean) (cons (quote bar!) (cons (quote assoc) (cons (quote arity) (cons (quote abort) (cons (quote append) (cons (quote and) (cons (quote adjoin) (cons (quote <-address) (cons (quote address->) (cons (quote absvector?) (cons (quote absvector) ())))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) (value (quote *property-vector*)))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare = arity cons eval-kl shen-dot-lambda-form) (clojure.core/defn shen-dot-lambda-form-entry [V1657] (clojure.core/cond (= (quote package) V1657) () (= (quote receive) V1657) () true (clojure.core/let [ArityF (arity V1657)] (if (= ArityF -1) () (if (= ArityF 0) () (cons (cons V1657 (eval-kl (shen-dot-lambda-form V1657 ArityF))) ())))) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-lambda-form [V1660 V1661] (clojure.core/cond (= 0 V1661) V1660 true (clojure.core/let [X (gensym (quote V))] (cons (quote lambda) (cons X (cons (shen-dot-lambda-form (shen-dot-add-end V1660 X) (- V1661 1)) ())))) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-add-end [V1664 V1665] (clojure.core/cond (cons? V1664) (append V1664 (cons V1665 ())) true (cons V1664 (cons V1665 ())) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? put hd tl value shen-dot-f_error) (clojure.core/defn shen-dot-set-lambda-form-entry [V1667] (clojure.core/cond (cons? V1667) (put (hd V1667) (quote shen-dot-lambda-form) (tl V1667) (value (quote *property-vector*))) true (shen-dot-f_error (quote shen-dot-set-lambda-form-entry)) :else (throw (Exception. "No matching cond clause"))))))
(shen-dot-for-each (do (clojure.core/declare shen-dot-set-lambda-form-entry) (clojure.core/fn [Entry] (shen-dot-set-lambda-form-entry Entry))) (cons (cons (quote shen-dot-datatype-error) (do (clojure.core/declare shen-dot-datatype-error) (clojure.core/fn [X] (shen-dot-datatype-error X)))) (cons (cons (quote shen-dot-tuple) (do (clojure.core/declare shen-dot-tuple) (clojure.core/fn [X] (shen-dot-tuple X)))) (cons (cons (quote shen-dot-pvar) (do (clojure.core/declare shen-dot-pvar) (clojure.core/fn [X] (shen-dot-pvar X)))) (cons (cons (quote shen-dot-dictionary) (do (clojure.core/declare shen-dot-dictionary) (clojure.core/fn [X] (shen-dot-dictionary X)))) (mapcan (do (clojure.core/declare shen-dot-lambda-form-entry) (clojure.core/fn [X] (shen-dot-lambda-form-entry X))) (external (intern "shen"))))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare set cons value) (clojure.core/defn specialise [V1669] (do (set (quote shen-dot-*special*) (cons V1669 (value (quote shen-dot-*special*)))) V1669))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare set remove value) (clojure.core/defn unspecialise [V1671] (do (set (quote shen-dot-*special*) (remove V1671 (value (quote shen-dot-*special*)))) V1671))))
(clojure.core/comment t-star.kl)
(clojure.core/comment "Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.")
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-typecheck [V3644 V3645] (clojure.core/let [Curry (shen-dot-curry V3644)] (clojure.core/let [ProcessN (shen-dot-start-new-prolog-process)] (clojure.core/let [Type (shen-dot-insert-prolog-variables (shen-dot-demodulate (shen-dot-curry-type V3645)) ProcessN)] (clojure.core/let [Continuation (clojure.core/fn [] (return Type ProcessN (quote shen-dot-void)))] (shen-dot-t* (cons Curry (cons (quote -colon-) (cons Type ()))) () ProcessN Continuation)))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-curry cons? shen-dot-special? hd cons map tl shen-dot-extraspecial? =) (clojure.core/defn shen-dot-curry [V3647] (clojure.core/cond (clojure.core/and (cons? V3647) (shen-dot-special? (hd V3647))) (cons (hd V3647) (map (do (clojure.core/declare shen-dot-curry) (clojure.core/fn [Y] (shen-dot-curry Y))) (tl V3647))) (clojure.core/and (cons? V3647) (clojure.core/and (cons? (tl V3647)) (shen-dot-extraspecial? (hd V3647)))) V3647 (clojure.core/and (cons? V3647) (clojure.core/and (= (quote type) (hd V3647)) (clojure.core/and (cons? (tl V3647)) (clojure.core/and (cons? (tl (tl V3647))) (= () (tl (tl (tl V3647)))))))) (cons (quote type) (cons (shen-dot-curry (hd (tl V3647))) (tl (tl V3647)))) (clojure.core/and (cons? V3647) (clojure.core/and (cons? (tl V3647)) (cons? (tl (tl V3647))))) (shen-dot-curry (cons (cons (hd V3647) (cons (hd (tl V3647)) ())) (tl (tl V3647)))) (clojure.core/and (cons? V3647) (clojure.core/and (cons? (tl V3647)) (= () (tl (tl V3647))))) (cons (shen-dot-curry (hd V3647)) (cons (shen-dot-curry (hd (tl V3647))) ())) true V3647 :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare element? value) (clojure.core/defn shen-dot-special? [V3649] (element? V3649 (value (quote shen-dot-*special*))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare element? value) (clojure.core/defn shen-dot-extraspecial? [V3651] (element? V3651 (value (quote shen-dot-*extraspecial*))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-t* [V3656 V3657 V3658 V3659] (clojure.core/let [Throwcontrol (shen-dot-catchpoint)] (shen-dot-cutpoint Throwcontrol (clojure.core/let [Case (clojure.core/let [Error (shen-dot-newpv V3658)] (do (shen-dot-incinfs) (fwhen (shen-dot-maxinfexceeded?) V3658 (clojure.core/fn [] (bind Error (shen-dot-errormaxinfs) V3658 V3659)))))] (if (= Case false) (clojure.core/let [Case (clojure.core/let [V3636 (shen-dot-lazyderef V3656 V3658)] (if (= (quote fail) V3636) (do (shen-dot-incinfs) (cut Throwcontrol V3658 (clojure.core/fn [] (shen-dot-prolog-failure V3658 V3659)))) false))] (if (= Case false) (clojure.core/let [Case (clojure.core/let [V3637 (shen-dot-lazyderef V3656 V3658)] (if (cons? V3637) (clojure.core/let [X (hd V3637)] (clojure.core/let [V3638 (shen-dot-lazyderef (tl V3637) V3658)] (if (cons? V3638) (clojure.core/let [V3639 (shen-dot-lazyderef (hd V3638) V3658)] (if (= (quote -colon-) V3639) (clojure.core/let [V3640 (shen-dot-lazyderef (tl V3638) V3658)] (if (cons? V3640) (clojure.core/let [A (hd V3640)] (clojure.core/let [V3641 (shen-dot-lazyderef (tl V3640) V3658)] (if (= () V3641) (do (shen-dot-incinfs) (fwhen (shen-dot-type-theory-enabled?) V3658 (clojure.core/fn [] (cut Throwcontrol V3658 (clojure.core/fn [] (shen-dot-th* X A V3657 V3658 V3659)))))) false))) false)) false)) false))) false))] (if (= Case false) (clojure.core/let [Datatypes (shen-dot-newpv V3658)] (do (shen-dot-incinfs) (shen-dot-show V3656 V3657 V3658 (clojure.core/fn [] (bind Datatypes (value (quote shen-dot-*datatypes*)) V3658 (clojure.core/fn [] (shen-dot-udefs* V3656 V3657 Datatypes V3658 V3659))))))) Case)) Case)) Case))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare value) (clojure.core/defn shen-dot-type-theory-enabled? [] (value (quote shen-dot-*shen-type-theory-enabled?*)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare = set simple-error) (clojure.core/defn enable-type-theory [V3665] (clojure.core/cond (= (quote +) V3665) (set (quote shen-dot-*shen-type-theory-enabled?*) true) (= (quote -) V3665) (set (quote shen-dot-*shen-type-theory-enabled?*) false) true (simple-error "enable-type-theory expects a + or a -\n") :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-prolog-failure [V3676 V3677] false))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare > inferences value) (clojure.core/defn shen-dot-maxinfexceeded? [] (> (inferences) (value (quote shen-dot-*maxinferences*))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare simple-error) (clojure.core/defn shen-dot-errormaxinfs [] (simple-error "maximum inferences exceeded~%"))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-udefs* [V3683 V3684 V3685 V3686 V3687] (clojure.core/let [Case (clojure.core/let [V3632 (shen-dot-lazyderef V3685 V3686)] (if (cons? V3632) (clojure.core/let [D (hd V3632)] (do (shen-dot-incinfs) (call (cons D (cons V3683 (cons V3684 ()))) V3686 V3687))) false))] (if (= Case false) (clojure.core/let [V3633 (shen-dot-lazyderef V3685 V3686)] (if (cons? V3633) (clojure.core/let [Ds (tl V3633)] (do (shen-dot-incinfs) (shen-dot-udefs* V3683 V3684 Ds V3686 V3687))) false)) Case))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-th*-aux-2 [V3693 V3694 V3695 V3696 V3697] (clojure.core/let [Case (clojure.core/let [V3591 (shen-dot-lazyderef V3693 V3696)] (if (cons? V3591) (clojure.core/let [V3592 (shen-dot-lazyderef (hd V3591) V3696)] (if (= (quote open) V3592) (clojure.core/let [V3593 (shen-dot-lazyderef (tl V3591) V3696)] (if (cons? V3593) (clojure.core/let [FileName (hd V3593)] (clojure.core/let [V3594 (shen-dot-lazyderef (tl V3593) V3696)] (if (cons? V3594) (clojure.core/let [Direction3524 (hd V3594)] (clojure.core/let [V3595 (shen-dot-lazyderef (tl V3594) V3696)] (if (= () V3595) (clojure.core/let [V3596 (shen-dot-lazyderef V3694 V3696)] (if (cons? V3596) (clojure.core/let [V3597 (shen-dot-lazyderef (hd V3596) V3696)] (if (= (quote stream) V3597) (clojure.core/let [V3598 (shen-dot-lazyderef (tl V3596) V3696)] (if (cons? V3598) (clojure.core/let [Direction (hd V3598)] (clojure.core/let [V3599 (shen-dot-lazyderef (tl V3598) V3696)] (if (= () V3599) (do (shen-dot-incinfs) (unify! Direction Direction3524 V3696 (clojure.core/fn [] (cut (quote Throwcontrol) V3696 (clojure.core/fn [] (fwhen (element? (shen-dot-lazyderef Direction V3696) (cons (quote in) (cons (quote out) ()))) V3696 (clojure.core/fn [] (shen-dot-th* FileName (quote string) V3695 V3696 V3697)))))))) (if (shen-dot-pvar? V3599) (do (shen-dot-bindv V3599 () V3696) (clojure.core/let [Result (do (shen-dot-incinfs) (unify! Direction Direction3524 V3696 (clojure.core/fn [] (cut (quote Throwcontrol) V3696 (clojure.core/fn [] (fwhen (element? (shen-dot-lazyderef Direction V3696) (cons (quote in) (cons (quote out) ()))) V3696 (clojure.core/fn [] (shen-dot-th* FileName (quote string) V3695 V3696 V3697))))))))] (do (shen-dot-unbindv V3599 V3696) Result))) false)))) (if (shen-dot-pvar? V3598) (clojure.core/let [Direction (shen-dot-newpv V3696)] (do (shen-dot-bindv V3598 (cons Direction ()) V3696) (clojure.core/let [Result (do (shen-dot-incinfs) (unify! Direction Direction3524 V3696 (clojure.core/fn [] (cut (quote Throwcontrol) V3696 (clojure.core/fn [] (fwhen (element? (shen-dot-lazyderef Direction V3696) (cons (quote in) (cons (quote out) ()))) V3696 (clojure.core/fn [] (shen-dot-th* FileName (quote string) V3695 V3696 V3697))))))))] (do (shen-dot-unbindv V3598 V3696) Result)))) false))) (if (shen-dot-pvar? V3597) (do (shen-dot-bindv V3597 (quote stream) V3696) (clojure.core/let [Result (clojure.core/let [V3600 (shen-dot-lazyderef (tl V3596) V3696)] (if (cons? V3600) (clojure.core/let [Direction (hd V3600)] (clojure.core/let [V3601 (shen-dot-lazyderef (tl V3600) V3696)] (if (= () V3601) (do (shen-dot-incinfs) (unify! Direction Direction3524 V3696 (clojure.core/fn [] (cut (quote Throwcontrol) V3696 (clojure.core/fn [] (fwhen (element? (shen-dot-lazyderef Direction V3696) (cons (quote in) (cons (quote out) ()))) V3696 (clojure.core/fn [] (shen-dot-th* FileName (quote string) V3695 V3696 V3697)))))))) (if (shen-dot-pvar? V3601) (do (shen-dot-bindv V3601 () V3696) (clojure.core/let [Result (do (shen-dot-incinfs) (unify! Direction Direction3524 V3696 (clojure.core/fn [] (cut (quote Throwcontrol) V3696 (clojure.core/fn [] (fwhen (element? (shen-dot-lazyderef Direction V3696) (cons (quote in) (cons (quote out) ()))) V3696 (clojure.core/fn [] (shen-dot-th* FileName (quote string) V3695 V3696 V3697))))))))] (do (shen-dot-unbindv V3601 V3696) Result))) false)))) (if (shen-dot-pvar? V3600) (clojure.core/let [Direction (shen-dot-newpv V3696)] (do (shen-dot-bindv V3600 (cons Direction ()) V3696) (clojure.core/let [Result (do (shen-dot-incinfs) (unify! Direction Direction3524 V3696 (clojure.core/fn [] (cut (quote Throwcontrol) V3696 (clojure.core/fn [] (fwhen (element? (shen-dot-lazyderef Direction V3696) (cons (quote in) (cons (quote out) ()))) V3696 (clojure.core/fn [] (shen-dot-th* FileName (quote string) V3695 V3696 V3697))))))))] (do (shen-dot-unbindv V3600 V3696) Result)))) false)))] (do (shen-dot-unbindv V3597 V3696) Result))) false))) (if (shen-dot-pvar? V3596) (clojure.core/let [Direction (shen-dot-newpv V3696)] (do (shen-dot-bindv V3596 (cons (quote stream) (cons Direction ())) V3696) (clojure.core/let [Result (do (shen-dot-incinfs) (unify! Direction Direction3524 V3696 (clojure.core/fn [] (cut (quote Throwcontrol) V3696 (clojure.core/fn [] (fwhen (element? (shen-dot-lazyderef Direction V3696) (cons (quote in) (cons (quote out) ()))) V3696 (clojure.core/fn [] (shen-dot-th* FileName (quote string) V3695 V3696 V3697))))))))] (do (shen-dot-unbindv V3596 V3696) Result)))) false))) false))) false))) false)) false)) false))] (if (= Case false) (clojure.core/let [Case (clojure.core/let [V3602 (shen-dot-lazyderef V3693 V3696)] (if (cons? V3602) (clojure.core/let [V3603 (shen-dot-lazyderef (hd V3602) V3696)] (if (= (quote type) V3603) (clojure.core/let [V3604 (shen-dot-lazyderef (tl V3602) V3696)] (if (cons? V3604) (clojure.core/let [X (hd V3604)] (clojure.core/let [V3605 (shen-dot-lazyderef (tl V3604) V3696)] (if (cons? V3605) (clojure.core/let [A (hd V3605)] (clojure.core/let [V3606 (shen-dot-lazyderef (tl V3605) V3696)] (if (= () V3606) (do (shen-dot-incinfs) (cut (quote Throwcontrol) V3696 (clojure.core/fn [] (unify A V3694 V3696 (clojure.core/fn [] (shen-dot-th* X A V3695 V3696 V3697)))))) false))) false))) false)) false)) false))] (if (= Case false) (clojure.core/let [Case (clojure.core/let [V3607 (shen-dot-lazyderef V3693 V3696)] (if (cons? V3607) (clojure.core/let [V3608 (shen-dot-lazyderef (hd V3607) V3696)] (if (= (quote input+) V3608) (clojure.core/let [V3609 (shen-dot-lazyderef (tl V3607) V3696)] (if (cons? V3609) (clojure.core/let [A (hd V3609)] (clojure.core/let [V3610 (shen-dot-lazyderef (tl V3609) V3696)] (if (cons? V3610) (clojure.core/let [Stream (hd V3610)] (clojure.core/let [V3611 (shen-dot-lazyderef (tl V3610) V3696)] (if (= () V3611) (clojure.core/let [C (shen-dot-newpv V3696)] (do (shen-dot-incinfs) (bind C (shen-dot-demodulate (shen-dot-lazyderef A V3696)) V3696 (clojure.core/fn [] (unify V3694 C V3696 (clojure.core/fn [] (shen-dot-th* Stream (cons (quote stream) (cons (quote in) ())) V3695 V3696 V3697))))))) false))) false))) false)) false)) false))] (if (= Case false) (clojure.core/let [Case (clojure.core/let [V3612 (shen-dot-lazyderef V3693 V3696)] (if (cons? V3612) (clojure.core/let [V3613 (shen-dot-lazyderef (hd V3612) V3696)] (if (= (quote set) V3613) (clojure.core/let [V3614 (shen-dot-lazyderef (tl V3612) V3696)] (if (cons? V3614) (clojure.core/let [Var (hd V3614)] (clojure.core/let [V3615 (shen-dot-lazyderef (tl V3614) V3696)] (if (cons? V3615) (clojure.core/let [Val (hd V3615)] (clojure.core/let [V3616 (shen-dot-lazyderef (tl V3615) V3696)] (if (= () V3616) (do (shen-dot-incinfs) (cut (quote Throwcontrol) V3696 (clojure.core/fn [] (shen-dot-th* Var (quote symbol) V3695 V3696 (clojure.core/fn [] (cut (quote Throwcontrol) V3696 (clojure.core/fn [] (shen-dot-th* (cons (quote value) (cons Var ())) V3694 V3695 V3696 (clojure.core/fn [] (shen-dot-th* Val V3694 V3695 V3696 V3697)))))))))) false))) false))) false)) false)) false))] (if (= Case false) (clojure.core/let [Case (clojure.core/let [NewHyp (shen-dot-newpv V3696)] (do (shen-dot-incinfs) (shen-dot-t*-hyps V3695 NewHyp V3696 (clojure.core/fn [] (shen-dot-th* V3693 V3694 NewHyp V3696 V3697)))))] (if (= Case false) (clojure.core/let [Case (clojure.core/let [V3617 (shen-dot-lazyderef V3693 V3696)] (if (cons? V3617) (clojure.core/let [V3618 (shen-dot-lazyderef (hd V3617) V3696)] (if (= (quote define) V3618) (clojure.core/let [V3619 (shen-dot-lazyderef (tl V3617) V3696)] (if (cons? V3619) (clojure.core/let [F (hd V3619)] (clojure.core/let [X (tl V3619)] (do (shen-dot-incinfs) (cut (quote Throwcontrol) V3696 (clojure.core/fn [] (shen-dot-t*-def (cons (quote define) (cons F X)) V3694 V3695 V3696 V3697)))))) false)) false)) false))] (if (= Case false) (clojure.core/let [Case (clojure.core/let [V3620 (shen-dot-lazyderef V3693 V3696)] (if (cons? V3620) (clojure.core/let [V3621 (shen-dot-lazyderef (hd V3620) V3696)] (if (= (quote defmacro) V3621) (clojure.core/let [V3622 (shen-dot-lazyderef V3694 V3696)] (if (= (quote unit) V3622) (do (shen-dot-incinfs) (cut (quote Throwcontrol) V3696 V3697)) (if (shen-dot-pvar? V3622) (do (shen-dot-bindv V3622 (quote unit) V3696) (clojure.core/let [Result (do (shen-dot-incinfs) (cut (quote Throwcontrol) V3696 V3697))] (do (shen-dot-unbindv V3622 V3696) Result))) false))) false)) false))] (if (= Case false) (clojure.core/let [Case (clojure.core/let [V3623 (shen-dot-lazyderef V3693 V3696)] (if (cons? V3623) (clojure.core/let [V3624 (shen-dot-lazyderef (hd V3623) V3696)] (if (= (quote shen-dot-process-datatype) V3624) (clojure.core/let [V3625 (shen-dot-lazyderef V3694 V3696)] (if (= (quote symbol) V3625) (do (shen-dot-incinfs) (thaw V3697)) (if (shen-dot-pvar? V3625) (do (shen-dot-bindv V3625 (quote symbol) V3696) (clojure.core/let [Result (do (shen-dot-incinfs) (thaw V3697))] (do (shen-dot-unbindv V3625 V3696) Result))) false))) false)) false))] (if (= Case false) (clojure.core/let [Case (clojure.core/let [V3626 (shen-dot-lazyderef V3693 V3696)] (if (cons? V3626) (clojure.core/let [V3627 (shen-dot-lazyderef (hd V3626) V3696)] (if (= (quote shen-dot-synonyms-help) V3627) (clojure.core/let [V3628 (shen-dot-lazyderef V3694 V3696)] (if (= (quote symbol) V3628) (do (shen-dot-incinfs) (thaw V3697)) (if (shen-dot-pvar? V3628) (do (shen-dot-bindv V3628 (quote symbol) V3696) (clojure.core/let [Result (do (shen-dot-incinfs) (thaw V3697))] (do (shen-dot-unbindv V3628 V3696) Result))) false))) false)) false))] (if (= Case false) (clojure.core/let [Datatypes (shen-dot-newpv V3696)] (do (shen-dot-incinfs) (bind Datatypes (value (quote shen-dot-*datatypes*)) V3696 (clojure.core/fn [] (shen-dot-udefs* (cons V3693 (cons (quote -colon-) (cons V3694 ()))) V3695 Datatypes V3696 V3697))))) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-th*-aux [V3693 V3694 V3695 V3696 V3697] (clojure.core/let [Case (clojure.core/let [V3573 (shen-dot-lazyderef V3693 V3696)] (if (cons? V3573) (clojure.core/let [V3574 (shen-dot-lazyderef (hd V3573) V3696)] (if (= (quote lambda) V3574) (clojure.core/let [V3575 (shen-dot-lazyderef (tl V3573) V3696)] (if (cons? V3575) (clojure.core/let [X (hd V3575)] (clojure.core/let [V3576 (shen-dot-lazyderef (tl V3575) V3696)] (if (cons? V3576) (clojure.core/let [Y (hd V3576)] (clojure.core/let [V3577 (shen-dot-lazyderef (tl V3576) V3696)] (if (= () V3577) (clojure.core/let [V3578 (shen-dot-lazyderef V3694 V3696)] (if (cons? V3578) (clojure.core/let [A (hd V3578)] (clojure.core/let [V3579 (shen-dot-lazyderef (tl V3578) V3696)] (if (cons? V3579) (clojure.core/let [V3580 (shen-dot-lazyderef (hd V3579) V3696)] (if (= (quote -->) V3580) (clojure.core/let [V3581 (shen-dot-lazyderef (tl V3579) V3696)] (if (cons? V3581) (clojure.core/let [B (hd V3581)] (clojure.core/let [V3582 (shen-dot-lazyderef (tl V3581) V3696)] (if (= () V3582) (clojure.core/let [Z (shen-dot-newpv V3696)] (clojure.core/let [X&& (shen-dot-newpv V3696)] (do (shen-dot-incinfs) (cut (quote Throwcontrol) V3696 (clojure.core/fn [] (bind X&& (shen-dot-placeholder) V3696 (clojure.core/fn [] (bind Z (shen-dot-ebr (shen-dot-lazyderef X&& V3696) (shen-dot-lazyderef X V3696) (shen-dot-lazyderef Y V3696)) V3696 (clojure.core/fn [] (shen-dot-th* Z B (cons (cons X&& (cons (quote -colon-) (cons A ()))) V3695) V3696 V3697)))))))))) (if (shen-dot-pvar? V3582) (do (shen-dot-bindv V3582 () V3696) (clojure.core/let [Result (clojure.core/let [Z (shen-dot-newpv V3696)] (clojure.core/let [X&& (shen-dot-newpv V3696)] (do (shen-dot-incinfs) (cut (quote Throwcontrol) V3696 (clojure.core/fn [] (bind X&& (shen-dot-placeholder) V3696 (clojure.core/fn [] (bind Z (shen-dot-ebr (shen-dot-lazyderef X&& V3696) (shen-dot-lazyderef X V3696) (shen-dot-lazyderef Y V3696)) V3696 (clojure.core/fn [] (shen-dot-th* Z B (cons (cons X&& (cons (quote -colon-) (cons A ()))) V3695) V3696 V3697))))))))))] (do (shen-dot-unbindv V3582 V3696) Result))) false)))) (if (shen-dot-pvar? V3581) (clojure.core/let [B (shen-dot-newpv V3696)] (do (shen-dot-bindv V3581 (cons B ()) V3696) (clojure.core/let [Result (clojure.core/let [Z (shen-dot-newpv V3696)] (clojure.core/let [X&& (shen-dot-newpv V3696)] (do (shen-dot-incinfs) (cut (quote Throwcontrol) V3696 (clojure.core/fn [] (bind X&& (shen-dot-placeholder) V3696 (clojure.core/fn [] (bind Z (shen-dot-ebr (shen-dot-lazyderef X&& V3696) (shen-dot-lazyderef X V3696) (shen-dot-lazyderef Y V3696)) V3696 (clojure.core/fn [] (shen-dot-th* Z B (cons (cons X&& (cons (quote -colon-) (cons A ()))) V3695) V3696 V3697))))))))))] (do (shen-dot-unbindv V3581 V3696) Result)))) false))) (if (shen-dot-pvar? V3580) (do (shen-dot-bindv V3580 (quote -->) V3696) (clojure.core/let [Result (clojure.core/let [V3583 (shen-dot-lazyderef (tl V3579) V3696)] (if (cons? V3583) (clojure.core/let [B (hd V3583)] (clojure.core/let [V3584 (shen-dot-lazyderef (tl V3583) V3696)] (if (= () V3584) (clojure.core/let [Z (shen-dot-newpv V3696)] (clojure.core/let [X&& (shen-dot-newpv V3696)] (do (shen-dot-incinfs) (cut (quote Throwcontrol) V3696 (clojure.core/fn [] (bind X&& (shen-dot-placeholder) V3696 (clojure.core/fn [] (bind Z (shen-dot-ebr (shen-dot-lazyderef X&& V3696) (shen-dot-lazyderef X V3696) (shen-dot-lazyderef Y V3696)) V3696 (clojure.core/fn [] (shen-dot-th* Z B (cons (cons X&& (cons (quote -colon-) (cons A ()))) V3695) V3696 V3697)))))))))) (if (shen-dot-pvar? V3584) (do (shen-dot-bindv V3584 () V3696) (clojure.core/let [Result (clojure.core/let [Z (shen-dot-newpv V3696)] (clojure.core/let [X&& (shen-dot-newpv V3696)] (do (shen-dot-incinfs) (cut (quote Throwcontrol) V3696 (clojure.core/fn [] (bind X&& (shen-dot-placeholder) V3696 (clojure.core/fn [] (bind Z (shen-dot-ebr (shen-dot-lazyderef X&& V3696) (shen-dot-lazyderef X V3696) (shen-dot-lazyderef Y V3696)) V3696 (clojure.core/fn [] (shen-dot-th* Z B (cons (cons X&& (cons (quote -colon-) (cons A ()))) V3695) V3696 V3697))))))))))] (do (shen-dot-unbindv V3584 V3696) Result))) false)))) (if (shen-dot-pvar? V3583) (clojure.core/let [B (shen-dot-newpv V3696)] (do (shen-dot-bindv V3583 (cons B ()) V3696) (clojure.core/let [Result (clojure.core/let [Z (shen-dot-newpv V3696)] (clojure.core/let [X&& (shen-dot-newpv V3696)] (do (shen-dot-incinfs) (cut (quote Throwcontrol) V3696 (clojure.core/fn [] (bind X&& (shen-dot-placeholder) V3696 (clojure.core/fn [] (bind Z (shen-dot-ebr (shen-dot-lazyderef X&& V3696) (shen-dot-lazyderef X V3696) (shen-dot-lazyderef Y V3696)) V3696 (clojure.core/fn [] (shen-dot-th* Z B (cons (cons X&& (cons (quote -colon-) (cons A ()))) V3695) V3696 V3697))))))))))] (do (shen-dot-unbindv V3583 V3696) Result)))) false)))] (do (shen-dot-unbindv V3580 V3696) Result))) false))) (if (shen-dot-pvar? V3579) (clojure.core/let [B (shen-dot-newpv V3696)] (do (shen-dot-bindv V3579 (cons (quote -->) (cons B ())) V3696) (clojure.core/let [Result (clojure.core/let [Z (shen-dot-newpv V3696)] (clojure.core/let [X&& (shen-dot-newpv V3696)] (do (shen-dot-incinfs) (cut (quote Throwcontrol) V3696 (clojure.core/fn [] (bind X&& (shen-dot-placeholder) V3696 (clojure.core/fn [] (bind Z (shen-dot-ebr (shen-dot-lazyderef X&& V3696) (shen-dot-lazyderef X V3696) (shen-dot-lazyderef Y V3696)) V3696 (clojure.core/fn [] (shen-dot-th* Z B (cons (cons X&& (cons (quote -colon-) (cons A ()))) V3695) V3696 V3697))))))))))] (do (shen-dot-unbindv V3579 V3696) Result)))) false)))) (if (shen-dot-pvar? V3578) (clojure.core/let [A (shen-dot-newpv V3696)] (clojure.core/let [B (shen-dot-newpv V3696)] (do (shen-dot-bindv V3578 (cons A (cons (quote -->) (cons B ()))) V3696) (clojure.core/let [Result (clojure.core/let [Z (shen-dot-newpv V3696)] (clojure.core/let [X&& (shen-dot-newpv V3696)] (do (shen-dot-incinfs) (cut (quote Throwcontrol) V3696 (clojure.core/fn [] (bind X&& (shen-dot-placeholder) V3696 (clojure.core/fn [] (bind Z (shen-dot-ebr (shen-dot-lazyderef X&& V3696) (shen-dot-lazyderef X V3696) (shen-dot-lazyderef Y V3696)) V3696 (clojure.core/fn [] (shen-dot-th* Z B (cons (cons X&& (cons (quote -colon-) (cons A ()))) V3695) V3696 V3697))))))))))] (do (shen-dot-unbindv V3578 V3696) Result))))) false))) false))) false))) false)) false)) false))] (if (= Case false) (clojure.core/let [Case (clojure.core/let [V3585 (shen-dot-lazyderef V3693 V3696)] (if (cons? V3585) (clojure.core/let [V3586 (shen-dot-lazyderef (hd V3585) V3696)] (if (= (quote let) V3586) (clojure.core/let [V3587 (shen-dot-lazyderef (tl V3585) V3696)] (if (cons? V3587) (clojure.core/let [X (hd V3587)] (clojure.core/let [V3588 (shen-dot-lazyderef (tl V3587) V3696)] (if (cons? V3588) (clojure.core/let [Y (hd V3588)] (clojure.core/let [V3589 (shen-dot-lazyderef (tl V3588) V3696)] (if (cons? V3589) (clojure.core/let [Z (hd V3589)] (clojure.core/let [V3590 (shen-dot-lazyderef (tl V3589) V3696)] (if (= () V3590) (clojure.core/let [W (shen-dot-newpv V3696)] (clojure.core/let [X&& (shen-dot-newpv V3696)] (clojure.core/let [B (shen-dot-newpv V3696)] (do (shen-dot-incinfs) (shen-dot-th* Y B V3695 V3696 (clojure.core/fn [] (bind X&& (shen-dot-placeholder) V3696 (clojure.core/fn [] (bind W (shen-dot-ebr (shen-dot-lazyderef X&& V3696) (shen-dot-lazyderef X V3696) (shen-dot-lazyderef Z V3696)) V3696 (clojure.core/fn [] (shen-dot-th* W V3694 (cons (cons X&& (cons (quote -colon-) (cons B ()))) V3695) V3696 V3697))))))))))) false))) false))) false))) false)) false)) false))] (if (= Case false) (shen-dot-th*-aux-2 V3693 V3694 V3695 V3696 V3697) Case)) Case))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-th* [V3693 V3694 V3695 V3696 V3697] (clojure.core/let [Throwcontrol (shen-dot-catchpoint)] (shen-dot-cutpoint Throwcontrol (clojure.core/let [Case (do (shen-dot-incinfs) (shen-dot-show (cons V3693 (cons (quote -colon-) (cons V3694 ()))) V3695 V3696 (clojure.core/fn [] (fwhen false V3696 V3697))))] (if (= Case false) (clojure.core/let [Case (clojure.core/let [F (shen-dot-newpv V3696)] (do (shen-dot-incinfs) (fwhen (shen-dot-typedf? (shen-dot-lazyderef V3693 V3696)) V3696 (clojure.core/fn [] (bind F (shen-dot-sigf (shen-dot-lazyderef V3693 V3696)) V3696 (clojure.core/fn [] (call (cons F (cons V3694 ())) V3696 V3697)))))))] (if (= Case false) (clojure.core/let [Case (do (shen-dot-incinfs) (shen-dot-base V3693 V3694 V3696 V3697))] (if (= Case false) (clojure.core/let [Case (do (shen-dot-incinfs) (shen-dot-by_hypothesis V3693 V3694 V3695 V3696 V3697))] (if (= Case false) (clojure.core/let [Case (clojure.core/let [V3528 (shen-dot-lazyderef V3693 V3696)] (if (cons? V3528) (clojure.core/let [F (hd V3528)] (clojure.core/let [V3529 (shen-dot-lazyderef (tl V3528) V3696)] (if (= () V3529) (do (shen-dot-incinfs) (shen-dot-th* F (cons (quote -->) (cons V3694 ())) V3695 V3696 V3697)) false))) false))] (if (= Case false) (clojure.core/let [Case (clojure.core/let [V3530 (shen-dot-lazyderef V3693 V3696)] (if (cons? V3530) (clojure.core/let [F (hd V3530)] (clojure.core/let [V3531 (shen-dot-lazyderef (tl V3530) V3696)] (if (cons? V3531) (clojure.core/let [X (hd V3531)] (clojure.core/let [V3532 (shen-dot-lazyderef (tl V3531) V3696)] (if (= () V3532) (clojure.core/let [B (shen-dot-newpv V3696)] (do (shen-dot-incinfs) (shen-dot-th* F (cons B (cons (quote -->) (cons V3694 ()))) V3695 V3696 (clojure.core/fn [] (shen-dot-th* X B V3695 V3696 V3697))))) false))) false))) false))] (if (= Case false) (clojure.core/let [Case (clojure.core/let [V3533 (shen-dot-lazyderef V3693 V3696)] (if (cons? V3533) (clojure.core/let [V3534 (shen-dot-lazyderef (hd V3533) V3696)] (if (= (quote cons) V3534) (clojure.core/let [V3535 (shen-dot-lazyderef (tl V3533) V3696)] (if (cons? V3535) (clojure.core/let [X (hd V3535)] (clojure.core/let [V3536 (shen-dot-lazyderef (tl V3535) V3696)] (if (cons? V3536) (clojure.core/let [Y (hd V3536)] (clojure.core/let [V3537 (shen-dot-lazyderef (tl V3536) V3696)] (if (= () V3537) (clojure.core/let [V3538 (shen-dot-lazyderef V3694 V3696)] (if (cons? V3538) (clojure.core/let [V3539 (shen-dot-lazyderef (hd V3538) V3696)] (if (= (quote list) V3539) (clojure.core/let [V3540 (shen-dot-lazyderef (tl V3538) V3696)] (if (cons? V3540) (clojure.core/let [A (hd V3540)] (clojure.core/let [V3541 (shen-dot-lazyderef (tl V3540) V3696)] (if (= () V3541) (do (shen-dot-incinfs) (shen-dot-th* X A V3695 V3696 (clojure.core/fn [] (shen-dot-th* Y (cons (quote list) (cons A ())) V3695 V3696 V3697)))) (if (shen-dot-pvar? V3541) (do (shen-dot-bindv V3541 () V3696) (clojure.core/let [Result (do (shen-dot-incinfs) (shen-dot-th* X A V3695 V3696 (clojure.core/fn [] (shen-dot-th* Y (cons (quote list) (cons A ())) V3695 V3696 V3697))))] (do (shen-dot-unbindv V3541 V3696) Result))) false)))) (if (shen-dot-pvar? V3540) (clojure.core/let [A (shen-dot-newpv V3696)] (do (shen-dot-bindv V3540 (cons A ()) V3696) (clojure.core/let [Result (do (shen-dot-incinfs) (shen-dot-th* X A V3695 V3696 (clojure.core/fn [] (shen-dot-th* Y (cons (quote list) (cons A ())) V3695 V3696 V3697))))] (do (shen-dot-unbindv V3540 V3696) Result)))) false))) (if (shen-dot-pvar? V3539) (do (shen-dot-bindv V3539 (quote list) V3696) (clojure.core/let [Result (clojure.core/let [V3542 (shen-dot-lazyderef (tl V3538) V3696)] (if (cons? V3542) (clojure.core/let [A (hd V3542)] (clojure.core/let [V3543 (shen-dot-lazyderef (tl V3542) V3696)] (if (= () V3543) (do (shen-dot-incinfs) (shen-dot-th* X A V3695 V3696 (clojure.core/fn [] (shen-dot-th* Y (cons (quote list) (cons A ())) V3695 V3696 V3697)))) (if (shen-dot-pvar? V3543) (do (shen-dot-bindv V3543 () V3696) (clojure.core/let [Result (do (shen-dot-incinfs) (shen-dot-th* X A V3695 V3696 (clojure.core/fn [] (shen-dot-th* Y (cons (quote list) (cons A ())) V3695 V3696 V3697))))] (do (shen-dot-unbindv V3543 V3696) Result))) false)))) (if (shen-dot-pvar? V3542) (clojure.core/let [A (shen-dot-newpv V3696)] (do (shen-dot-bindv V3542 (cons A ()) V3696) (clojure.core/let [Result (do (shen-dot-incinfs) (shen-dot-th* X A V3695 V3696 (clojure.core/fn [] (shen-dot-th* Y (cons (quote list) (cons A ())) V3695 V3696 V3697))))] (do (shen-dot-unbindv V3542 V3696) Result)))) false)))] (do (shen-dot-unbindv V3539 V3696) Result))) false))) (if (shen-dot-pvar? V3538) (clojure.core/let [A (shen-dot-newpv V3696)] (do (shen-dot-bindv V3538 (cons (quote list) (cons A ())) V3696) (clojure.core/let [Result (do (shen-dot-incinfs) (shen-dot-th* X A V3695 V3696 (clojure.core/fn [] (shen-dot-th* Y (cons (quote list) (cons A ())) V3695 V3696 V3697))))] (do (shen-dot-unbindv V3538 V3696) Result)))) false))) false))) false))) false)) false)) false))] (if (= Case false) (clojure.core/let [Case (clojure.core/let [V3544 (shen-dot-lazyderef V3693 V3696)] (if (cons? V3544) (clojure.core/let [V3545 (shen-dot-lazyderef (hd V3544) V3696)] (if (= (quote -at-p) V3545) (clojure.core/let [V3546 (shen-dot-lazyderef (tl V3544) V3696)] (if (cons? V3546) (clojure.core/let [X (hd V3546)] (clojure.core/let [V3547 (shen-dot-lazyderef (tl V3546) V3696)] (if (cons? V3547) (clojure.core/let [Y (hd V3547)] (clojure.core/let [V3548 (shen-dot-lazyderef (tl V3547) V3696)] (if (= () V3548) (clojure.core/let [V3549 (shen-dot-lazyderef V3694 V3696)] (if (cons? V3549) (clojure.core/let [A (hd V3549)] (clojure.core/let [V3550 (shen-dot-lazyderef (tl V3549) V3696)] (if (cons? V3550) (clojure.core/let [V3551 (shen-dot-lazyderef (hd V3550) V3696)] (if (= (quote *) V3551) (clojure.core/let [V3552 (shen-dot-lazyderef (tl V3550) V3696)] (if (cons? V3552) (clojure.core/let [B (hd V3552)] (clojure.core/let [V3553 (shen-dot-lazyderef (tl V3552) V3696)] (if (= () V3553) (do (shen-dot-incinfs) (shen-dot-th* X A V3695 V3696 (clojure.core/fn [] (shen-dot-th* Y B V3695 V3696 V3697)))) (if (shen-dot-pvar? V3553) (do (shen-dot-bindv V3553 () V3696) (clojure.core/let [Result (do (shen-dot-incinfs) (shen-dot-th* X A V3695 V3696 (clojure.core/fn [] (shen-dot-th* Y B V3695 V3696 V3697))))] (do (shen-dot-unbindv V3553 V3696) Result))) false)))) (if (shen-dot-pvar? V3552) (clojure.core/let [B (shen-dot-newpv V3696)] (do (shen-dot-bindv V3552 (cons B ()) V3696) (clojure.core/let [Result (do (shen-dot-incinfs) (shen-dot-th* X A V3695 V3696 (clojure.core/fn [] (shen-dot-th* Y B V3695 V3696 V3697))))] (do (shen-dot-unbindv V3552 V3696) Result)))) false))) (if (shen-dot-pvar? V3551) (do (shen-dot-bindv V3551 (quote *) V3696) (clojure.core/let [Result (clojure.core/let [V3554 (shen-dot-lazyderef (tl V3550) V3696)] (if (cons? V3554) (clojure.core/let [B (hd V3554)] (clojure.core/let [V3555 (shen-dot-lazyderef (tl V3554) V3696)] (if (= () V3555) (do (shen-dot-incinfs) (shen-dot-th* X A V3695 V3696 (clojure.core/fn [] (shen-dot-th* Y B V3695 V3696 V3697)))) (if (shen-dot-pvar? V3555) (do (shen-dot-bindv V3555 () V3696) (clojure.core/let [Result (do (shen-dot-incinfs) (shen-dot-th* X A V3695 V3696 (clojure.core/fn [] (shen-dot-th* Y B V3695 V3696 V3697))))] (do (shen-dot-unbindv V3555 V3696) Result))) false)))) (if (shen-dot-pvar? V3554) (clojure.core/let [B (shen-dot-newpv V3696)] (do (shen-dot-bindv V3554 (cons B ()) V3696) (clojure.core/let [Result (do (shen-dot-incinfs) (shen-dot-th* X A V3695 V3696 (clojure.core/fn [] (shen-dot-th* Y B V3695 V3696 V3697))))] (do (shen-dot-unbindv V3554 V3696) Result)))) false)))] (do (shen-dot-unbindv V3551 V3696) Result))) false))) (if (shen-dot-pvar? V3550) (clojure.core/let [B (shen-dot-newpv V3696)] (do (shen-dot-bindv V3550 (cons (quote *) (cons B ())) V3696) (clojure.core/let [Result (do (shen-dot-incinfs) (shen-dot-th* X A V3695 V3696 (clojure.core/fn [] (shen-dot-th* Y B V3695 V3696 V3697))))] (do (shen-dot-unbindv V3550 V3696) Result)))) false)))) (if (shen-dot-pvar? V3549) (clojure.core/let [A (shen-dot-newpv V3696)] (clojure.core/let [B (shen-dot-newpv V3696)] (do (shen-dot-bindv V3549 (cons A (cons (quote *) (cons B ()))) V3696) (clojure.core/let [Result (do (shen-dot-incinfs) (shen-dot-th* X A V3695 V3696 (clojure.core/fn [] (shen-dot-th* Y B V3695 V3696 V3697))))] (do (shen-dot-unbindv V3549 V3696) Result))))) false))) false))) false))) false)) false)) false))] (if (= Case false) (clojure.core/let [Case (clojure.core/let [V3556 (shen-dot-lazyderef V3693 V3696)] (if (cons? V3556) (clojure.core/let [V3557 (shen-dot-lazyderef (hd V3556) V3696)] (if (= (quote -at-v) V3557) (clojure.core/let [V3558 (shen-dot-lazyderef (tl V3556) V3696)] (if (cons? V3558) (clojure.core/let [X (hd V3558)] (clojure.core/let [V3559 (shen-dot-lazyderef (tl V3558) V3696)] (if (cons? V3559) (clojure.core/let [Y (hd V3559)] (clojure.core/let [V3560 (shen-dot-lazyderef (tl V3559) V3696)] (if (= () V3560) (clojure.core/let [V3561 (shen-dot-lazyderef V3694 V3696)] (if (cons? V3561) (clojure.core/let [V3562 (shen-dot-lazyderef (hd V3561) V3696)] (if (= (quote vector) V3562) (clojure.core/let [V3563 (shen-dot-lazyderef (tl V3561) V3696)] (if (cons? V3563) (clojure.core/let [A (hd V3563)] (clojure.core/let [V3564 (shen-dot-lazyderef (tl V3563) V3696)] (if (= () V3564) (do (shen-dot-incinfs) (shen-dot-th* X A V3695 V3696 (clojure.core/fn [] (shen-dot-th* Y (cons (quote vector) (cons A ())) V3695 V3696 V3697)))) (if (shen-dot-pvar? V3564) (do (shen-dot-bindv V3564 () V3696) (clojure.core/let [Result (do (shen-dot-incinfs) (shen-dot-th* X A V3695 V3696 (clojure.core/fn [] (shen-dot-th* Y (cons (quote vector) (cons A ())) V3695 V3696 V3697))))] (do (shen-dot-unbindv V3564 V3696) Result))) false)))) (if (shen-dot-pvar? V3563) (clojure.core/let [A (shen-dot-newpv V3696)] (do (shen-dot-bindv V3563 (cons A ()) V3696) (clojure.core/let [Result (do (shen-dot-incinfs) (shen-dot-th* X A V3695 V3696 (clojure.core/fn [] (shen-dot-th* Y (cons (quote vector) (cons A ())) V3695 V3696 V3697))))] (do (shen-dot-unbindv V3563 V3696) Result)))) false))) (if (shen-dot-pvar? V3562) (do (shen-dot-bindv V3562 (quote vector) V3696) (clojure.core/let [Result (clojure.core/let [V3565 (shen-dot-lazyderef (tl V3561) V3696)] (if (cons? V3565) (clojure.core/let [A (hd V3565)] (clojure.core/let [V3566 (shen-dot-lazyderef (tl V3565) V3696)] (if (= () V3566) (do (shen-dot-incinfs) (shen-dot-th* X A V3695 V3696 (clojure.core/fn [] (shen-dot-th* Y (cons (quote vector) (cons A ())) V3695 V3696 V3697)))) (if (shen-dot-pvar? V3566) (do (shen-dot-bindv V3566 () V3696) (clojure.core/let [Result (do (shen-dot-incinfs) (shen-dot-th* X A V3695 V3696 (clojure.core/fn [] (shen-dot-th* Y (cons (quote vector) (cons A ())) V3695 V3696 V3697))))] (do (shen-dot-unbindv V3566 V3696) Result))) false)))) (if (shen-dot-pvar? V3565) (clojure.core/let [A (shen-dot-newpv V3696)] (do (shen-dot-bindv V3565 (cons A ()) V3696) (clojure.core/let [Result (do (shen-dot-incinfs) (shen-dot-th* X A V3695 V3696 (clojure.core/fn [] (shen-dot-th* Y (cons (quote vector) (cons A ())) V3695 V3696 V3697))))] (do (shen-dot-unbindv V3565 V3696) Result)))) false)))] (do (shen-dot-unbindv V3562 V3696) Result))) false))) (if (shen-dot-pvar? V3561) (clojure.core/let [A (shen-dot-newpv V3696)] (do (shen-dot-bindv V3561 (cons (quote vector) (cons A ())) V3696) (clojure.core/let [Result (do (shen-dot-incinfs) (shen-dot-th* X A V3695 V3696 (clojure.core/fn [] (shen-dot-th* Y (cons (quote vector) (cons A ())) V3695 V3696 V3697))))] (do (shen-dot-unbindv V3561 V3696) Result)))) false))) false))) false))) false)) false)) false))] (if (= Case false) (clojure.core/let [Case (clojure.core/let [V3567 (shen-dot-lazyderef V3693 V3696)] (if (cons? V3567) (clojure.core/let [V3568 (shen-dot-lazyderef (hd V3567) V3696)] (if (= (quote -at-s) V3568) (clojure.core/let [V3569 (shen-dot-lazyderef (tl V3567) V3696)] (if (cons? V3569) (clojure.core/let [X (hd V3569)] (clojure.core/let [V3570 (shen-dot-lazyderef (tl V3569) V3696)] (if (cons? V3570) (clojure.core/let [Y (hd V3570)] (clojure.core/let [V3571 (shen-dot-lazyderef (tl V3570) V3696)] (if (= () V3571) (clojure.core/let [V3572 (shen-dot-lazyderef V3694 V3696)] (if (= (quote string) V3572) (do (shen-dot-incinfs) (shen-dot-th* X (quote string) V3695 V3696 (clojure.core/fn [] (shen-dot-th* Y (quote string) V3695 V3696 V3697)))) (if (shen-dot-pvar? V3572) (do (shen-dot-bindv V3572 (quote string) V3696) (clojure.core/let [Result (do (shen-dot-incinfs) (shen-dot-th* X (quote string) V3695 V3696 (clojure.core/fn [] (shen-dot-th* Y (quote string) V3695 V3696 V3697))))] (do (shen-dot-unbindv V3572 V3696) Result))) false))) false))) false))) false)) false)) false))] (if (= Case false) (shen-dot-th*-aux V3693 V3694 V3695 V3696 V3697) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-t*-hyps-aux [V3702 V3703 V3704 V3705] (clojure.core/let [Case (clojure.core/let [V3487 (shen-dot-lazyderef V3702 V3704)] (if (cons? V3487) (clojure.core/let [V3488 (shen-dot-lazyderef (hd V3487) V3704)] (if (cons? V3488) (clojure.core/let [V3489 (shen-dot-lazyderef (hd V3488) V3704)] (if (cons? V3489) (clojure.core/let [V3490 (shen-dot-lazyderef (hd V3489) V3704)] (if (= (quote -at-v) V3490) (clojure.core/let [V3491 (shen-dot-lazyderef (tl V3489) V3704)] (if (cons? V3491) (clojure.core/let [X (hd V3491)] (clojure.core/let [V3492 (shen-dot-lazyderef (tl V3491) V3704)] (if (cons? V3492) (clojure.core/let [Y (hd V3492)] (clojure.core/let [V3493 (shen-dot-lazyderef (tl V3492) V3704)] (if (= () V3493) (clojure.core/let [V3494 (shen-dot-lazyderef (tl V3488) V3704)] (if (cons? V3494) (clojure.core/let [V3495 (shen-dot-lazyderef (hd V3494) V3704)] (if (= (quote -colon-) V3495) (clojure.core/let [V3496 (shen-dot-lazyderef (tl V3494) V3704)] (if (cons? V3496) (clojure.core/let [V3497 (shen-dot-lazyderef (hd V3496) V3704)] (if (cons? V3497) (clojure.core/let [V3498 (shen-dot-lazyderef (hd V3497) V3704)] (if (= (quote vector) V3498) (clojure.core/let [V3499 (shen-dot-lazyderef (tl V3497) V3704)] (if (cons? V3499) (clojure.core/let [A (hd V3499)] (clojure.core/let [V3500 (shen-dot-lazyderef (tl V3499) V3704)] (if (= () V3500) (clojure.core/let [V3501 (shen-dot-lazyderef (tl V3496) V3704)] (if (= () V3501) (clojure.core/let [Hyp (tl V3487)] (do (shen-dot-incinfs) (bind V3703 (cons (cons (shen-dot-lazyderef X V3704) (cons (quote -colon-) (cons (shen-dot-lazyderef A V3704) ()))) (cons (cons (shen-dot-lazyderef Y V3704) (cons (quote -colon-) (cons (cons (quote vector) (cons (shen-dot-lazyderef A V3704) ())) ()))) (shen-dot-lazyderef Hyp V3704))) V3704 V3705))) (if (shen-dot-pvar? V3501) (do (shen-dot-bindv V3501 () V3704) (clojure.core/let [Result (clojure.core/let [Hyp (tl V3487)] (do (shen-dot-incinfs) (bind V3703 (cons (cons (shen-dot-lazyderef X V3704) (cons (quote -colon-) (cons (shen-dot-lazyderef A V3704) ()))) (cons (cons (shen-dot-lazyderef Y V3704) (cons (quote -colon-) (cons (cons (quote vector) (cons (shen-dot-lazyderef A V3704) ())) ()))) (shen-dot-lazyderef Hyp V3704))) V3704 V3705)))] (do (shen-dot-unbindv V3501 V3704) Result))) false))) (if (shen-dot-pvar? V3500) (do (shen-dot-bindv V3500 () V3704) (clojure.core/let [Result (clojure.core/let [V3502 (shen-dot-lazyderef (tl V3496) V3704)] (if (= () V3502) (clojure.core/let [Hyp (tl V3487)] (do (shen-dot-incinfs) (bind V3703 (cons (cons (shen-dot-lazyderef X V3704) (cons (quote -colon-) (cons (shen-dot-lazyderef A V3704) ()))) (cons (cons (shen-dot-lazyderef Y V3704) (cons (quote -colon-) (cons (cons (quote vector) (cons (shen-dot-lazyderef A V3704) ())) ()))) (shen-dot-lazyderef Hyp V3704))) V3704 V3705))) (if (shen-dot-pvar? V3502) (do (shen-dot-bindv V3502 () V3704) (clojure.core/let [Result (clojure.core/let [Hyp (tl V3487)] (do (shen-dot-incinfs) (bind V3703 (cons (cons (shen-dot-lazyderef X V3704) (cons (quote -colon-) (cons (shen-dot-lazyderef A V3704) ()))) (cons (cons (shen-dot-lazyderef Y V3704) (cons (quote -colon-) (cons (cons (quote vector) (cons (shen-dot-lazyderef A V3704) ())) ()))) (shen-dot-lazyderef Hyp V3704))) V3704 V3705)))] (do (shen-dot-unbindv V3502 V3704) Result))) false)))] (do (shen-dot-unbindv V3500 V3704) Result))) false)))) (if (shen-dot-pvar? V3499) (clojure.core/let [A (shen-dot-newpv V3704)] (do (shen-dot-bindv V3499 (cons A ()) V3704) (clojure.core/let [Result (clojure.core/let [V3503 (shen-dot-lazyderef (tl V3496) V3704)] (if (= () V3503) (clojure.core/let [Hyp (tl V3487)] (do (shen-dot-incinfs) (bind V3703 (cons (cons (shen-dot-lazyderef X V3704) (cons (quote -colon-) (cons (shen-dot-lazyderef A V3704) ()))) (cons (cons (shen-dot-lazyderef Y V3704) (cons (quote -colon-) (cons (cons (quote vector) (cons (shen-dot-lazyderef A V3704) ())) ()))) (shen-dot-lazyderef Hyp V3704))) V3704 V3705))) (if (shen-dot-pvar? V3503) (do (shen-dot-bindv V3503 () V3704) (clojure.core/let [Result (clojure.core/let [Hyp (tl V3487)] (do (shen-dot-incinfs) (bind V3703 (cons (cons (shen-dot-lazyderef X V3704) (cons (quote -colon-) (cons (shen-dot-lazyderef A V3704) ()))) (cons (cons (shen-dot-lazyderef Y V3704) (cons (quote -colon-) (cons (cons (quote vector) (cons (shen-dot-lazyderef A V3704) ())) ()))) (shen-dot-lazyderef Hyp V3704))) V3704 V3705)))] (do (shen-dot-unbindv V3503 V3704) Result))) false)))] (do (shen-dot-unbindv V3499 V3704) Result)))) false))) (if (shen-dot-pvar? V3498) (do (shen-dot-bindv V3498 (quote vector) V3704) (clojure.core/let [Result (clojure.core/let [V3504 (shen-dot-lazyderef (tl V3497) V3704)] (if (cons? V3504) (clojure.core/let [A (hd V3504)] (clojure.core/let [V3505 (shen-dot-lazyderef (tl V3504) V3704)] (if (= () V3505) (clojure.core/let [V3506 (shen-dot-lazyderef (tl V3496) V3704)] (if (= () V3506) (clojure.core/let [Hyp (tl V3487)] (do (shen-dot-incinfs) (bind V3703 (cons (cons (shen-dot-lazyderef X V3704) (cons (quote -colon-) (cons (shen-dot-lazyderef A V3704) ()))) (cons (cons (shen-dot-lazyderef Y V3704) (cons (quote -colon-) (cons (cons (quote vector) (cons (shen-dot-lazyderef A V3704) ())) ()))) (shen-dot-lazyderef Hyp V3704))) V3704 V3705))) (if (shen-dot-pvar? V3506) (do (shen-dot-bindv V3506 () V3704) (clojure.core/let [Result (clojure.core/let [Hyp (tl V3487)] (do (shen-dot-incinfs) (bind V3703 (cons (cons (shen-dot-lazyderef X V3704) (cons (quote -colon-) (cons (shen-dot-lazyderef A V3704) ()))) (cons (cons (shen-dot-lazyderef Y V3704) (cons (quote -colon-) (cons (cons (quote vector) (cons (shen-dot-lazyderef A V3704) ())) ()))) (shen-dot-lazyderef Hyp V3704))) V3704 V3705)))] (do (shen-dot-unbindv V3506 V3704) Result))) false))) (if (shen-dot-pvar? V3505) (do (shen-dot-bindv V3505 () V3704) (clojure.core/let [Result (clojure.core/let [V3507 (shen-dot-lazyderef (tl V3496) V3704)] (if (= () V3507) (clojure.core/let [Hyp (tl V3487)] (do (shen-dot-incinfs) (bind V3703 (cons (cons (shen-dot-lazyderef X V3704) (cons (quote -colon-) (cons (shen-dot-lazyderef A V3704) ()))) (cons (cons (shen-dot-lazyderef Y V3704) (cons (quote -colon-) (cons (cons (quote vector) (cons (shen-dot-lazyderef A V3704) ())) ()))) (shen-dot-lazyderef Hyp V3704))) V3704 V3705))) (if (shen-dot-pvar? V3507) (do (shen-dot-bindv V3507 () V3704) (clojure.core/let [Result (clojure.core/let [Hyp (tl V3487)] (do (shen-dot-incinfs) (bind V3703 (cons (cons (shen-dot-lazyderef X V3704) (cons (quote -colon-) (cons (shen-dot-lazyderef A V3704) ()))) (cons (cons (shen-dot-lazyderef Y V3704) (cons (quote -colon-) (cons (cons (quote vector) (cons (shen-dot-lazyderef A V3704) ())) ()))) (shen-dot-lazyderef Hyp V3704))) V3704 V3705)))] (do (shen-dot-unbindv V3507 V3704) Result))) false)))] (do (shen-dot-unbindv V3505 V3704) Result))) false)))) (if (shen-dot-pvar? V3504) (clojure.core/let [A (shen-dot-newpv V3704)] (do (shen-dot-bindv V3504 (cons A ()) V3704) (clojure.core/let [Result (clojure.core/let [V3508 (shen-dot-lazyderef (tl V3496) V3704)] (if (= () V3508) (clojure.core/let [Hyp (tl V3487)] (do (shen-dot-incinfs) (bind V3703 (cons (cons (shen-dot-lazyderef X V3704) (cons (quote -colon-) (cons (shen-dot-lazyderef A V3704) ()))) (cons (cons (shen-dot-lazyderef Y V3704) (cons (quote -colon-) (cons (cons (quote vector) (cons (shen-dot-lazyderef A V3704) ())) ()))) (shen-dot-lazyderef Hyp V3704))) V3704 V3705))) (if (shen-dot-pvar? V3508) (do (shen-dot-bindv V3508 () V3704) (clojure.core/let [Result (clojure.core/let [Hyp (tl V3487)] (do (shen-dot-incinfs) (bind V3703 (cons (cons (shen-dot-lazyderef X V3704) (cons (quote -colon-) (cons (shen-dot-lazyderef A V3704) ()))) (cons (cons (shen-dot-lazyderef Y V3704) (cons (quote -colon-) (cons (cons (quote vector) (cons (shen-dot-lazyderef A V3704) ())) ()))) (shen-dot-lazyderef Hyp V3704))) V3704 V3705)))] (do (shen-dot-unbindv V3508 V3704) Result))) false)))] (do (shen-dot-unbindv V3504 V3704) Result)))) false)))] (do (shen-dot-unbindv V3498 V3704) Result))) false))) (if (shen-dot-pvar? V3497) (clojure.core/let [A (shen-dot-newpv V3704)] (do (shen-dot-bindv V3497 (cons (quote vector) (cons A ())) V3704) (clojure.core/let [Result (clojure.core/let [V3509 (shen-dot-lazyderef (tl V3496) V3704)] (if (= () V3509) (clojure.core/let [Hyp (tl V3487)] (do (shen-dot-incinfs) (bind V3703 (cons (cons (shen-dot-lazyderef X V3704) (cons (quote -colon-) (cons (shen-dot-lazyderef A V3704) ()))) (cons (cons (shen-dot-lazyderef Y V3704) (cons (quote -colon-) (cons (cons (quote vector) (cons (shen-dot-lazyderef A V3704) ())) ()))) (shen-dot-lazyderef Hyp V3704))) V3704 V3705))) (if (shen-dot-pvar? V3509) (do (shen-dot-bindv V3509 () V3704) (clojure.core/let [Result (clojure.core/let [Hyp (tl V3487)] (do (shen-dot-incinfs) (bind V3703 (cons (cons (shen-dot-lazyderef X V3704) (cons (quote -colon-) (cons (shen-dot-lazyderef A V3704) ()))) (cons (cons (shen-dot-lazyderef Y V3704) (cons (quote -colon-) (cons (cons (quote vector) (cons (shen-dot-lazyderef A V3704) ())) ()))) (shen-dot-lazyderef Hyp V3704))) V3704 V3705)))] (do (shen-dot-unbindv V3509 V3704) Result))) false)))] (do (shen-dot-unbindv V3497 V3704) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false))] (if (= Case false) (clojure.core/let [Case (clojure.core/let [V3510 (shen-dot-lazyderef V3702 V3704)] (if (cons? V3510) (clojure.core/let [V3511 (shen-dot-lazyderef (hd V3510) V3704)] (if (cons? V3511) (clojure.core/let [V3512 (shen-dot-lazyderef (hd V3511) V3704)] (if (cons? V3512) (clojure.core/let [V3513 (shen-dot-lazyderef (hd V3512) V3704)] (if (= (quote -at-s) V3513) (clojure.core/let [V3514 (shen-dot-lazyderef (tl V3512) V3704)] (if (cons? V3514) (clojure.core/let [X (hd V3514)] (clojure.core/let [V3515 (shen-dot-lazyderef (tl V3514) V3704)] (if (cons? V3515) (clojure.core/let [Y (hd V3515)] (clojure.core/let [V3516 (shen-dot-lazyderef (tl V3515) V3704)] (if (= () V3516) (clojure.core/let [V3517 (shen-dot-lazyderef (tl V3511) V3704)] (if (cons? V3517) (clojure.core/let [V3518 (shen-dot-lazyderef (hd V3517) V3704)] (if (= (quote -colon-) V3518) (clojure.core/let [V3519 (shen-dot-lazyderef (tl V3517) V3704)] (if (cons? V3519) (clojure.core/let [V3520 (shen-dot-lazyderef (hd V3519) V3704)] (if (= (quote string) V3520) (clojure.core/let [V3521 (shen-dot-lazyderef (tl V3519) V3704)] (if (= () V3521) (clojure.core/let [Hyp (tl V3510)] (do (shen-dot-incinfs) (bind V3703 (cons (cons (shen-dot-lazyderef X V3704) (cons (quote -colon-) (cons (quote string) ()))) (cons (cons (shen-dot-lazyderef Y V3704) (cons (quote -colon-) (cons (quote string) ()))) (shen-dot-lazyderef Hyp V3704))) V3704 V3705))) (if (shen-dot-pvar? V3521) (do (shen-dot-bindv V3521 () V3704) (clojure.core/let [Result (clojure.core/let [Hyp (tl V3510)] (do (shen-dot-incinfs) (bind V3703 (cons (cons (shen-dot-lazyderef X V3704) (cons (quote -colon-) (cons (quote string) ()))) (cons (cons (shen-dot-lazyderef Y V3704) (cons (quote -colon-) (cons (quote string) ()))) (shen-dot-lazyderef Hyp V3704))) V3704 V3705)))] (do (shen-dot-unbindv V3521 V3704) Result))) false))) (if (shen-dot-pvar? V3520) (do (shen-dot-bindv V3520 (quote string) V3704) (clojure.core/let [Result (clojure.core/let [V3522 (shen-dot-lazyderef (tl V3519) V3704)] (if (= () V3522) (clojure.core/let [Hyp (tl V3510)] (do (shen-dot-incinfs) (bind V3703 (cons (cons (shen-dot-lazyderef X V3704) (cons (quote -colon-) (cons (quote string) ()))) (cons (cons (shen-dot-lazyderef Y V3704) (cons (quote -colon-) (cons (quote string) ()))) (shen-dot-lazyderef Hyp V3704))) V3704 V3705))) (if (shen-dot-pvar? V3522) (do (shen-dot-bindv V3522 () V3704) (clojure.core/let [Result (clojure.core/let [Hyp (tl V3510)] (do (shen-dot-incinfs) (bind V3703 (cons (cons (shen-dot-lazyderef X V3704) (cons (quote -colon-) (cons (quote string) ()))) (cons (cons (shen-dot-lazyderef Y V3704) (cons (quote -colon-) (cons (quote string) ()))) (shen-dot-lazyderef Hyp V3704))) V3704 V3705)))] (do (shen-dot-unbindv V3522 V3704) Result))) false)))] (do (shen-dot-unbindv V3520 V3704) Result))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false))] (if (= Case false) (clojure.core/let [V3523 (shen-dot-lazyderef V3702 V3704)] (if (cons? V3523) (clojure.core/let [X (hd V3523)] (clojure.core/let [Hyp (tl V3523)] (clojure.core/let [NewHyps (shen-dot-newpv V3704)] (do (shen-dot-incinfs) (bind V3703 (cons (shen-dot-lazyderef X V3704) (shen-dot-lazyderef NewHyps V3704)) V3704 (clojure.core/fn [] (shen-dot-t*-hyps Hyp NewHyps V3704 V3705))))))) false)) Case)) Case))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-t*-hyps-aux-2 [V3702 V3703 V3704 V3705] (clojure.core/let [Case (clojure.core/let [V3462 (shen-dot-lazyderef V3702 V3704)] (if (cons? V3462) (clojure.core/let [V3463 (shen-dot-lazyderef (hd V3462) V3704)] (if (cons? V3463) (clojure.core/let [V3464 (shen-dot-lazyderef (hd V3463) V3704)] (if (cons? V3464) (clojure.core/let [V3465 (shen-dot-lazyderef (hd V3464) V3704)] (if (= (quote -at-p) V3465) (clojure.core/let [V3466 (shen-dot-lazyderef (tl V3464) V3704)] (if (cons? V3466) (clojure.core/let [X (hd V3466)] (clojure.core/let [V3467 (shen-dot-lazyderef (tl V3466) V3704)] (if (cons? V3467) (clojure.core/let [Y (hd V3467)] (clojure.core/let [V3468 (shen-dot-lazyderef (tl V3467) V3704)] (if (= () V3468) (clojure.core/let [V3469 (shen-dot-lazyderef (tl V3463) V3704)] (if (cons? V3469) (clojure.core/let [V3470 (shen-dot-lazyderef (hd V3469) V3704)] (if (= (quote -colon-) V3470) (clojure.core/let [V3471 (shen-dot-lazyderef (tl V3469) V3704)] (if (cons? V3471) (clojure.core/let [V3472 (shen-dot-lazyderef (hd V3471) V3704)] (if (cons? V3472) (clojure.core/let [A (hd V3472)] (clojure.core/let [V3473 (shen-dot-lazyderef (tl V3472) V3704)] (if (cons? V3473) (clojure.core/let [V3474 (shen-dot-lazyderef (hd V3473) V3704)] (if (= (quote *) V3474) (clojure.core/let [V3475 (shen-dot-lazyderef (tl V3473) V3704)] (if (cons? V3475) (clojure.core/let [B (hd V3475)] (clojure.core/let [V3476 (shen-dot-lazyderef (tl V3475) V3704)] (if (= () V3476) (clojure.core/let [V3477 (shen-dot-lazyderef (tl V3471) V3704)] (if (= () V3477) (clojure.core/let [Hyp (tl V3462)] (do (shen-dot-incinfs) (bind V3703 (cons (cons (shen-dot-lazyderef X V3704) (cons (quote -colon-) (cons (shen-dot-lazyderef A V3704) ()))) (cons (cons (shen-dot-lazyderef Y V3704) (cons (quote -colon-) (cons (shen-dot-lazyderef B V3704) ()))) (shen-dot-lazyderef Hyp V3704))) V3704 V3705))) (if (shen-dot-pvar? V3477) (do (shen-dot-bindv V3477 () V3704) (clojure.core/let [Result (clojure.core/let [Hyp (tl V3462)] (do (shen-dot-incinfs) (bind V3703 (cons (cons (shen-dot-lazyderef X V3704) (cons (quote -colon-) (cons (shen-dot-lazyderef A V3704) ()))) (cons (cons (shen-dot-lazyderef Y V3704) (cons (quote -colon-) (cons (shen-dot-lazyderef B V3704) ()))) (shen-dot-lazyderef Hyp V3704))) V3704 V3705)))] (do (shen-dot-unbindv V3477 V3704) Result))) false))) (if (shen-dot-pvar? V3476) (do (shen-dot-bindv V3476 () V3704) (clojure.core/let [Result (clojure.core/let [V3478 (shen-dot-lazyderef (tl V3471) V3704)] (if (= () V3478) (clojure.core/let [Hyp (tl V3462)] (do (shen-dot-incinfs) (bind V3703 (cons (cons (shen-dot-lazyderef X V3704) (cons (quote -colon-) (cons (shen-dot-lazyderef A V3704) ()))) (cons (cons (shen-dot-lazyderef Y V3704) (cons (quote -colon-) (cons (shen-dot-lazyderef B V3704) ()))) (shen-dot-lazyderef Hyp V3704))) V3704 V3705))) (if (shen-dot-pvar? V3478) (do (shen-dot-bindv V3478 () V3704) (clojure.core/let [Result (clojure.core/let [Hyp (tl V3462)] (do (shen-dot-incinfs) (bind V3703 (cons (cons (shen-dot-lazyderef X V3704) (cons (quote -colon-) (cons (shen-dot-lazyderef A V3704) ()))) (cons (cons (shen-dot-lazyderef Y V3704) (cons (quote -colon-) (cons (shen-dot-lazyderef B V3704) ()))) (shen-dot-lazyderef Hyp V3704))) V3704 V3705)))] (do (shen-dot-unbindv V3478 V3704) Result))) false)))] (do (shen-dot-unbindv V3476 V3704) Result))) false)))) (if (shen-dot-pvar? V3475) (clojure.core/let [B (shen-dot-newpv V3704)] (do (shen-dot-bindv V3475 (cons B ()) V3704) (clojure.core/let [Result (clojure.core/let [V3479 (shen-dot-lazyderef (tl V3471) V3704)] (if (= () V3479) (clojure.core/let [Hyp (tl V3462)] (do (shen-dot-incinfs) (bind V3703 (cons (cons (shen-dot-lazyderef X V3704) (cons (quote -colon-) (cons (shen-dot-lazyderef A V3704) ()))) (cons (cons (shen-dot-lazyderef Y V3704) (cons (quote -colon-) (cons (shen-dot-lazyderef B V3704) ()))) (shen-dot-lazyderef Hyp V3704))) V3704 V3705))) (if (shen-dot-pvar? V3479) (do (shen-dot-bindv V3479 () V3704) (clojure.core/let [Result (clojure.core/let [Hyp (tl V3462)] (do (shen-dot-incinfs) (bind V3703 (cons (cons (shen-dot-lazyderef X V3704) (cons (quote -colon-) (cons (shen-dot-lazyderef A V3704) ()))) (cons (cons (shen-dot-lazyderef Y V3704) (cons (quote -colon-) (cons (shen-dot-lazyderef B V3704) ()))) (shen-dot-lazyderef Hyp V3704))) V3704 V3705)))] (do (shen-dot-unbindv V3479 V3704) Result))) false)))] (do (shen-dot-unbindv V3475 V3704) Result)))) false))) (if (shen-dot-pvar? V3474) (do (shen-dot-bindv V3474 (quote *) V3704) (clojure.core/let [Result (clojure.core/let [V3480 (shen-dot-lazyderef (tl V3473) V3704)] (if (cons? V3480) (clojure.core/let [B (hd V3480)] (clojure.core/let [V3481 (shen-dot-lazyderef (tl V3480) V3704)] (if (= () V3481) (clojure.core/let [V3482 (shen-dot-lazyderef (tl V3471) V3704)] (if (= () V3482) (clojure.core/let [Hyp (tl V3462)] (do (shen-dot-incinfs) (bind V3703 (cons (cons (shen-dot-lazyderef X V3704) (cons (quote -colon-) (cons (shen-dot-lazyderef A V3704) ()))) (cons (cons (shen-dot-lazyderef Y V3704) (cons (quote -colon-) (cons (shen-dot-lazyderef B V3704) ()))) (shen-dot-lazyderef Hyp V3704))) V3704 V3705))) (if (shen-dot-pvar? V3482) (do (shen-dot-bindv V3482 () V3704) (clojure.core/let [Result (clojure.core/let [Hyp (tl V3462)] (do (shen-dot-incinfs) (bind V3703 (cons (cons (shen-dot-lazyderef X V3704) (cons (quote -colon-) (cons (shen-dot-lazyderef A V3704) ()))) (cons (cons (shen-dot-lazyderef Y V3704) (cons (quote -colon-) (cons (shen-dot-lazyderef B V3704) ()))) (shen-dot-lazyderef Hyp V3704))) V3704 V3705)))] (do (shen-dot-unbindv V3482 V3704) Result))) false))) (if (shen-dot-pvar? V3481) (do (shen-dot-bindv V3481 () V3704) (clojure.core/let [Result (clojure.core/let [V3483 (shen-dot-lazyderef (tl V3471) V3704)] (if (= () V3483) (clojure.core/let [Hyp (tl V3462)] (do (shen-dot-incinfs) (bind V3703 (cons (cons (shen-dot-lazyderef X V3704) (cons (quote -colon-) (cons (shen-dot-lazyderef A V3704) ()))) (cons (cons (shen-dot-lazyderef Y V3704) (cons (quote -colon-) (cons (shen-dot-lazyderef B V3704) ()))) (shen-dot-lazyderef Hyp V3704))) V3704 V3705))) (if (shen-dot-pvar? V3483) (do (shen-dot-bindv V3483 () V3704) (clojure.core/let [Result (clojure.core/let [Hyp (tl V3462)] (do (shen-dot-incinfs) (bind V3703 (cons (cons (shen-dot-lazyderef X V3704) (cons (quote -colon-) (cons (shen-dot-lazyderef A V3704) ()))) (cons (cons (shen-dot-lazyderef Y V3704) (cons (quote -colon-) (cons (shen-dot-lazyderef B V3704) ()))) (shen-dot-lazyderef Hyp V3704))) V3704 V3705)))] (do (shen-dot-unbindv V3483 V3704) Result))) false)))] (do (shen-dot-unbindv V3481 V3704) Result))) false)))) (if (shen-dot-pvar? V3480) (clojure.core/let [B (shen-dot-newpv V3704)] (do (shen-dot-bindv V3480 (cons B ()) V3704) (clojure.core/let [Result (clojure.core/let [V3484 (shen-dot-lazyderef (tl V3471) V3704)] (if (= () V3484) (clojure.core/let [Hyp (tl V3462)] (do (shen-dot-incinfs) (bind V3703 (cons (cons (shen-dot-lazyderef X V3704) (cons (quote -colon-) (cons (shen-dot-lazyderef A V3704) ()))) (cons (cons (shen-dot-lazyderef Y V3704) (cons (quote -colon-) (cons (shen-dot-lazyderef B V3704) ()))) (shen-dot-lazyderef Hyp V3704))) V3704 V3705))) (if (shen-dot-pvar? V3484) (do (shen-dot-bindv V3484 () V3704) (clojure.core/let [Result (clojure.core/let [Hyp (tl V3462)] (do (shen-dot-incinfs) (bind V3703 (cons (cons (shen-dot-lazyderef X V3704) (cons (quote -colon-) (cons (shen-dot-lazyderef A V3704) ()))) (cons (cons (shen-dot-lazyderef Y V3704) (cons (quote -colon-) (cons (shen-dot-lazyderef B V3704) ()))) (shen-dot-lazyderef Hyp V3704))) V3704 V3705)))] (do (shen-dot-unbindv V3484 V3704) Result))) false)))] (do (shen-dot-unbindv V3480 V3704) Result)))) false)))] (do (shen-dot-unbindv V3474 V3704) Result))) false))) (if (shen-dot-pvar? V3473) (clojure.core/let [B (shen-dot-newpv V3704)] (do (shen-dot-bindv V3473 (cons (quote *) (cons B ())) V3704) (clojure.core/let [Result (clojure.core/let [V3485 (shen-dot-lazyderef (tl V3471) V3704)] (if (= () V3485) (clojure.core/let [Hyp (tl V3462)] (do (shen-dot-incinfs) (bind V3703 (cons (cons (shen-dot-lazyderef X V3704) (cons (quote -colon-) (cons (shen-dot-lazyderef A V3704) ()))) (cons (cons (shen-dot-lazyderef Y V3704) (cons (quote -colon-) (cons (shen-dot-lazyderef B V3704) ()))) (shen-dot-lazyderef Hyp V3704))) V3704 V3705))) (if (shen-dot-pvar? V3485) (do (shen-dot-bindv V3485 () V3704) (clojure.core/let [Result (clojure.core/let [Hyp (tl V3462)] (do (shen-dot-incinfs) (bind V3703 (cons (cons (shen-dot-lazyderef X V3704) (cons (quote -colon-) (cons (shen-dot-lazyderef A V3704) ()))) (cons (cons (shen-dot-lazyderef Y V3704) (cons (quote -colon-) (cons (shen-dot-lazyderef B V3704) ()))) (shen-dot-lazyderef Hyp V3704))) V3704 V3705)))] (do (shen-dot-unbindv V3485 V3704) Result))) false)))] (do (shen-dot-unbindv V3473 V3704) Result)))) false)))) (if (shen-dot-pvar? V3472) (clojure.core/let [A (shen-dot-newpv V3704)] (clojure.core/let [B (shen-dot-newpv V3704)] (do (shen-dot-bindv V3472 (cons A (cons (quote *) (cons B ()))) V3704) (clojure.core/let [Result (clojure.core/let [V3486 (shen-dot-lazyderef (tl V3471) V3704)] (if (= () V3486) (clojure.core/let [Hyp (tl V3462)] (do (shen-dot-incinfs) (bind V3703 (cons (cons (shen-dot-lazyderef X V3704) (cons (quote -colon-) (cons (shen-dot-lazyderef A V3704) ()))) (cons (cons (shen-dot-lazyderef Y V3704) (cons (quote -colon-) (cons (shen-dot-lazyderef B V3704) ()))) (shen-dot-lazyderef Hyp V3704))) V3704 V3705))) (if (shen-dot-pvar? V3486) (do (shen-dot-bindv V3486 () V3704) (clojure.core/let [Result (clojure.core/let [Hyp (tl V3462)] (do (shen-dot-incinfs) (bind V3703 (cons (cons (shen-dot-lazyderef X V3704) (cons (quote -colon-) (cons (shen-dot-lazyderef A V3704) ()))) (cons (cons (shen-dot-lazyderef Y V3704) (cons (quote -colon-) (cons (shen-dot-lazyderef B V3704) ()))) (shen-dot-lazyderef Hyp V3704))) V3704 V3705)))] (do (shen-dot-unbindv V3486 V3704) Result))) false)))] (do (shen-dot-unbindv V3472 V3704) Result))))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false))] (if (= Case false) (shen-dot-t*-hyps-aux V3702 V3703 V3704 V3705) Case))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-t*-hyps [V3702 V3703 V3704 V3705] (clojure.core/let [Case (clojure.core/let [V3439 (shen-dot-lazyderef V3702 V3704)] (if (cons? V3439) (clojure.core/let [V3440 (shen-dot-lazyderef (hd V3439) V3704)] (if (cons? V3440) (clojure.core/let [V3441 (shen-dot-lazyderef (hd V3440) V3704)] (if (cons? V3441) (clojure.core/let [V3442 (shen-dot-lazyderef (hd V3441) V3704)] (if (= (quote cons) V3442) (clojure.core/let [V3443 (shen-dot-lazyderef (tl V3441) V3704)] (if (cons? V3443) (clojure.core/let [X (hd V3443)] (clojure.core/let [V3444 (shen-dot-lazyderef (tl V3443) V3704)] (if (cons? V3444) (clojure.core/let [Y (hd V3444)] (clojure.core/let [V3445 (shen-dot-lazyderef (tl V3444) V3704)] (if (= () V3445) (clojure.core/let [V3446 (shen-dot-lazyderef (tl V3440) V3704)] (if (cons? V3446) (clojure.core/let [V3447 (shen-dot-lazyderef (hd V3446) V3704)] (if (= (quote -colon-) V3447) (clojure.core/let [V3448 (shen-dot-lazyderef (tl V3446) V3704)] (if (cons? V3448) (clojure.core/let [V3449 (shen-dot-lazyderef (hd V3448) V3704)] (if (cons? V3449) (clojure.core/let [V3450 (shen-dot-lazyderef (hd V3449) V3704)] (if (= (quote list) V3450) (clojure.core/let [V3451 (shen-dot-lazyderef (tl V3449) V3704)] (if (cons? V3451) (clojure.core/let [A (hd V3451)] (clojure.core/let [V3452 (shen-dot-lazyderef (tl V3451) V3704)] (if (= () V3452) (clojure.core/let [V3453 (shen-dot-lazyderef (tl V3448) V3704)] (if (= () V3453) (clojure.core/let [Hyp (tl V3439)] (do (shen-dot-incinfs) (bind V3703 (cons (cons (shen-dot-lazyderef X V3704) (cons (quote -colon-) (cons (shen-dot-lazyderef A V3704) ()))) (cons (cons (shen-dot-lazyderef Y V3704) (cons (quote -colon-) (cons (cons (quote list) (cons (shen-dot-lazyderef A V3704) ())) ()))) (shen-dot-lazyderef Hyp V3704))) V3704 V3705))) (if (shen-dot-pvar? V3453) (do (shen-dot-bindv V3453 () V3704) (clojure.core/let [Result (clojure.core/let [Hyp (tl V3439)] (do (shen-dot-incinfs) (bind V3703 (cons (cons (shen-dot-lazyderef X V3704) (cons (quote -colon-) (cons (shen-dot-lazyderef A V3704) ()))) (cons (cons (shen-dot-lazyderef Y V3704) (cons (quote -colon-) (cons (cons (quote list) (cons (shen-dot-lazyderef A V3704) ())) ()))) (shen-dot-lazyderef Hyp V3704))) V3704 V3705)))] (do (shen-dot-unbindv V3453 V3704) Result))) false))) (if (shen-dot-pvar? V3452) (do (shen-dot-bindv V3452 () V3704) (clojure.core/let [Result (clojure.core/let [V3454 (shen-dot-lazyderef (tl V3448) V3704)] (if (= () V3454) (clojure.core/let [Hyp (tl V3439)] (do (shen-dot-incinfs) (bind V3703 (cons (cons (shen-dot-lazyderef X V3704) (cons (quote -colon-) (cons (shen-dot-lazyderef A V3704) ()))) (cons (cons (shen-dot-lazyderef Y V3704) (cons (quote -colon-) (cons (cons (quote list) (cons (shen-dot-lazyderef A V3704) ())) ()))) (shen-dot-lazyderef Hyp V3704))) V3704 V3705))) (if (shen-dot-pvar? V3454) (do (shen-dot-bindv V3454 () V3704) (clojure.core/let [Result (clojure.core/let [Hyp (tl V3439)] (do (shen-dot-incinfs) (bind V3703 (cons (cons (shen-dot-lazyderef X V3704) (cons (quote -colon-) (cons (shen-dot-lazyderef A V3704) ()))) (cons (cons (shen-dot-lazyderef Y V3704) (cons (quote -colon-) (cons (cons (quote list) (cons (shen-dot-lazyderef A V3704) ())) ()))) (shen-dot-lazyderef Hyp V3704))) V3704 V3705)))] (do (shen-dot-unbindv V3454 V3704) Result))) false)))] (do (shen-dot-unbindv V3452 V3704) Result))) false)))) (if (shen-dot-pvar? V3451) (clojure.core/let [A (shen-dot-newpv V3704)] (do (shen-dot-bindv V3451 (cons A ()) V3704) (clojure.core/let [Result (clojure.core/let [V3455 (shen-dot-lazyderef (tl V3448) V3704)] (if (= () V3455) (clojure.core/let [Hyp (tl V3439)] (do (shen-dot-incinfs) (bind V3703 (cons (cons (shen-dot-lazyderef X V3704) (cons (quote -colon-) (cons (shen-dot-lazyderef A V3704) ()))) (cons (cons (shen-dot-lazyderef Y V3704) (cons (quote -colon-) (cons (cons (quote list) (cons (shen-dot-lazyderef A V3704) ())) ()))) (shen-dot-lazyderef Hyp V3704))) V3704 V3705))) (if (shen-dot-pvar? V3455) (do (shen-dot-bindv V3455 () V3704) (clojure.core/let [Result (clojure.core/let [Hyp (tl V3439)] (do (shen-dot-incinfs) (bind V3703 (cons (cons (shen-dot-lazyderef X V3704) (cons (quote -colon-) (cons (shen-dot-lazyderef A V3704) ()))) (cons (cons (shen-dot-lazyderef Y V3704) (cons (quote -colon-) (cons (cons (quote list) (cons (shen-dot-lazyderef A V3704) ())) ()))) (shen-dot-lazyderef Hyp V3704))) V3704 V3705)))] (do (shen-dot-unbindv V3455 V3704) Result))) false)))] (do (shen-dot-unbindv V3451 V3704) Result)))) false))) (if (shen-dot-pvar? V3450) (do (shen-dot-bindv V3450 (quote list) V3704) (clojure.core/let [Result (clojure.core/let [V3456 (shen-dot-lazyderef (tl V3449) V3704)] (if (cons? V3456) (clojure.core/let [A (hd V3456)] (clojure.core/let [V3457 (shen-dot-lazyderef (tl V3456) V3704)] (if (= () V3457) (clojure.core/let [V3458 (shen-dot-lazyderef (tl V3448) V3704)] (if (= () V3458) (clojure.core/let [Hyp (tl V3439)] (do (shen-dot-incinfs) (bind V3703 (cons (cons (shen-dot-lazyderef X V3704) (cons (quote -colon-) (cons (shen-dot-lazyderef A V3704) ()))) (cons (cons (shen-dot-lazyderef Y V3704) (cons (quote -colon-) (cons (cons (quote list) (cons (shen-dot-lazyderef A V3704) ())) ()))) (shen-dot-lazyderef Hyp V3704))) V3704 V3705))) (if (shen-dot-pvar? V3458) (do (shen-dot-bindv V3458 () V3704) (clojure.core/let [Result (clojure.core/let [Hyp (tl V3439)] (do (shen-dot-incinfs) (bind V3703 (cons (cons (shen-dot-lazyderef X V3704) (cons (quote -colon-) (cons (shen-dot-lazyderef A V3704) ()))) (cons (cons (shen-dot-lazyderef Y V3704) (cons (quote -colon-) (cons (cons (quote list) (cons (shen-dot-lazyderef A V3704) ())) ()))) (shen-dot-lazyderef Hyp V3704))) V3704 V3705)))] (do (shen-dot-unbindv V3458 V3704) Result))) false))) (if (shen-dot-pvar? V3457) (do (shen-dot-bindv V3457 () V3704) (clojure.core/let [Result (clojure.core/let [V3459 (shen-dot-lazyderef (tl V3448) V3704)] (if (= () V3459) (clojure.core/let [Hyp (tl V3439)] (do (shen-dot-incinfs) (bind V3703 (cons (cons (shen-dot-lazyderef X V3704) (cons (quote -colon-) (cons (shen-dot-lazyderef A V3704) ()))) (cons (cons (shen-dot-lazyderef Y V3704) (cons (quote -colon-) (cons (cons (quote list) (cons (shen-dot-lazyderef A V3704) ())) ()))) (shen-dot-lazyderef Hyp V3704))) V3704 V3705))) (if (shen-dot-pvar? V3459) (do (shen-dot-bindv V3459 () V3704) (clojure.core/let [Result (clojure.core/let [Hyp (tl V3439)] (do (shen-dot-incinfs) (bind V3703 (cons (cons (shen-dot-lazyderef X V3704) (cons (quote -colon-) (cons (shen-dot-lazyderef A V3704) ()))) (cons (cons (shen-dot-lazyderef Y V3704) (cons (quote -colon-) (cons (cons (quote list) (cons (shen-dot-lazyderef A V3704) ())) ()))) (shen-dot-lazyderef Hyp V3704))) V3704 V3705)))] (do (shen-dot-unbindv V3459 V3704) Result))) false)))] (do (shen-dot-unbindv V3457 V3704) Result))) false)))) (if (shen-dot-pvar? V3456) (clojure.core/let [A (shen-dot-newpv V3704)] (do (shen-dot-bindv V3456 (cons A ()) V3704) (clojure.core/let [Result (clojure.core/let [V3460 (shen-dot-lazyderef (tl V3448) V3704)] (if (= () V3460) (clojure.core/let [Hyp (tl V3439)] (do (shen-dot-incinfs) (bind V3703 (cons (cons (shen-dot-lazyderef X V3704) (cons (quote -colon-) (cons (shen-dot-lazyderef A V3704) ()))) (cons (cons (shen-dot-lazyderef Y V3704) (cons (quote -colon-) (cons (cons (quote list) (cons (shen-dot-lazyderef A V3704) ())) ()))) (shen-dot-lazyderef Hyp V3704))) V3704 V3705))) (if (shen-dot-pvar? V3460) (do (shen-dot-bindv V3460 () V3704) (clojure.core/let [Result (clojure.core/let [Hyp (tl V3439)] (do (shen-dot-incinfs) (bind V3703 (cons (cons (shen-dot-lazyderef X V3704) (cons (quote -colon-) (cons (shen-dot-lazyderef A V3704) ()))) (cons (cons (shen-dot-lazyderef Y V3704) (cons (quote -colon-) (cons (cons (quote list) (cons (shen-dot-lazyderef A V3704) ())) ()))) (shen-dot-lazyderef Hyp V3704))) V3704 V3705)))] (do (shen-dot-unbindv V3460 V3704) Result))) false)))] (do (shen-dot-unbindv V3456 V3704) Result)))) false)))] (do (shen-dot-unbindv V3450 V3704) Result))) false))) (if (shen-dot-pvar? V3449) (clojure.core/let [A (shen-dot-newpv V3704)] (do (shen-dot-bindv V3449 (cons (quote list) (cons A ())) V3704) (clojure.core/let [Result (clojure.core/let [V3461 (shen-dot-lazyderef (tl V3448) V3704)] (if (= () V3461) (clojure.core/let [Hyp (tl V3439)] (do (shen-dot-incinfs) (bind V3703 (cons (cons (shen-dot-lazyderef X V3704) (cons (quote -colon-) (cons (shen-dot-lazyderef A V3704) ()))) (cons (cons (shen-dot-lazyderef Y V3704) (cons (quote -colon-) (cons (cons (quote list) (cons (shen-dot-lazyderef A V3704) ())) ()))) (shen-dot-lazyderef Hyp V3704))) V3704 V3705))) (if (shen-dot-pvar? V3461) (do (shen-dot-bindv V3461 () V3704) (clojure.core/let [Result (clojure.core/let [Hyp (tl V3439)] (do (shen-dot-incinfs) (bind V3703 (cons (cons (shen-dot-lazyderef X V3704) (cons (quote -colon-) (cons (shen-dot-lazyderef A V3704) ()))) (cons (cons (shen-dot-lazyderef Y V3704) (cons (quote -colon-) (cons (cons (quote list) (cons (shen-dot-lazyderef A V3704) ())) ()))) (shen-dot-lazyderef Hyp V3704))) V3704 V3705)))] (do (shen-dot-unbindv V3461 V3704) Result))) false)))] (do (shen-dot-unbindv V3449 V3704) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false))] (if (= Case false) (shen-dot-t*-hyps-aux-2 V3702 V3703 V3704 V3705) Case))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-show [V3722 V3723 V3724 V3725] (clojure.core/cond (value (quote shen-dot-*spy*)) (do (shen-dot-line) (do (shen-dot-show-p (shen-dot-deref V3722 V3724)) (do (nl 1) (do (nl 1) (do (shen-dot-show-assumptions (shen-dot-deref V3723 V3724) 1) (do (shen-dot-prhush "\n> " (stoutput)) (do (shen-dot-pause-for-user) (thaw V3725)))))))) true (thaw V3725) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare inferences shen-dot-prhush cn shen-dot-app = stoutput) (clojure.core/defn shen-dot-line [] (clojure.core/let [Infs (inferences)] (shen-dot-prhush (cn "____________________________________________________________ " (shen-dot-app Infs (cn " inference" (shen-dot-app (if (= 1 Infs) "" "s") " \n?- " (quote shen-dot-a))) (quote shen-dot-a))) (stoutput))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? tl = hd shen-dot-prhush shen-dot-app cn stoutput) (clojure.core/defn shen-dot-show-p [V3727] (clojure.core/cond (clojure.core/and (cons? V3727) (clojure.core/and (cons? (tl V3727)) (clojure.core/and (= (quote -colon-) (hd (tl V3727))) (clojure.core/and (cons? (tl (tl V3727))) (= () (tl (tl (tl V3727)))))))) (shen-dot-prhush (shen-dot-app (hd V3727) (cn " : " (shen-dot-app (hd (tl (tl V3727))) "" (quote shen-dot-r))) (quote shen-dot-r)) (stoutput)) true (shen-dot-prhush (shen-dot-app V3727 "" (quote shen-dot-r)) (stoutput)) :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-show-assumptions [V3732 V3733] (clojure.core/cond (= () V3732) (quote shen-dot-skip) (cons? V3732) (do (shen-dot-prhush (shen-dot-app V3733 ". " (quote shen-dot-a)) (stoutput)) (do (shen-dot-show-p (hd V3732)) (do (nl 1) (shen-dot-show-assumptions (tl V3732) (+ V3733 1))))) true (shen-dot-f_error (quote shen-dot-show-assumptions)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare read-byte stinput = simple-error nl) (clojure.core/defn shen-dot-pause-for-user [] (clojure.core/let [Byte (read-byte (stinput))] (if (= Byte 94) (simple-error "input aborted\n") (nl 1))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare cons? assoc value) (clojure.core/defn shen-dot-typedf? [V3735] (cons? (assoc V3735 (value (quote shen-dot-*signedfuncs*)))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare concat) (clojure.core/defn shen-dot-sigf [V3737] (concat (quote shen-dot-type-signature-of-) V3737))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare gensym) (clojure.core/defn shen-dot-placeholder [] (gensym (quote &&)))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-base [V3742 V3743 V3744 V3745] (clojure.core/let [Case (clojure.core/let [V3426 (shen-dot-lazyderef V3743 V3744)] (if (= (quote number) V3426) (do (shen-dot-incinfs) (fwhen (number? (shen-dot-lazyderef V3742 V3744)) V3744 V3745)) (if (shen-dot-pvar? V3426) (do (shen-dot-bindv V3426 (quote number) V3744) (clojure.core/let [Result (do (shen-dot-incinfs) (fwhen (number? (shen-dot-lazyderef V3742 V3744)) V3744 V3745))] (do (shen-dot-unbindv V3426 V3744) Result))) false)))] (if (= Case false) (clojure.core/let [Case (clojure.core/let [V3427 (shen-dot-lazyderef V3743 V3744)] (if (= (quote boolean) V3427) (do (shen-dot-incinfs) (fwhen (boolean? (shen-dot-lazyderef V3742 V3744)) V3744 V3745)) (if (shen-dot-pvar? V3427) (do (shen-dot-bindv V3427 (quote boolean) V3744) (clojure.core/let [Result (do (shen-dot-incinfs) (fwhen (boolean? (shen-dot-lazyderef V3742 V3744)) V3744 V3745))] (do (shen-dot-unbindv V3427 V3744) Result))) false)))] (if (= Case false) (clojure.core/let [Case (clojure.core/let [V3428 (shen-dot-lazyderef V3743 V3744)] (if (= (quote string) V3428) (do (shen-dot-incinfs) (fwhen (string? (shen-dot-lazyderef V3742 V3744)) V3744 V3745)) (if (shen-dot-pvar? V3428) (do (shen-dot-bindv V3428 (quote string) V3744) (clojure.core/let [Result (do (shen-dot-incinfs) (fwhen (string? (shen-dot-lazyderef V3742 V3744)) V3744 V3745))] (do (shen-dot-unbindv V3428 V3744) Result))) false)))] (if (= Case false) (clojure.core/let [Case (clojure.core/let [V3429 (shen-dot-lazyderef V3743 V3744)] (if (= (quote symbol) V3429) (do (shen-dot-incinfs) (fwhen (symbol? (shen-dot-lazyderef V3742 V3744)) V3744 (clojure.core/fn [] (fwhen (not (shen-dot-ue? (shen-dot-lazyderef V3742 V3744))) V3744 V3745)))) (if (shen-dot-pvar? V3429) (do (shen-dot-bindv V3429 (quote symbol) V3744) (clojure.core/let [Result (do (shen-dot-incinfs) (fwhen (symbol? (shen-dot-lazyderef V3742 V3744)) V3744 (clojure.core/fn [] (fwhen (not (shen-dot-ue? (shen-dot-lazyderef V3742 V3744))) V3744 V3745))))] (do (shen-dot-unbindv V3429 V3744) Result))) false)))] (if (= Case false) (clojure.core/let [V3430 (shen-dot-lazyderef V3742 V3744)] (if (= () V3430) (clojure.core/let [V3431 (shen-dot-lazyderef V3743 V3744)] (if (cons? V3431) (clojure.core/let [V3432 (shen-dot-lazyderef (hd V3431) V3744)] (if (= (quote list) V3432) (clojure.core/let [V3433 (shen-dot-lazyderef (tl V3431) V3744)] (if (cons? V3433) (clojure.core/let [A (hd V3433)] (clojure.core/let [V3434 (shen-dot-lazyderef (tl V3433) V3744)] (if (= () V3434) (do (shen-dot-incinfs) (thaw V3745)) (if (shen-dot-pvar? V3434) (do (shen-dot-bindv V3434 () V3744) (clojure.core/let [Result (do (shen-dot-incinfs) (thaw V3745))] (do (shen-dot-unbindv V3434 V3744) Result))) false)))) (if (shen-dot-pvar? V3433) (clojure.core/let [A (shen-dot-newpv V3744)] (do (shen-dot-bindv V3433 (cons A ()) V3744) (clojure.core/let [Result (do (shen-dot-incinfs) (thaw V3745))] (do (shen-dot-unbindv V3433 V3744) Result)))) false))) (if (shen-dot-pvar? V3432) (do (shen-dot-bindv V3432 (quote list) V3744) (clojure.core/let [Result (clojure.core/let [V3435 (shen-dot-lazyderef (tl V3431) V3744)] (if (cons? V3435) (clojure.core/let [A (hd V3435)] (clojure.core/let [V3436 (shen-dot-lazyderef (tl V3435) V3744)] (if (= () V3436) (do (shen-dot-incinfs) (thaw V3745)) (if (shen-dot-pvar? V3436) (do (shen-dot-bindv V3436 () V3744) (clojure.core/let [Result (do (shen-dot-incinfs) (thaw V3745))] (do (shen-dot-unbindv V3436 V3744) Result))) false)))) (if (shen-dot-pvar? V3435) (clojure.core/let [A (shen-dot-newpv V3744)] (do (shen-dot-bindv V3435 (cons A ()) V3744) (clojure.core/let [Result (do (shen-dot-incinfs) (thaw V3745))] (do (shen-dot-unbindv V3435 V3744) Result)))) false)))] (do (shen-dot-unbindv V3432 V3744) Result))) false))) (if (shen-dot-pvar? V3431) (clojure.core/let [A (shen-dot-newpv V3744)] (do (shen-dot-bindv V3431 (cons (quote list) (cons A ())) V3744) (clojure.core/let [Result (do (shen-dot-incinfs) (thaw V3745))] (do (shen-dot-unbindv V3431 V3744) Result)))) false))) false)) Case)) Case)) Case)) Case))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-by_hypothesis [V3751 V3752 V3753 V3754 V3755] (clojure.core/let [Case (clojure.core/let [V3417 (shen-dot-lazyderef V3753 V3754)] (if (cons? V3417) (clojure.core/let [V3418 (shen-dot-lazyderef (hd V3417) V3754)] (if (cons? V3418) (clojure.core/let [Y (hd V3418)] (clojure.core/let [V3419 (shen-dot-lazyderef (tl V3418) V3754)] (if (cons? V3419) (clojure.core/let [V3420 (shen-dot-lazyderef (hd V3419) V3754)] (if (= (quote -colon-) V3420) (clojure.core/let [V3421 (shen-dot-lazyderef (tl V3419) V3754)] (if (cons? V3421) (clojure.core/let [B (hd V3421)] (clojure.core/let [V3422 (shen-dot-lazyderef (tl V3421) V3754)] (if (= () V3422) (do (shen-dot-incinfs) (identical V3751 Y V3754 (clojure.core/fn [] (unify! V3752 B V3754 V3755)))) false))) false)) false)) false))) false)) false))] (if (= Case false) (clojure.core/let [V3423 (shen-dot-lazyderef V3753 V3754)] (if (cons? V3423) (clojure.core/let [Hyp (tl V3423)] (do (shen-dot-incinfs) (shen-dot-by_hypothesis V3751 V3752 Hyp V3754 V3755))) false)) Case))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-t*-def [V3761 V3762 V3763 V3764 V3765] (clojure.core/let [V3411 (shen-dot-lazyderef V3761 V3764)] (if (cons? V3411) (clojure.core/let [V3412 (shen-dot-lazyderef (hd V3411) V3764)] (if (= (quote define) V3412) (clojure.core/let [V3413 (shen-dot-lazyderef (tl V3411) V3764)] (if (cons? V3413) (clojure.core/let [F (hd V3413)] (clojure.core/let [X (tl V3413)] (clojure.core/let [Y (shen-dot-newpv V3764)] (clojure.core/let [E (shen-dot-newpv V3764)] (do (shen-dot-incinfs) (shen-dot-t*-defh (compile (do (clojure.core/declare shen-dot-<sig+rules>) (clojure.core/fn [Y] (shen-dot-<sig+rules> Y))) X (do (clojure.core/declare cons? simple-error cn shen-dot-app) (clojure.core/fn [E] (if (cons? E) (simple-error (cn "parse error here: " (shen-dot-app E "\n" (quote shen-dot-s)))) (simple-error "parse error\n"))))) F V3762 V3763 V3764 V3765)))))) false)) false)) false))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-t*-defh [V3772 V3773 V3774 V3775 V3776 V3777] (clojure.core/let [V3407 (shen-dot-lazyderef V3772 V3776)] (if (cons? V3407) (clojure.core/let [Sig (hd V3407)] (clojure.core/let [Rules (tl V3407)] (do (shen-dot-incinfs) (shen-dot-t*-defhh Sig (shen-dot-ue-sig Sig) V3773 V3774 V3775 Rules V3776 V3777)))) false))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-t*-defhh [V3786 V3787 V3788 V3789 V3790 V3791 V3792 V3793] (do (shen-dot-incinfs) (shen-dot-t*-rules V3791 V3787 1 V3788 (cons (cons V3788 (cons (quote -colon-) (cons V3787 ()))) V3790) V3792 (clojure.core/fn [] (shen-dot-memo V3788 V3786 V3789 V3792 V3793))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-memo [V3799 V3800 V3801 V3802 V3803] (clojure.core/let [Jnk (shen-dot-newpv V3802)] (do (shen-dot-incinfs) (unify! V3801 V3800 V3802 (clojure.core/fn [] (bind Jnk (declare (shen-dot-lazyderef V3799 V3802) (shen-dot-lazyderef V3801 V3802)) V3802 V3803)))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-<signature> not = fail shen-dot-<non-ll-rules> shen-dot-pair hd cons shen-dot-hdtl) (clojure.core/defn shen-dot-<sig+rules> [V3805] (clojure.core/let [Parse_shen-dot-<signature> (shen-dot-<signature> V3805)] (if (not (= (fail) Parse_shen-dot-<signature>)) (clojure.core/let [Parse_shen-dot-<non-ll-rules> (shen-dot-<non-ll-rules> Parse_shen-dot-<signature>)] (if (not (= (fail) Parse_shen-dot-<non-ll-rules>)) (shen-dot-pair (hd Parse_shen-dot-<non-ll-rules>) (cons (shen-dot-hdtl Parse_shen-dot-<signature>) (shen-dot-hdtl Parse_shen-dot-<non-ll-rules>))) (fail))) (fail))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-<rule> not = fail shen-dot-<non-ll-rules> shen-dot-pair hd cons shen-dot-hdtl) (clojure.core/defn shen-dot-<non-ll-rules> [V3807] (clojure.core/let [YaccParse (clojure.core/let [Parse_shen-dot-<rule> (shen-dot-<rule> V3807)] (if (not (= (fail) Parse_shen-dot-<rule>)) (clojure.core/let [Parse_shen-dot-<non-ll-rules> (shen-dot-<non-ll-rules> Parse_shen-dot-<rule>)] (if (not (= (fail) Parse_shen-dot-<non-ll-rules>)) (shen-dot-pair (hd Parse_shen-dot-<non-ll-rules>) (cons (shen-dot-hdtl Parse_shen-dot-<rule>) (shen-dot-hdtl Parse_shen-dot-<non-ll-rules>))) (fail))) (fail)))] (if (= YaccParse (fail)) (clojure.core/let [Parse_shen-dot-<rule> (shen-dot-<rule> V3807)] (if (not (= (fail) Parse_shen-dot-<rule>)) (shen-dot-pair (hd Parse_shen-dot-<rule>) (cons (shen-dot-hdtl Parse_shen-dot-<rule>) ())) (fail))) YaccParse)))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-ue cons? tl = hd map variable? concat) (clojure.core/defn shen-dot-ue [V3809] (clojure.core/cond (clojure.core/and (cons? V3809) (clojure.core/and (cons? (tl V3809)) (clojure.core/and (= () (tl (tl V3809))) (= (hd V3809) (quote protect))))) V3809 (cons? V3809) (map (do (clojure.core/declare shen-dot-ue) (clojure.core/fn [Z] (shen-dot-ue Z))) V3809) (variable? V3809) (concat (quote &&) V3809) true V3809 :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-ue-sig cons? map variable? concat) (clojure.core/defn shen-dot-ue-sig [V3811] (clojure.core/cond (cons? V3811) (map (do (clojure.core/declare shen-dot-ue-sig) (clojure.core/fn [Z] (shen-dot-ue-sig Z))) V3811) (variable? V3811) (concat (quote &&&) V3811) true V3811 :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-ue? cons cons? union shen-dot-ues hd tl) (clojure.core/defn shen-dot-ues [V3817] (clojure.core/cond (shen-dot-ue? V3817) (cons V3817 ()) (cons? V3817) (union (shen-dot-ues (hd V3817)) (shen-dot-ues (tl V3817))) true () :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare symbol? shen-dot-ue-h? str) (clojure.core/defn shen-dot-ue? [V3819] (clojure.core/and (symbol? V3819) (shen-dot-ue-h? (str V3819))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-+string? = pos tlstr) (clojure.core/defn shen-dot-ue-h? [V3827] (clojure.core/cond (clojure.core/and (shen-dot-+string? V3827) (clojure.core/and (= "&" (pos V3827 0)) (clojure.core/and (shen-dot-+string? (tlstr V3827)) (= "&" (pos (tlstr V3827) 0))))) true true false :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-t*-rules [V3835 V3836 V3837 V3838 V3839 V3840 V3841] (clojure.core/let [Throwcontrol (shen-dot-catchpoint)] (shen-dot-cutpoint Throwcontrol (clojure.core/let [Case (clojure.core/let [V3391 (shen-dot-lazyderef V3835 V3840)] (if (= () V3391) (do (shen-dot-incinfs) (thaw V3841)) false))] (if (= Case false) (clojure.core/let [Case (clojure.core/let [V3392 (shen-dot-lazyderef V3835 V3840)] (if (cons? V3392) (clojure.core/let [Rule (hd V3392)] (clojure.core/let [Rules (tl V3392)] (do (shen-dot-incinfs) (shen-dot-t*-rule (shen-dot-ue Rule) V3836 V3839 V3840 (clojure.core/fn [] (cut Throwcontrol V3840 (clojure.core/fn [] (shen-dot-t*-rules Rules V3836 (+ V3837 1) V3838 V3839 V3840 V3841)))))))) false))] (if (= Case false) (clojure.core/let [Err (shen-dot-newpv V3840)] (do (shen-dot-incinfs) (bind Err (simple-error (cn "type error in rule " (shen-dot-app (shen-dot-lazyderef V3837 V3840) (cn " of " (shen-dot-app (shen-dot-lazyderef V3838 V3840) "" (quote shen-dot-a))) (quote shen-dot-a)))) V3840 V3841))) Case)) Case))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-t*-rule [V3847 V3848 V3849 V3850 V3851] (clojure.core/let [Throwcontrol (shen-dot-catchpoint)] (shen-dot-cutpoint Throwcontrol (clojure.core/let [V3383 (shen-dot-lazyderef V3847 V3850)] (if (cons? V3383) (clojure.core/let [Patterns (hd V3383)] (clojure.core/let [V3384 (shen-dot-lazyderef (tl V3383) V3850)] (if (cons? V3384) (clojure.core/let [Action (hd V3384)] (clojure.core/let [V3385 (shen-dot-lazyderef (tl V3384) V3850)] (if (= () V3385) (clojure.core/let [NewHyps (shen-dot-newpv V3850)] (do (shen-dot-incinfs) (shen-dot-newhyps (shen-dot-placeholders Patterns) V3849 NewHyps V3850 (clojure.core/fn [] (shen-dot-t*-patterns Patterns V3848 NewHyps V3850 (clojure.core/fn [] (cut Throwcontrol V3850 (clojure.core/fn [] (shen-dot-t*-action (shen-dot-curry (shen-dot-ue Action)) (shen-dot-result-type Patterns V3848) (shen-dot-patthyps Patterns V3848 V3849) V3850 V3851))))))))) false))) false))) false))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-ue? cons cons? union shen-dot-placeholders hd tl) (clojure.core/defn shen-dot-placeholders [V3857] (clojure.core/cond (shen-dot-ue? V3857) (cons V3857 ()) (cons? V3857) (union (shen-dot-placeholders (hd V3857)) (shen-dot-placeholders (tl V3857))) true () :else (throw (Exception. "No matching cond clause"))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-newhyps [V3863 V3864 V3865 V3866 V3867] (clojure.core/let [Case (clojure.core/let [V3370 (shen-dot-lazyderef V3863 V3866)] (if (= () V3370) (do (shen-dot-incinfs) (unify! V3865 V3864 V3866 V3867)) false))] (if (= Case false) (clojure.core/let [V3371 (shen-dot-lazyderef V3863 V3866)] (if (cons? V3371) (clojure.core/let [V3366 (hd V3371)] (clojure.core/let [Vs (tl V3371)] (clojure.core/let [V3372 (shen-dot-lazyderef V3865 V3866)] (if (cons? V3372) (clojure.core/let [V3373 (shen-dot-lazyderef (hd V3372) V3866)] (if (cons? V3373) (clojure.core/let [V (hd V3373)] (clojure.core/let [V3374 (shen-dot-lazyderef (tl V3373) V3866)] (if (cons? V3374) (clojure.core/let [V3375 (shen-dot-lazyderef (hd V3374) V3866)] (if (= (quote -colon-) V3375) (clojure.core/let [V3376 (shen-dot-lazyderef (tl V3374) V3866)] (if (cons? V3376) (clojure.core/let [A (hd V3376)] (clojure.core/let [V3377 (shen-dot-lazyderef (tl V3376) V3866)] (if (= () V3377) (clojure.core/let [NewHyp (tl V3372)] (do (shen-dot-incinfs) (unify! V V3366 V3866 (clojure.core/fn [] (shen-dot-newhyps Vs V3864 NewHyp V3866 V3867))))) (if (shen-dot-pvar? V3377) (do (shen-dot-bindv V3377 () V3866) (clojure.core/let [Result (clojure.core/let [NewHyp (tl V3372)] (do (shen-dot-incinfs) (unify! V V3366 V3866 (clojure.core/fn [] (shen-dot-newhyps Vs V3864 NewHyp V3866 V3867)))))] (do (shen-dot-unbindv V3377 V3866) Result))) false)))) (if (shen-dot-pvar? V3376) (clojure.core/let [A (shen-dot-newpv V3866)] (do (shen-dot-bindv V3376 (cons A ()) V3866) (clojure.core/let [Result (clojure.core/let [NewHyp (tl V3372)] (do (shen-dot-incinfs) (unify! V V3366 V3866 (clojure.core/fn [] (shen-dot-newhyps Vs V3864 NewHyp V3866 V3867)))))] (do (shen-dot-unbindv V3376 V3866) Result)))) false))) (if (shen-dot-pvar? V3375) (do (shen-dot-bindv V3375 (quote -colon-) V3866) (clojure.core/let [Result (clojure.core/let [V3378 (shen-dot-lazyderef (tl V3374) V3866)] (if (cons? V3378) (clojure.core/let [A (hd V3378)] (clojure.core/let [V3379 (shen-dot-lazyderef (tl V3378) V3866)] (if (= () V3379) (clojure.core/let [NewHyp (tl V3372)] (do (shen-dot-incinfs) (unify! V V3366 V3866 (clojure.core/fn [] (shen-dot-newhyps Vs V3864 NewHyp V3866 V3867))))) (if (shen-dot-pvar? V3379) (do (shen-dot-bindv V3379 () V3866) (clojure.core/let [Result (clojure.core/let [NewHyp (tl V3372)] (do (shen-dot-incinfs) (unify! V V3366 V3866 (clojure.core/fn [] (shen-dot-newhyps Vs V3864 NewHyp V3866 V3867)))))] (do (shen-dot-unbindv V3379 V3866) Result))) false)))) (if (shen-dot-pvar? V3378) (clojure.core/let [A (shen-dot-newpv V3866)] (do (shen-dot-bindv V3378 (cons A ()) V3866) (clojure.core/let [Result (clojure.core/let [NewHyp (tl V3372)] (do (shen-dot-incinfs) (unify! V V3366 V3866 (clojure.core/fn [] (shen-dot-newhyps Vs V3864 NewHyp V3866 V3867)))))] (do (shen-dot-unbindv V3378 V3866) Result)))) false)))] (do (shen-dot-unbindv V3375 V3866) Result))) false))) (if (shen-dot-pvar? V3374) (clojure.core/let [A (shen-dot-newpv V3866)] (do (shen-dot-bindv V3374 (cons (quote -colon-) (cons A ())) V3866) (clojure.core/let [Result (clojure.core/let [NewHyp (tl V3372)] (do (shen-dot-incinfs) (unify! V V3366 V3866 (clojure.core/fn [] (shen-dot-newhyps Vs V3864 NewHyp V3866 V3867)))))] (do (shen-dot-unbindv V3374 V3866) Result)))) false)))) (if (shen-dot-pvar? V3373) (clojure.core/let [V (shen-dot-newpv V3866)] (clojure.core/let [A (shen-dot-newpv V3866)] (do (shen-dot-bindv V3373 (cons V (cons (quote -colon-) (cons A ()))) V3866) (clojure.core/let [Result (clojure.core/let [NewHyp (tl V3372)] (do (shen-dot-incinfs) (unify! V V3366 V3866 (clojure.core/fn [] (shen-dot-newhyps Vs V3864 NewHyp V3866 V3867)))))] (do (shen-dot-unbindv V3373 V3866) Result))))) false))) (if (shen-dot-pvar? V3372) (clojure.core/let [V (shen-dot-newpv V3866)] (clojure.core/let [A (shen-dot-newpv V3866)] (clojure.core/let [NewHyp (shen-dot-newpv V3866)] (do (shen-dot-bindv V3372 (cons (cons V (cons (quote -colon-) (cons A ()))) NewHyp) V3866) (clojure.core/let [Result (do (shen-dot-incinfs) (unify! V V3366 V3866 (clojure.core/fn [] (shen-dot-newhyps Vs V3864 NewHyp V3866 V3867))))] (do (shen-dot-unbindv V3372 V3866) Result)))))) false))))) false)) Case))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-patthyps [V3873 V3874 V3875] (clojure.core/cond (= () V3873) V3875 (clojure.core/and (cons? V3873) (clojure.core/and (cons? V3874) (clojure.core/and (cons? (tl V3874)) (clojure.core/and (= (quote -->) (hd (tl V3874))) (clojure.core/and (cons? (tl (tl V3874))) (= () (tl (tl (tl V3874))))))))) (adjoin (cons (hd V3873) (cons (quote -colon-) (cons (hd V3874) ()))) (shen-dot-patthyps (tl V3873) (hd (tl (tl V3874))) V3875)) true (shen-dot-f_error (quote shen-dot-patthyps)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-result-type [V3882 V3883] (clojure.core/cond (clojure.core/and (= () V3882) (clojure.core/and (cons? V3883) (clojure.core/and (= (quote -->) (hd V3883)) (clojure.core/and (cons? (tl V3883)) (= () (tl (tl V3883))))))) (hd (tl V3883)) (= () V3882) V3883 (clojure.core/and (cons? V3882) (clojure.core/and (cons? V3883) (clojure.core/and (cons? (tl V3883)) (clojure.core/and (= (quote -->) (hd (tl V3883))) (clojure.core/and (cons? (tl (tl V3883))) (= () (tl (tl (tl V3883))))))))) (shen-dot-result-type (tl V3882) (hd (tl (tl V3883)))) true (shen-dot-f_error (quote shen-dot-result-type)) :else (throw (Exception. "No matching cond clause")))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-t*-patterns [V3889 V3890 V3891 V3892 V3893] (clojure.core/let [Case (clojure.core/let [V3358 (shen-dot-lazyderef V3889 V3892)] (if (= () V3358) (do (shen-dot-incinfs) (thaw V3893)) false))] (if (= Case false) (clojure.core/let [V3359 (shen-dot-lazyderef V3889 V3892)] (if (cons? V3359) (clojure.core/let [Pattern (hd V3359)] (clojure.core/let [Patterns (tl V3359)] (clojure.core/let [V3360 (shen-dot-lazyderef V3890 V3892)] (if (cons? V3360) (clojure.core/let [A (hd V3360)] (clojure.core/let [V3361 (shen-dot-lazyderef (tl V3360) V3892)] (if (cons? V3361) (clojure.core/let [V3362 (shen-dot-lazyderef (hd V3361) V3892)] (if (= (quote -->) V3362) (clojure.core/let [V3363 (shen-dot-lazyderef (tl V3361) V3892)] (if (cons? V3363) (clojure.core/let [B (hd V3363)] (clojure.core/let [V3364 (shen-dot-lazyderef (tl V3363) V3892)] (if (= () V3364) (do (shen-dot-incinfs) (shen-dot-t* (cons Pattern (cons (quote -colon-) (cons A ()))) V3891 V3892 (clojure.core/fn [] (shen-dot-t*-patterns Patterns B V3891 V3892 V3893)))) false))) false)) false)) false))) false)))) false)) Case))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-t*-action [V3899 V3900 V3901 V3902 V3903] (clojure.core/let [Throwcontrol (shen-dot-catchpoint)] (shen-dot-cutpoint Throwcontrol (clojure.core/let [Case (clojure.core/let [V3335 (shen-dot-lazyderef V3899 V3902)] (if (cons? V3335) (clojure.core/let [V3336 (shen-dot-lazyderef (hd V3335) V3902)] (if (= (quote where) V3336) (clojure.core/let [V3337 (shen-dot-lazyderef (tl V3335) V3902)] (if (cons? V3337) (clojure.core/let [P (hd V3337)] (clojure.core/let [V3338 (shen-dot-lazyderef (tl V3337) V3902)] (if (cons? V3338) (clojure.core/let [Action (hd V3338)] (clojure.core/let [V3339 (shen-dot-lazyderef (tl V3338) V3902)] (if (= () V3339) (do (shen-dot-incinfs) (cut Throwcontrol V3902 (clojure.core/fn [] (shen-dot-t* (cons P (cons (quote -colon-) (cons (quote boolean) ()))) V3901 V3902 (clojure.core/fn [] (cut Throwcontrol V3902 (clojure.core/fn [] (shen-dot-t*-action Action V3900 (cons (cons P (cons (quote -colon-) (cons (quote verified) ()))) V3901) V3902 V3903)))))))) false))) false))) false)) false)) false))] (if (= Case false) (clojure.core/let [Case (clojure.core/let [V3340 (shen-dot-lazyderef V3899 V3902)] (if (cons? V3340) (clojure.core/let [V3341 (shen-dot-lazyderef (hd V3340) V3902)] (if (= (quote shen-dot-choicepoint!) V3341) (clojure.core/let [V3342 (shen-dot-lazyderef (tl V3340) V3902)] (if (cons? V3342) (clojure.core/let [V3343 (shen-dot-lazyderef (hd V3342) V3902)] (if (cons? V3343) (clojure.core/let [V3344 (shen-dot-lazyderef (hd V3343) V3902)] (if (cons? V3344) (clojure.core/let [V3345 (shen-dot-lazyderef (hd V3344) V3902)] (if (= (quote fail-if) V3345) (clojure.core/let [V3346 (shen-dot-lazyderef (tl V3344) V3902)] (if (cons? V3346) (clojure.core/let [F (hd V3346)] (clojure.core/let [V3347 (shen-dot-lazyderef (tl V3346) V3902)] (if (= () V3347) (clojure.core/let [V3348 (shen-dot-lazyderef (tl V3343) V3902)] (if (cons? V3348) (clojure.core/let [Action (hd V3348)] (clojure.core/let [V3349 (shen-dot-lazyderef (tl V3348) V3902)] (if (= () V3349) (clojure.core/let [V3350 (shen-dot-lazyderef (tl V3342) V3902)] (if (= () V3350) (do (shen-dot-incinfs) (cut Throwcontrol V3902 (clojure.core/fn [] (shen-dot-t*-action (cons (quote where) (cons (cons (quote not) (cons (cons F (cons Action ())) ())) (cons Action ()))) V3900 V3901 V3902 V3903)))) false)) false))) false)) false))) false)) false)) false)) false)) false)) false)) false))] (if (= Case false) (clojure.core/let [Case (clojure.core/let [V3351 (shen-dot-lazyderef V3899 V3902)] (if (cons? V3351) (clojure.core/let [V3352 (shen-dot-lazyderef (hd V3351) V3902)] (if (= (quote shen-dot-choicepoint!) V3352) (clojure.core/let [V3353 (shen-dot-lazyderef (tl V3351) V3902)] (if (cons? V3353) (clojure.core/let [Action (hd V3353)] (clojure.core/let [V3354 (shen-dot-lazyderef (tl V3353) V3902)] (if (= () V3354) (do (shen-dot-incinfs) (cut Throwcontrol V3902 (clojure.core/fn [] (shen-dot-t*-action (cons (quote where) (cons (cons (quote not) (cons (cons (cons (quote =) (cons Action ())) (cons (cons (quote fail) ()) ())) ())) (cons Action ()))) V3900 V3901 V3902 V3903)))) false))) false)) false)) false))] (if (= Case false) (do (shen-dot-incinfs) (shen-dot-t* (cons V3899 (cons (quote -colon-) (cons V3900 ()))) V3901 V3902 V3903)) Case)) Case)) Case))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried findall [V3909 V3910 V3911 V3912 V3913] (clojure.core/let [B (shen-dot-newpv V3912)] (clojure.core/let [A (shen-dot-newpv V3912)] (do (shen-dot-incinfs) (bind A (gensym (quote shen-dot-a)) V3912 (clojure.core/fn [] (bind B (set (shen-dot-lazyderef A V3912) ()) V3912 (clojure.core/fn [] (shen-dot-findallhelp V3909 V3910 V3911 A V3912 V3913))))))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-findallhelp [V3920 V3921 V3922 V3923 V3924 V3925] (clojure.core/let [Case (do (shen-dot-incinfs) (call V3921 V3924 (clojure.core/fn [] (shen-dot-remember V3923 V3920 V3924 (clojure.core/fn [] (fwhen false V3924 V3925))))))] (if (= Case false) (do (shen-dot-incinfs) (bind V3922 (value (shen-dot-lazyderef V3923 V3924)) V3924 V3925)) Case))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-remember [V3930 V3931 V3932 V3933] (clojure.core/let [B (shen-dot-newpv V3932)] (do (shen-dot-incinfs) (bind B (set (shen-dot-deref V3930 V3932) (cons (shen-dot-deref V3931 V3932) (value (shen-dot-deref V3930 V3932)))) V3932 V3933)))))
(clojure.core/comment types.kl)
(clojure.core/comment "Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.")
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried declare [V4123 V4124] (clojure.core/let [Record (set (quote shen-dot-*signedfuncs*) (cons (cons V4123 V4124) (value (quote shen-dot-*signedfuncs*))))] (clojure.core/let [Variancy (try (shen-dot-variancy-test V4123 V4124) (catch Exception e8043 ((clojure.core/fn [E] (quote shen-dot-skip)) e8043)))] (clojure.core/let [Type (shen-dot-rcons_form (shen-dot-demodulate V4124))] (clojure.core/let [F* (concat (quote shen-dot-type-signature-of-) V4123)] (clojure.core/let [Parameters (shen-dot-parameters 1)] (clojure.core/let [Clause (cons (cons F* (cons (quote X) ())) (cons (quote -colon--) (cons (cons (cons (quote unify!) (cons (quote X) (cons Type ()))) ()) ())))] (clojure.core/let [AUM_instruction (shen-dot-aum Clause Parameters)] (clojure.core/let [Code (shen-dot-aum_to_shen AUM_instruction)] (clojure.core/let [ShenDef (cons (quote define) (cons F* (append Parameters (append (cons (quote ProcessN) (cons (quote Continuation) ())) (cons (quote ->) (cons Code ()))))))] (clojure.core/let [Eval (shen-dot-eval-without-macros ShenDef)] V4123))))))))))))
(shen-port.primitives/with-ns (quote shen.functions) (do (clojure.core/declare shen-dot-walk value = shen-dot-demodulate) (clojure.core/defn shen-dot-demodulate [V4126] (clojure.core/let [Demod (shen-dot-walk (value (quote shen-dot-*demodulation-function*)) V4126)] (if (= Demod V4126) V4126 (shen-dot-demodulate Demod))))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-variancy-test [V4129 V4130] (clojure.core/let [TypeF (shen-dot-typecheck V4129 (quote B))] (clojure.core/let [Check (if (= (quote symbol) TypeF) (quote shen-dot-skip) (if (shen-dot-variant? TypeF V4130) (quote shen-dot-skip) (shen-dot-prhush (cn "warning: changing the type of " (shen-dot-app V4129 " may create errors\n" (quote shen-dot-a))) (stoutput))))] (quote shen-dot-skip)))))
(shen-port.primitives/with-ns (quote shen.functions) (shen-port.primitives/defn-curried shen-dot-variant? [V4143 V4144] (clojure.core/cond (= V4144 V4143) true (clojure.core/and (cons? V4143) (clojure.core/and (cons? V4144) (= (hd V4144) (hd V4143)))) (shen-dot-variant? (tl V4143) (tl V4144)) (clojure.core/and (cons? V4143) (clojure.core/and (cons? V4144) (clojure.core/and (shen-dot-pvar? (hd V4143)) (variable? (hd V4144))))) (shen-dot-variant? (subst (quote shen-dot-a) (hd V4143) (tl V4143)) (subst (quote shen-dot-a) (hd V4144) (tl V4144))) (clojure.core/and (cons? V4143) (clojure.core/and (cons? (hd V4143)) (clojure.core/and (cons? V4144) (cons? (hd V4144))))) (shen-dot-variant? (append (hd V4143) (tl V4143)) (append (hd V4144) (tl V4144))) true false :else (throw (Exception. "No matching cond clause")))))
(declare (quote absvector?) (cons (quote A) (cons (quote -->) (cons (quote boolean) ()))))
(declare (quote adjoin) (cons (quote A) (cons (quote -->) (cons (cons (cons (quote list) (cons (quote A) ())) (cons (quote -->) (cons (cons (quote list) (cons (quote A) ())) ()))) ()))))
(declare (quote and) (cons (quote boolean) (cons (quote -->) (cons (cons (quote boolean) (cons (quote -->) (cons (quote boolean) ()))) ()))))
(declare (quote shen-dot-app) (cons (quote A) (cons (quote -->) (cons (cons (quote string) (cons (quote -->) (cons (cons (quote symbol) (cons (quote -->) (cons (quote string) ()))) ()))) ()))))
(declare (quote append) (cons (cons (quote list) (cons (quote A) ())) (cons (quote -->) (cons (cons (cons (quote list) (cons (quote A) ())) (cons (quote -->) (cons (cons (quote list) (cons (quote A) ())) ()))) ()))))
(declare (quote arity) (cons (quote A) (cons (quote -->) (cons (quote number) ()))))
(declare (quote assoc) (cons (quote A) (cons (quote -->) (cons (cons (cons (quote list) (cons (cons (quote list) (cons (quote A) ())) ())) (cons (quote -->) (cons (cons (quote list) (cons (quote A) ())) ()))) ()))))
(declare (quote boolean?) (cons (quote A) (cons (quote -->) (cons (quote boolean) ()))))
(declare (quote bound?) (cons (quote symbol) (cons (quote -->) (cons (quote boolean) ()))))
(declare (quote cd) (cons (quote string) (cons (quote -->) (cons (quote string) ()))))
(declare (quote close) (cons (cons (quote stream) (cons (quote A) ())) (cons (quote -->) (cons (cons (quote list) (cons (quote B) ())) ()))))
(declare (quote cn) (cons (quote string) (cons (quote -->) (cons (cons (quote string) (cons (quote -->) (cons (quote string) ()))) ()))))
(declare (quote compile) (cons (cons (quote A) (cons (quote shen-dot-==>) (cons (quote B) ()))) (cons (quote -->) (cons (cons (quote A) (cons (quote -->) (cons (cons (cons (quote A) (cons (quote -->) (cons (quote B) ()))) (cons (quote -->) (cons (quote B) ()))) ()))) ()))))
(declare (quote cons?) (cons (quote A) (cons (quote -->) (cons (quote boolean) ()))))
(declare (quote destroy) (cons (cons (quote A) (cons (quote -->) (cons (quote B) ()))) (cons (quote -->) (cons (quote symbol) ()))))
(declare (quote difference) (cons (cons (quote list) (cons (quote A) ())) (cons (quote -->) (cons (cons (cons (quote list) (cons (quote A) ())) (cons (quote -->) (cons (cons (quote list) (cons (quote A) ())) ()))) ()))))
(declare (quote do) (cons (quote A) (cons (quote -->) (cons (cons (quote B) (cons (quote -->) (cons (quote B) ()))) ()))))
(declare (quote <e>) (cons (cons (quote list) (cons (quote A) ())) (cons (quote shen-dot-==>) (cons (cons (quote list) (cons (quote B) ())) ()))))
(declare (quote <!>) (cons (cons (quote list) (cons (quote A) ())) (cons (quote shen-dot-==>) (cons (cons (quote list) (cons (quote A) ())) ()))))
(declare (quote element?) (cons (quote A) (cons (quote -->) (cons (cons (cons (quote list) (cons (quote A) ())) (cons (quote -->) (cons (quote boolean) ()))) ()))))
(declare (quote empty?) (cons (quote A) (cons (quote -->) (cons (quote boolean) ()))))
(declare (quote enable-type-theory) (cons (quote symbol) (cons (quote -->) (cons (quote boolean) ()))))
(declare (quote external) (cons (quote symbol) (cons (quote -->) (cons (cons (quote list) (cons (quote symbol) ())) ()))))
(declare (quote error-to-string) (cons (quote exception) (cons (quote -->) (cons (quote string) ()))))
(declare (quote explode) (cons (quote A) (cons (quote -->) (cons (cons (quote list) (cons (quote string) ())) ()))))
(declare (quote fail) (cons (quote -->) (cons (quote symbol) ())))
(declare (quote fail-if) (cons (cons (quote symbol) (cons (quote -->) (cons (quote boolean) ()))) (cons (quote -->) (cons (cons (quote symbol) (cons (quote -->) (cons (quote symbol) ()))) ()))))
(declare (quote fix) (cons (cons (quote A) (cons (quote -->) (cons (quote A) ()))) (cons (quote -->) (cons (cons (quote A) (cons (quote -->) (cons (quote A) ()))) ()))))
(declare (quote freeze) (cons (quote A) (cons (quote -->) (cons (cons (quote lazy) (cons (quote A) ())) ()))))
(declare (quote fst) (cons (cons (quote A) (cons (quote *) (cons (quote B) ()))) (cons (quote -->) (cons (quote A) ()))))
(declare (quote function) (cons (cons (quote A) (cons (quote -->) (cons (quote B) ()))) (cons (quote -->) (cons (cons (quote A) (cons (quote -->) (cons (quote B) ()))) ()))))
(declare (quote gensym) (cons (quote symbol) (cons (quote -->) (cons (quote symbol) ()))))
(declare (quote <-vector) (cons (cons (quote vector) (cons (quote A) ())) (cons (quote -->) (cons (cons (quote number) (cons (quote -->) (cons (quote A) ()))) ()))))
(declare (quote vector->) (cons (cons (quote vector) (cons (quote A) ())) (cons (quote -->) (cons (cons (quote number) (cons (quote -->) (cons (cons (quote A) (cons (quote -->) (cons (cons (quote vector) (cons (quote A) ())) ()))) ()))) ()))))
(declare (quote vector) (cons (quote number) (cons (quote -->) (cons (cons (quote vector) (cons (quote A) ())) ()))))
(declare (quote get-time) (cons (quote symbol) (cons (quote -->) (cons (quote number) ()))))
(declare (quote hash) (cons (quote A) (cons (quote -->) (cons (cons (quote number) (cons (quote -->) (cons (quote number) ()))) ()))))
(declare (quote head) (cons (cons (quote list) (cons (quote A) ())) (cons (quote -->) (cons (quote A) ()))))
(declare (quote hdv) (cons (cons (quote vector) (cons (quote A) ())) (cons (quote -->) (cons (quote A) ()))))
(declare (quote hdstr) (cons (quote string) (cons (quote -->) (cons (quote string) ()))))
(declare (quote if) (cons (quote boolean) (cons (quote -->) (cons (cons (quote A) (cons (quote -->) (cons (cons (quote A) (cons (quote -->) (cons (quote A) ()))) ()))) ()))))
(declare (quote it) (cons (quote -->) (cons (quote string) ())))
(declare (quote implementation) (cons (quote -->) (cons (quote string) ())))
(declare (quote include) (cons (cons (quote list) (cons (quote symbol) ())) (cons (quote -->) (cons (cons (quote list) (cons (quote symbol) ())) ()))))
(declare (quote include-all-but) (cons (cons (quote list) (cons (quote symbol) ())) (cons (quote -->) (cons (cons (quote list) (cons (quote symbol) ())) ()))))
(declare (quote inferences) (cons (quote -->) (cons (quote number) ())))
(declare (quote shen-dot-insert) (cons (quote A) (cons (quote -->) (cons (cons (quote string) (cons (quote -->) (cons (quote string) ()))) ()))))
(declare (quote integer?) (cons (quote A) (cons (quote -->) (cons (quote boolean) ()))))
(declare (quote internal) (cons (quote symbol) (cons (quote -->) (cons (cons (quote list) (cons (quote symbol) ())) ()))))
(declare (quote intersection) (cons (cons (quote list) (cons (quote A) ())) (cons (quote -->) (cons (cons (cons (quote list) (cons (quote A) ())) (cons (quote -->) (cons (cons (quote list) (cons (quote A) ())) ()))) ()))))
(declare (quote kill) (cons (quote -->) (cons (quote A) ())))
(declare (quote language) (cons (quote -->) (cons (quote string) ())))
(declare (quote length) (cons (cons (quote list) (cons (quote A) ())) (cons (quote -->) (cons (quote number) ()))))
(declare (quote limit) (cons (cons (quote vector) (cons (quote A) ())) (cons (quote -->) (cons (quote number) ()))))
(declare (quote load) (cons (quote string) (cons (quote -->) (cons (quote symbol) ()))))
(declare (quote map) (cons (cons (quote A) (cons (quote -->) (cons (quote B) ()))) (cons (quote -->) (cons (cons (cons (quote list) (cons (quote A) ())) (cons (quote -->) (cons (cons (quote list) (cons (quote B) ())) ()))) ()))))
(declare (quote mapcan) (cons (cons (quote A) (cons (quote -->) (cons (cons (quote list) (cons (quote B) ())) ()))) (cons (quote -->) (cons (cons (cons (quote list) (cons (quote A) ())) (cons (quote -->) (cons (cons (quote list) (cons (quote B) ())) ()))) ()))))
(declare (quote maxinferences) (cons (quote number) (cons (quote -->) (cons (quote number) ()))))
(declare (quote n->string) (cons (quote number) (cons (quote -->) (cons (quote string) ()))))
(declare (quote nl) (cons (quote number) (cons (quote -->) (cons (quote number) ()))))
(declare (quote not) (cons (quote boolean) (cons (quote -->) (cons (quote boolean) ()))))
(declare (quote nth) (cons (quote number) (cons (quote -->) (cons (cons (cons (quote list) (cons (quote A) ())) (cons (quote -->) (cons (quote A) ()))) ()))))
(declare (quote number?) (cons (quote A) (cons (quote -->) (cons (quote boolean) ()))))
(declare (quote occurrences) (cons (quote A) (cons (quote -->) (cons (cons (quote B) (cons (quote -->) (cons (quote number) ()))) ()))))
(declare (quote occurs-check) (cons (quote symbol) (cons (quote -->) (cons (quote boolean) ()))))
(declare (quote optimise) (cons (quote symbol) (cons (quote -->) (cons (quote boolean) ()))))
(declare (quote or) (cons (quote boolean) (cons (quote -->) (cons (cons (quote boolean) (cons (quote -->) (cons (quote boolean) ()))) ()))))
(declare (quote os) (cons (quote -->) (cons (quote string) ())))
(declare (quote package?) (cons (quote symbol) (cons (quote -->) (cons (quote boolean) ()))))
(declare (quote port) (cons (quote -->) (cons (quote string) ())))
(declare (quote porters) (cons (quote -->) (cons (quote string) ())))
(declare (quote pos) (cons (quote string) (cons (quote -->) (cons (cons (quote number) (cons (quote -->) (cons (quote string) ()))) ()))))
(declare (quote pr) (cons (quote string) (cons (quote -->) (cons (cons (cons (quote stream) (cons (quote out) ())) (cons (quote -->) (cons (quote string) ()))) ()))))
(declare (quote print) (cons (quote A) (cons (quote -->) (cons (quote A) ()))))
(declare (quote profile) (cons (cons (quote A) (cons (quote -->) (cons (quote B) ()))) (cons (quote -->) (cons (cons (quote A) (cons (quote -->) (cons (quote B) ()))) ()))))
(declare (quote preclude) (cons (cons (quote list) (cons (quote symbol) ())) (cons (quote -->) (cons (cons (quote list) (cons (quote symbol) ())) ()))))
(declare (quote shen-dot-proc-nl) (cons (quote string) (cons (quote -->) (cons (quote string) ()))))
(declare (quote profile-results) (cons (cons (quote A) (cons (quote -->) (cons (quote B) ()))) (cons (quote -->) (cons (cons (cons (quote A) (cons (quote -->) (cons (quote B) ()))) (cons (quote *) (cons (quote number) ()))) ()))))
(declare (quote protect) (cons (quote symbol) (cons (quote -->) (cons (quote symbol) ()))))
(declare (quote preclude-all-but) (cons (cons (quote list) (cons (quote symbol) ())) (cons (quote -->) (cons (cons (quote list) (cons (quote symbol) ())) ()))))
(declare (quote shen-dot-prhush) (cons (quote string) (cons (quote -->) (cons (cons (cons (quote stream) (cons (quote out) ())) (cons (quote -->) (cons (quote string) ()))) ()))))
(declare (quote ps) (cons (quote symbol) (cons (quote -->) (cons (cons (quote list) (cons (quote unit) ())) ()))))
(declare (quote read) (cons (cons (quote stream) (cons (quote in) ())) (cons (quote -->) (cons (quote unit) ()))))
(declare (quote read-byte) (cons (cons (quote stream) (cons (quote in) ())) (cons (quote -->) (cons (quote number) ()))))
(declare (quote read-file-as-bytelist) (cons (quote string) (cons (quote -->) (cons (cons (quote list) (cons (quote number) ())) ()))))
(declare (quote read-file-as-string) (cons (quote string) (cons (quote -->) (cons (quote string) ()))))
(declare (quote read-file) (cons (quote string) (cons (quote -->) (cons (cons (quote list) (cons (quote unit) ())) ()))))
(declare (quote read-from-string) (cons (quote string) (cons (quote -->) (cons (cons (quote list) (cons (quote unit) ())) ()))))
(declare (quote release) (cons (quote -->) (cons (quote string) ())))
(declare (quote remove) (cons (quote A) (cons (quote -->) (cons (cons (cons (quote list) (cons (quote A) ())) (cons (quote -->) (cons (cons (quote list) (cons (quote A) ())) ()))) ()))))
(declare (quote reverse) (cons (cons (quote list) (cons (quote A) ())) (cons (quote -->) (cons (cons (quote list) (cons (quote A) ())) ()))))
(declare (quote simple-error) (cons (quote string) (cons (quote -->) (cons (quote A) ()))))
(declare (quote snd) (cons (cons (quote A) (cons (quote *) (cons (quote B) ()))) (cons (quote -->) (cons (quote B) ()))))
(declare (quote specialise) (cons (quote symbol) (cons (quote -->) (cons (quote symbol) ()))))
(declare (quote spy) (cons (quote symbol) (cons (quote -->) (cons (quote boolean) ()))))
(declare (quote step) (cons (quote symbol) (cons (quote -->) (cons (quote boolean) ()))))
(declare (quote stinput) (cons (quote -->) (cons (cons (quote stream) (cons (quote in) ())) ())))
(declare (quote sterror) (cons (quote -->) (cons (cons (quote stream) (cons (quote out) ())) ())))
(declare (quote stoutput) (cons (quote -->) (cons (cons (quote stream) (cons (quote out) ())) ())))
(declare (quote string?) (cons (quote A) (cons (quote -->) (cons (quote boolean) ()))))
(declare (quote str) (cons (quote A) (cons (quote -->) (cons (quote string) ()))))
(declare (quote string->n) (cons (quote string) (cons (quote -->) (cons (quote number) ()))))
(declare (quote string->symbol) (cons (quote string) (cons (quote -->) (cons (quote symbol) ()))))
(declare (quote sum) (cons (cons (quote list) (cons (quote number) ())) (cons (quote -->) (cons (quote number) ()))))
(declare (quote symbol?) (cons (quote A) (cons (quote -->) (cons (quote boolean) ()))))
(declare (quote systemf) (cons (quote symbol) (cons (quote -->) (cons (quote symbol) ()))))
(declare (quote tail) (cons (cons (quote list) (cons (quote A) ())) (cons (quote -->) (cons (cons (quote list) (cons (quote A) ())) ()))))
(declare (quote tlstr) (cons (quote string) (cons (quote -->) (cons (quote string) ()))))
(declare (quote tlv) (cons (cons (quote vector) (cons (quote A) ())) (cons (quote -->) (cons (cons (quote vector) (cons (quote A) ())) ()))))
(declare (quote tc) (cons (quote symbol) (cons (quote -->) (cons (quote boolean) ()))))
(declare (quote tc?) (cons (quote -->) (cons (quote boolean) ())))
(declare (quote thaw) (cons (cons (quote lazy) (cons (quote A) ())) (cons (quote -->) (cons (quote A) ()))))
(declare (quote track) (cons (quote symbol) (cons (quote -->) (cons (quote symbol) ()))))
(declare (quote trap-error) (cons (quote A) (cons (quote -->) (cons (cons (cons (quote exception) (cons (quote -->) (cons (quote A) ()))) (cons (quote -->) (cons (quote A) ()))) ()))))
(declare (quote tuple?) (cons (quote A) (cons (quote -->) (cons (quote boolean) ()))))
(declare (quote undefmacro) (cons (quote symbol) (cons (quote -->) (cons (quote symbol) ()))))
(declare (quote union) (cons (cons (quote list) (cons (quote A) ())) (cons (quote -->) (cons (cons (cons (quote list) (cons (quote A) ())) (cons (quote -->) (cons (cons (quote list) (cons (quote A) ())) ()))) ()))))
(declare (quote unprofile) (cons (cons (quote A) (cons (quote -->) (cons (quote B) ()))) (cons (quote -->) (cons (cons (quote A) (cons (quote -->) (cons (quote B) ()))) ()))))
(declare (quote untrack) (cons (quote symbol) (cons (quote -->) (cons (quote symbol) ()))))
(declare (quote unspecialise) (cons (quote symbol) (cons (quote -->) (cons (quote symbol) ()))))
(declare (quote variable?) (cons (quote A) (cons (quote -->) (cons (quote boolean) ()))))
(declare (quote vector?) (cons (quote A) (cons (quote -->) (cons (quote boolean) ()))))
(declare (quote version) (cons (quote -->) (cons (quote string) ())))
(declare (quote write-to-file) (cons (quote string) (cons (quote -->) (cons (cons (quote A) (cons (quote -->) (cons (quote A) ()))) ()))))
(declare (quote write-byte) (cons (quote number) (cons (quote -->) (cons (cons (cons (quote stream) (cons (quote out) ())) (cons (quote -->) (cons (quote number) ()))) ()))))
(declare (quote y-or-n?) (cons (quote string) (cons (quote -->) (cons (quote boolean) ()))))
(declare (quote >) (cons (quote number) (cons (quote -->) (cons (cons (quote number) (cons (quote -->) (cons (quote boolean) ()))) ()))))
(declare (quote <) (cons (quote number) (cons (quote -->) (cons (cons (quote number) (cons (quote -->) (cons (quote boolean) ()))) ()))))
(declare (quote >=) (cons (quote number) (cons (quote -->) (cons (cons (quote number) (cons (quote -->) (cons (quote boolean) ()))) ()))))
(declare (quote <=) (cons (quote number) (cons (quote -->) (cons (cons (quote number) (cons (quote -->) (cons (quote boolean) ()))) ()))))
(declare (quote =) (cons (quote A) (cons (quote -->) (cons (cons (quote A) (cons (quote -->) (cons (quote boolean) ()))) ()))))
(declare (quote +) (cons (quote number) (cons (quote -->) (cons (cons (quote number) (cons (quote -->) (cons (quote number) ()))) ()))))
(declare (quote /) (cons (quote number) (cons (quote -->) (cons (cons (quote number) (cons (quote -->) (cons (quote number) ()))) ()))))
(declare (quote -) (cons (quote number) (cons (quote -->) (cons (cons (quote number) (cons (quote -->) (cons (quote number) ()))) ()))))
(declare (quote *) (cons (quote number) (cons (quote -->) (cons (cons (quote number) (cons (quote -->) (cons (quote number) ()))) ()))))
(declare (quote ==) (cons (quote A) (cons (quote -->) (cons (cons (quote B) (cons (quote -->) (cons (quote boolean) ()))) ()))))
(clojure.core/defn -main [] (shen-dot-shen))